{
  "language": "Solidity",
  "sources": {
    "contracts/test/uniswap/core/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.5.0;\n\ninterface IERC20 {\n\tevent Approval(address indexed owner, address indexed spender, uint value);\n\tevent Transfer(address indexed from, address indexed to, uint value);\n\n\tfunction name() external view returns (string memory);\n\n\tfunction symbol() external view returns (string memory);\n\n\tfunction decimals() external view returns (uint8);\n\n\tfunction totalSupply() external view returns (uint);\n\n\tfunction balanceOf(address owner) external view returns (uint);\n\n\tfunction allowance(address owner, address spender) external view returns (uint);\n\n\tfunction approve(address spender, uint value) external returns (bool);\n\n\tfunction transfer(address to, uint value) external returns (bool);\n\n\tfunction transferFrom(address from, address to, uint value) external returns (bool);\n}\n"
    },
    "contracts/test/uniswap/core/interfaces/IUniswapV2Callee.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.5.0;\n\ninterface IUniswapV2Callee {\n\tfunction uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;\n}\n"
    },
    "contracts/test/uniswap/core/interfaces/IUniswapV2ERC20.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.5.0;\n\ninterface IUniswapV2ERC20 {\n\tevent Approval(address indexed owner, address indexed spender, uint value);\n\tevent Transfer(address indexed from, address indexed to, uint value);\n\n\tfunction name() external pure returns (string memory);\n\n\tfunction symbol() external pure returns (string memory);\n\n\tfunction decimals() external pure returns (uint8);\n\n\tfunction totalSupply() external view returns (uint);\n\n\tfunction balanceOf(address owner) external view returns (uint);\n\n\tfunction allowance(address owner, address spender) external view returns (uint);\n\n\tfunction approve(address spender, uint value) external returns (bool);\n\n\tfunction transfer(address to, uint value) external returns (bool);\n\n\tfunction transferFrom(address from, address to, uint value) external returns (bool);\n\n\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\n\n\tfunction PERMIT_TYPEHASH() external pure returns (bytes32);\n\n\tfunction nonces(address owner) external view returns (uint);\n\n\tfunction permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n}\n"
    },
    "contracts/test/uniswap/core/interfaces/IUniswapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n\tevent PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n\tfunction feeTo() external view returns (address);\n\n\tfunction feeToSetter() external view returns (address);\n\n\tfunction getPair(address tokenA, address tokenB) external view returns (address pair);\n\n\tfunction allPairs(uint) external view returns (address pair);\n\n\tfunction allPairsLength() external view returns (uint);\n\n\tfunction createPair(address tokenA, address tokenB) external returns (address pair);\n\n\tfunction setFeeTo(address) external;\n\n\tfunction setFeeToSetter(address) external;\n\n\tfunction getInitHash() external view returns (bytes32);\n}\n"
    },
    "contracts/test/uniswap/core/interfaces/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n\tevent Approval(address indexed owner, address indexed spender, uint value);\n\tevent Transfer(address indexed from, address indexed to, uint value);\n\n\tfunction name() external pure returns (string memory);\n\n\tfunction symbol() external pure returns (string memory);\n\n\tfunction decimals() external pure returns (uint8);\n\n\tfunction totalSupply() external view returns (uint);\n\n\tfunction balanceOf(address owner) external view returns (uint);\n\n\tfunction allowance(address owner, address spender) external view returns (uint);\n\n\tfunction approve(address spender, uint value) external returns (bool);\n\n\tfunction transfer(address to, uint value) external returns (bool);\n\n\tfunction transferFrom(address from, address to, uint value) external returns (bool);\n\n\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\n\n\tfunction PERMIT_TYPEHASH() external pure returns (bytes32);\n\n\tfunction nonces(address owner) external view returns (uint);\n\n\tfunction permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n\tevent Mint(address indexed sender, uint amount0, uint amount1);\n\tevent Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n\tevent Swap(\n\t\taddress indexed sender,\n\t\tuint amount0In,\n\t\tuint amount1In,\n\t\tuint amount0Out,\n\t\tuint amount1Out,\n\t\taddress indexed to\n\t);\n\tevent Sync(uint112 reserve0, uint112 reserve1);\n\n\tfunction MINIMUM_LIQUIDITY() external pure returns (uint);\n\n\tfunction factory() external view returns (address);\n\n\tfunction token0() external view returns (address);\n\n\tfunction token1() external view returns (address);\n\n\tfunction getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n\n\tfunction price0CumulativeLast() external view returns (uint);\n\n\tfunction price1CumulativeLast() external view returns (uint);\n\n\tfunction kLast() external view returns (uint);\n\n\tfunction mint(address to) external returns (uint liquidity);\n\n\tfunction burn(address to) external returns (uint amount0, uint amount1);\n\n\tfunction swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n\n\tfunction skim(address to) external;\n\n\tfunction sync() external;\n\n\tfunction initialize(address, address) external;\n}\n"
    },
    "contracts/test/uniswap/core/libraries/Math.sol": {
      "content": "pragma solidity 0.6.6;\n\n// a library for performing various math operations\n\nlibrary Math {\n\tfunction min(uint x, uint y) internal pure returns (uint z) {\n\t\tz = x < y ? x : y;\n\t}\n\n\t// babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n\tfunction sqrt(uint y) internal pure returns (uint z) {\n\t\tif (y > 3) {\n\t\t\tz = y;\n\t\t\tuint x = y / 2 + 1;\n\t\t\twhile (x < z) {\n\t\t\t\tz = x;\n\t\t\t\tx = (y / x + x) / 2;\n\t\t\t}\n\t\t} else if (y != 0) {\n\t\t\tz = 1;\n\t\t}\n\t}\n}\n"
    },
    "contracts/test/uniswap/core/libraries/SafeMath.sol": {
      "content": "pragma solidity 0.6.6;\n\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n\nlibrary SafeMath {\n\tfunction add(uint x, uint y) internal pure returns (uint z) {\n\t\trequire((z = x + y) >= x, \"ds-math-add-overflow\");\n\t}\n\n\tfunction sub(uint x, uint y) internal pure returns (uint z) {\n\t\trequire((z = x - y) <= x, \"ds-math-sub-underflow\");\n\t}\n\n\tfunction mul(uint x, uint y) internal pure returns (uint z) {\n\t\trequire(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n\t}\n}\n"
    },
    "contracts/test/uniswap/core/libraries/UQ112x112.sol": {
      "content": "pragma solidity 0.6.6;\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\n\n// range: [0, 2**112 - 1]\n// resolution: 1 / 2**112\n\nlibrary UQ112x112 {\n\tuint224 constant Q112 = 2 ** 112;\n\n\t// encode a uint112 as a UQ112x112\n\tfunction encode(uint112 y) internal pure returns (uint224 z) {\n\t\tz = uint224(y) * Q112; // never overflows\n\t}\n\n\t// divide a UQ112x112 by a uint112, returning a UQ112x112\n\tfunction uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\n\t\tz = x / uint224(y);\n\t}\n}\n"
    },
    "contracts/test/uniswap/core/UniswapV2ERC20.sol": {
      "content": "pragma solidity 0.6.6;\n\nimport \"./interfaces/IUniswapV2ERC20.sol\";\nimport \"./libraries/SafeMath.sol\";\n\ncontract UniswapV2ERC20 {\n\tusing SafeMath for uint;\n\n\tstring public constant name = \"Uniswap V2\";\n\tstring public constant symbol = \"UNI-V2\";\n\tuint8 public constant decimals = 18;\n\tuint public totalSupply;\n\tmapping(address => uint) public balanceOf;\n\tmapping(address => mapping(address => uint)) public allowance;\n\n\tbytes32 public DOMAIN_SEPARATOR;\n\t// keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\tbytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\tmapping(address => uint) public nonces;\n\n\tevent Approval(address indexed owner, address indexed spender, uint value);\n\tevent Transfer(address indexed from, address indexed to, uint value);\n\n\tconstructor() public {\n\t\tuint chainId;\n\t\t// solhint-disable-next-line no-inline-assembly\n\t\tassembly {\n\t\t\tchainId := chainid()\n\t\t}\n\t\tDOMAIN_SEPARATOR = keccak256(\n\t\t\tabi.encode(\n\t\t\t\tkeccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n\t\t\t\tkeccak256(bytes(name)),\n\t\t\t\tkeccak256(bytes(\"1\")),\n\t\t\t\tchainId,\n\t\t\t\taddress(this)\n\t\t\t)\n\t\t);\n\t}\n\n\tfunction _mint(address to, uint value) internal {\n\t\ttotalSupply = totalSupply.add(value);\n\t\tbalanceOf[to] = balanceOf[to].add(value);\n\t\temit Transfer(address(0), to, value);\n\t}\n\n\tfunction _burn(address from, uint value) internal {\n\t\tbalanceOf[from] = balanceOf[from].sub(value);\n\t\ttotalSupply = totalSupply.sub(value);\n\t\temit Transfer(from, address(0), value);\n\t}\n\n\tfunction _approve(address owner, address spender, uint value) private {\n\t\tallowance[owner][spender] = value;\n\t\temit Approval(owner, spender, value);\n\t}\n\n\tfunction _transfer(address from, address to, uint value) private {\n\t\tbalanceOf[from] = balanceOf[from].sub(value);\n\t\tbalanceOf[to] = balanceOf[to].add(value);\n\t\temit Transfer(from, to, value);\n\t}\n\n\tfunction approve(address spender, uint value) external returns (bool) {\n\t\t_approve(msg.sender, spender, value);\n\t\treturn true;\n\t}\n\n\tfunction transfer(address to, uint value) external returns (bool) {\n\t\t_transfer(msg.sender, to, value);\n\t\treturn true;\n\t}\n\n\tfunction transferFrom(address from, address to, uint value) external returns (bool) {\n\t\tif (allowance[from][msg.sender] != uint(-1)) {\n\t\t\tallowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n\t\t}\n\t\t_transfer(from, to, value);\n\t\treturn true;\n\t}\n\n\tfunction permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\n\t\trequire(deadline >= block.timestamp, \"UniswapV2: EXPIRED\");\n\t\tbytes32 digest = keccak256(\n\t\t\tabi.encodePacked(\n\t\t\t\t\"\\x19\\x01\",\n\t\t\t\tDOMAIN_SEPARATOR,\n\t\t\t\tkeccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n\t\t\t)\n\t\t);\n\t\taddress recoveredAddress = ecrecover(digest, v, r, s);\n\t\trequire(recoveredAddress != address(0) && recoveredAddress == owner, \"UniswapV2: INVALID_SIGNATURE\");\n\t\t_approve(owner, spender, value);\n\t}\n}\n"
    },
    "contracts/test/uniswap/core/UniswapV2Factory.sol": {
      "content": "pragma solidity 0.6.6;\n\nimport \"./interfaces/IUniswapV2Factory.sol\";\nimport \"./UniswapV2Pair.sol\";\n\ncontract UniswapV2Factory {\n\taddress public feeTo;\n\taddress public feeToSetter;\n\n\tmapping(address => mapping(address => address)) public getPair;\n\taddress[] public allPairs;\n\n\tevent PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n\tconstructor(address _feeToSetter) public {\n\t\tfeeToSetter = _feeToSetter;\n\t}\n\n\tfunction getInitHash() public pure returns (bytes32) {\n\t\tbytes memory bytecode = type(UniswapV2Pair).creationCode;\n\t\treturn keccak256(abi.encodePacked(bytecode));\n\t}\n\n\tfunction allPairsLength() external view returns (uint) {\n\t\treturn allPairs.length;\n\t}\n\n\tfunction createPair(address tokenA, address tokenB) external returns (address pair) {\n\t\trequire(tokenA != tokenB, \"UniswapV2: IDENTICAL_ADDRESSES\");\n\t\t(address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n\t\trequire(token0 != address(0), \"UniswapV2: ZERO_ADDRESS\");\n\t\trequire(getPair[token0][token1] == address(0), \"UniswapV2: PAIR_EXISTS\"); // single check is sufficient\n\t\tbytes memory bytecode = type(UniswapV2Pair).creationCode;\n\t\tbytes32 salt = keccak256(abi.encodePacked(token0, token1));\n\t\tassembly {\n\t\t\tpair := create2(0, add(bytecode, 32), mload(bytecode), salt)\n\t\t}\n\t\tIUniswapV2Pair(pair).initialize(token0, token1);\n\t\tgetPair[token0][token1] = pair;\n\t\tgetPair[token1][token0] = pair; // populate mapping in the reverse direction\n\t\tallPairs.push(pair);\n\t\temit PairCreated(token0, token1, pair, allPairs.length);\n\t}\n\n\tfunction setFeeTo(address _feeTo) external {\n\t\trequire(msg.sender == feeToSetter, \"UniswapV2: FORBIDDEN\");\n\t\tfeeTo = _feeTo;\n\t}\n\n\tfunction setFeeToSetter(address _feeToSetter) external {\n\t\trequire(msg.sender == feeToSetter, \"UniswapV2: FORBIDDEN\");\n\t\tfeeToSetter = _feeToSetter;\n\t}\n}\n"
    },
    "contracts/test/uniswap/core/UniswapV2Pair.sol": {
      "content": "pragma solidity 0.6.6;\n\nimport \"./interfaces/IUniswapV2Pair.sol\";\nimport \"./UniswapV2ERC20.sol\";\nimport \"./libraries/Math.sol\";\nimport \"./libraries/UQ112x112.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./interfaces/IUniswapV2Factory.sol\";\nimport \"./interfaces/IUniswapV2Callee.sol\";\n\ncontract UniswapV2Pair is UniswapV2ERC20 {\n\tusing SafeMath for uint;\n\tusing UQ112x112 for uint224;\n\n\tuint public constant MINIMUM_LIQUIDITY = 10 ** 3;\n\tbytes4 private constant SELECTOR = bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\n\n\taddress public factory;\n\taddress public token0;\n\taddress public token1;\n\n\tuint112 private reserve0; // uses single storage slot, accessible via getReserves\n\tuint112 private reserve1; // uses single storage slot, accessible via getReserves\n\tuint32 private blockTimestampLast; // uses single storage slot, accessible via getReserves\n\n\tuint public price0CumulativeLast;\n\tuint public price1CumulativeLast;\n\tuint public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event\n\n\tuint private unlocked = 1;\n\tmodifier lock() {\n\t\trequire(unlocked == 1, \"UniswapV2: LOCKED\");\n\t\tunlocked = 0;\n\t\t_;\n\t\tunlocked = 1;\n\t}\n\n\tfunction getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {\n\t\t_reserve0 = reserve0;\n\t\t_reserve1 = reserve1;\n\t\t_blockTimestampLast = blockTimestampLast;\n\t}\n\n\tfunction _safeTransfer(address token, address to, uint value) private {\n\t\t(bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\n\t\trequire(success && (data.length == 0 || abi.decode(data, (bool))), \"UniswapV2: TRANSFER_FAILED\");\n\t}\n\n\tevent Mint(address indexed sender, uint amount0, uint amount1);\n\tevent Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n\tevent Swap(\n\t\taddress indexed sender,\n\t\tuint amount0In,\n\t\tuint amount1In,\n\t\tuint amount0Out,\n\t\tuint amount1Out,\n\t\taddress indexed to\n\t);\n\tevent Sync(uint112 reserve0, uint112 reserve1);\n\n\tconstructor() public {\n\t\tfactory = msg.sender;\n\t}\n\n\t// called once by the factory at time of deployment\n\tfunction initialize(address _token0, address _token1) external {\n\t\trequire(msg.sender == factory, \"UniswapV2: FORBIDDEN\"); // sufficient check\n\t\ttoken0 = _token0;\n\t\ttoken1 = _token1;\n\t}\n\n\t// update reserves and, on the first call per block, price accumulators\n\tfunction _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {\n\t\trequire(balance0 <= uint112(-1) && balance1 <= uint112(-1), \"UniswapV2: OVERFLOW\");\n\t\tuint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);\n\t\tuint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\n\t\tif (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\n\t\t\t// * never overflows, and + overflow is desired\n\t\t\tprice0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;\n\t\t\tprice1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;\n\t\t}\n\t\treserve0 = uint112(balance0);\n\t\treserve1 = uint112(balance1);\n\t\tblockTimestampLast = blockTimestamp;\n\t\temit Sync(reserve0, reserve1);\n\t}\n\n\t// if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)\n\tfunction _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {\n\t\taddress feeTo = IUniswapV2Factory(factory).feeTo();\n\t\tfeeOn = feeTo != address(0);\n\t\tuint _kLast = kLast; // gas savings\n\t\tif (feeOn) {\n\t\t\tif (_kLast != 0) {\n\t\t\t\tuint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));\n\t\t\t\tuint rootKLast = Math.sqrt(_kLast);\n\t\t\t\tif (rootK > rootKLast) {\n\t\t\t\t\tuint numerator = totalSupply.mul(rootK.sub(rootKLast));\n\t\t\t\t\tuint denominator = rootK.mul(5).add(rootKLast);\n\t\t\t\t\tuint liquidity = numerator / denominator;\n\t\t\t\t\tif (liquidity > 0) _mint(feeTo, liquidity);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (_kLast != 0) {\n\t\t\tkLast = 0;\n\t\t}\n\t}\n\n\t// this low-level function should be called from a contract which performs important safety checks\n\tfunction mint(address to) external lock returns (uint liquidity) {\n\t\t(uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\n\t\tuint balance0 = IERC20(token0).balanceOf(address(this));\n\t\tuint balance1 = IERC20(token1).balanceOf(address(this));\n\t\tuint amount0 = balance0.sub(_reserve0);\n\t\tuint amount1 = balance1.sub(_reserve1);\n\n\t\tbool feeOn = _mintFee(_reserve0, _reserve1);\n\t\tuint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n\t\tif (_totalSupply == 0) {\n\t\t\tliquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\n\t\t\t_mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\n\t\t} else {\n\t\t\tliquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);\n\t\t}\n\t\trequire(liquidity > 0, \"UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED\");\n\t\t_mint(to, liquidity);\n\n\t\t_update(balance0, balance1, _reserve0, _reserve1);\n\t\tif (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\n\t\temit Mint(msg.sender, amount0, amount1);\n\t}\n\n\t// this low-level function should be called from a contract which performs important safety checks\n\tfunction burn(address to) external lock returns (uint amount0, uint amount1) {\n\t\t(uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\n\t\taddress _token0 = token0; // gas savings\n\t\taddress _token1 = token1; // gas savings\n\t\tuint balance0 = IERC20(_token0).balanceOf(address(this));\n\t\tuint balance1 = IERC20(_token1).balanceOf(address(this));\n\t\tuint liquidity = balanceOf[address(this)];\n\n\t\tbool feeOn = _mintFee(_reserve0, _reserve1);\n\t\tuint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n\t\tamount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution\n\t\tamount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution\n\t\trequire(amount0 > 0 && amount1 > 0, \"UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED\");\n\t\t_burn(address(this), liquidity);\n\t\t_safeTransfer(_token0, to, amount0);\n\t\t_safeTransfer(_token1, to, amount1);\n\t\tbalance0 = IERC20(_token0).balanceOf(address(this));\n\t\tbalance1 = IERC20(_token1).balanceOf(address(this));\n\n\t\t_update(balance0, balance1, _reserve0, _reserve1);\n\t\tif (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\n\t\temit Burn(msg.sender, amount0, amount1, to);\n\t}\n\n\t// this low-level function should be called from a contract which performs important safety checks\n\tfunction swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock {\n\t\trequire(amount0Out > 0 || amount1Out > 0, \"UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT\");\n\t\t(uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\n\t\trequire(amount0Out < _reserve0 && amount1Out < _reserve1, \"UniswapV2: INSUFFICIENT_LIQUIDITY\");\n\n\t\tuint balance0;\n\t\tuint balance1;\n\t\t{\n\t\t\t// scope for _token{0,1}, avoids stack too deep errors\n\t\t\taddress _token0 = token0;\n\t\t\taddress _token1 = token1;\n\t\t\trequire(to != _token0 && to != _token1, \"UniswapV2: INVALID_TO\");\n\t\t\tif (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\n\t\t\tif (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\n\t\t\tif (data.length > 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);\n\t\t\tbalance0 = IERC20(_token0).balanceOf(address(this));\n\t\t\tbalance1 = IERC20(_token1).balanceOf(address(this));\n\t\t}\n\t\tuint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\n\t\tuint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\n\t\trequire(amount0In > 0 || amount1In > 0, \"UniswapV2: INSUFFICIENT_INPUT_AMOUNT\");\n\t\t{\n\t\t\t// scope for reserve{0,1}Adjusted, avoids stack too deep errors\n\t\t\tuint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));\n\t\t\tuint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));\n\t\t\trequire(\n\t\t\t\tbalance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000 ** 2),\n\t\t\t\t\"UniswapV2: K\"\n\t\t\t);\n\t\t}\n\n\t\t_update(balance0, balance1, _reserve0, _reserve1);\n\t\temit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n\t}\n\n\t// force balances to match reserves\n\tfunction skim(address to) external lock {\n\t\taddress _token0 = token0; // gas savings\n\t\taddress _token1 = token1; // gas savings\n\t\t_safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0));\n\t\t_safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));\n\t}\n\n\t// force reserves to match balances\n\tfunction sync() external lock {\n\t\t_update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);\n\t}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}