{
  "language": "Solidity",
  "sources": {
    "@uniswap/lib/contracts/libraries/Babylonian.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.4.0;\n\n// computes square roots using the babylonian method\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\nlibrary Babylonian {\n    // credit for this implementation goes to\n    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\n    function sqrt(uint256 x) internal pure returns (uint256) {\n        if (x == 0) return 0;\n        // this block is equivalent to r = uint256(1) << (BitMath.mostSignificantBit(x) / 2);\n        // however that code costs significantly more gas\n        uint256 xx = x;\n        uint256 r = 1;\n        if (xx >= 0x100000000000000000000000000000000) {\n            xx >>= 128;\n            r <<= 64;\n        }\n        if (xx >= 0x10000000000000000) {\n            xx >>= 64;\n            r <<= 32;\n        }\n        if (xx >= 0x100000000) {\n            xx >>= 32;\n            r <<= 16;\n        }\n        if (xx >= 0x10000) {\n            xx >>= 16;\n            r <<= 8;\n        }\n        if (xx >= 0x100) {\n            xx >>= 8;\n            r <<= 4;\n        }\n        if (xx >= 0x10) {\n            xx >>= 4;\n            r <<= 2;\n        }\n        if (xx >= 0x8) {\n            r <<= 1;\n        }\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1; // Seven iterations should be enough\n        uint256 r1 = x / r;\n        return (r < r1 ? r : r1);\n    }\n}\n"
    },
    "@uniswap/lib/contracts/libraries/BitMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.5.0;\n\nlibrary BitMath {\n    // returns the 0 indexed position of the most significant bit of the input x\n    // s.t. x >= 2**msb and x < 2**(msb+1)\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0, 'BitMath::mostSignificantBit: zero');\n\n        if (x >= 0x100000000000000000000000000000000) {\n            x >>= 128;\n            r += 128;\n        }\n        if (x >= 0x10000000000000000) {\n            x >>= 64;\n            r += 64;\n        }\n        if (x >= 0x100000000) {\n            x >>= 32;\n            r += 32;\n        }\n        if (x >= 0x10000) {\n            x >>= 16;\n            r += 16;\n        }\n        if (x >= 0x100) {\n            x >>= 8;\n            r += 8;\n        }\n        if (x >= 0x10) {\n            x >>= 4;\n            r += 4;\n        }\n        if (x >= 0x4) {\n            x >>= 2;\n            r += 2;\n        }\n        if (x >= 0x2) r += 1;\n    }\n\n    // returns the 0 indexed position of the least significant bit of the input x\n    // s.t. (x & 2**lsb) != 0 and (x & (2**(lsb) - 1)) == 0)\n    // i.e. the bit at the index is set and the mask of all lower bits is 0\n    function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0, 'BitMath::leastSignificantBit: zero');\n\n        r = 255;\n        if (x & uint128(-1) > 0) {\n            r -= 128;\n        } else {\n            x >>= 128;\n        }\n        if (x & uint64(-1) > 0) {\n            r -= 64;\n        } else {\n            x >>= 64;\n        }\n        if (x & uint32(-1) > 0) {\n            r -= 32;\n        } else {\n            x >>= 32;\n        }\n        if (x & uint16(-1) > 0) {\n            r -= 16;\n        } else {\n            x >>= 16;\n        }\n        if (x & uint8(-1) > 0) {\n            r -= 8;\n        } else {\n            x >>= 8;\n        }\n        if (x & 0xf > 0) {\n            r -= 4;\n        } else {\n            x >>= 4;\n        }\n        if (x & 0x3 > 0) {\n            r -= 2;\n        } else {\n            x >>= 2;\n        }\n        if (x & 0x1 > 0) r -= 1;\n    }\n}\n"
    },
    "@uniswap/lib/contracts/libraries/FixedPoint.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.4.0;\n\nimport './FullMath.sol';\nimport './Babylonian.sol';\nimport './BitMath.sol';\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\nlibrary FixedPoint {\n    // range: [0, 2**112 - 1]\n    // resolution: 1 / 2**112\n    struct uq112x112 {\n        uint224 _x;\n    }\n\n    // range: [0, 2**144 - 1]\n    // resolution: 1 / 2**112\n    struct uq144x112 {\n        uint256 _x;\n    }\n\n    uint8 public constant RESOLUTION = 112;\n    uint256 public constant Q112 = 0x10000000000000000000000000000; // 2**112\n    uint256 private constant Q224 = 0x100000000000000000000000000000000000000000000000000000000; // 2**224\n    uint256 private constant LOWER_MASK = 0xffffffffffffffffffffffffffff; // decimal of UQ*x112 (lower 112 bits)\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\n        return uq112x112(uint224(x) << RESOLUTION);\n    }\n\n    // encodes a uint144 as a UQ144x112\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\n        return uq144x112(uint256(x) << RESOLUTION);\n    }\n\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\n        return uint112(self._x >> RESOLUTION);\n    }\n\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\n        return uint144(self._x >> RESOLUTION);\n    }\n\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\n    // reverts on overflow\n    function mul(uq112x112 memory self, uint256 y) internal pure returns (uq144x112 memory) {\n        uint256 z = 0;\n        require(y == 0 || (z = self._x * y) / y == self._x, 'FixedPoint::mul: overflow');\n        return uq144x112(z);\n    }\n\n    // multiply a UQ112x112 by an int and decode, returning an int\n    // reverts on overflow\n    function muli(uq112x112 memory self, int256 y) internal pure returns (int256) {\n        uint256 z = FullMath.mulDiv(self._x, uint256(y < 0 ? -y : y), Q112);\n        require(z < 2**255, 'FixedPoint::muli: overflow');\n        return y < 0 ? -int256(z) : int256(z);\n    }\n\n    // multiply a UQ112x112 by a UQ112x112, returning a UQ112x112\n    // lossy\n    function muluq(uq112x112 memory self, uq112x112 memory other) internal pure returns (uq112x112 memory) {\n        if (self._x == 0 || other._x == 0) {\n            return uq112x112(0);\n        }\n        uint112 upper_self = uint112(self._x >> RESOLUTION); // * 2^0\n        uint112 lower_self = uint112(self._x & LOWER_MASK); // * 2^-112\n        uint112 upper_other = uint112(other._x >> RESOLUTION); // * 2^0\n        uint112 lower_other = uint112(other._x & LOWER_MASK); // * 2^-112\n\n        // partial products\n        uint224 upper = uint224(upper_self) * upper_other; // * 2^0\n        uint224 lower = uint224(lower_self) * lower_other; // * 2^-224\n        uint224 uppers_lowero = uint224(upper_self) * lower_other; // * 2^-112\n        uint224 uppero_lowers = uint224(upper_other) * lower_self; // * 2^-112\n\n        // so the bit shift does not overflow\n        require(upper <= uint112(-1), 'FixedPoint::muluq: upper overflow');\n\n        // this cannot exceed 256 bits, all values are 224 bits\n        uint256 sum = uint256(upper << RESOLUTION) + uppers_lowero + uppero_lowers + (lower >> RESOLUTION);\n\n        // so the cast does not overflow\n        require(sum <= uint224(-1), 'FixedPoint::muluq: sum overflow');\n\n        return uq112x112(uint224(sum));\n    }\n\n    // divide a UQ112x112 by a UQ112x112, returning a UQ112x112\n    function divuq(uq112x112 memory self, uq112x112 memory other) internal pure returns (uq112x112 memory) {\n        require(other._x > 0, 'FixedPoint::divuq: division by zero');\n        if (self._x == other._x) {\n            return uq112x112(uint224(Q112));\n        }\n        if (self._x <= uint144(-1)) {\n            uint256 value = (uint256(self._x) << RESOLUTION) / other._x;\n            require(value <= uint224(-1), 'FixedPoint::divuq: overflow');\n            return uq112x112(uint224(value));\n        }\n\n        uint256 result = FullMath.mulDiv(Q112, self._x, other._x);\n        require(result <= uint224(-1), 'FixedPoint::divuq: overflow');\n        return uq112x112(uint224(result));\n    }\n\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\n    // can be lossy\n    function fraction(uint256 numerator, uint256 denominator) internal pure returns (uq112x112 memory) {\n        require(denominator > 0, 'FixedPoint::fraction: division by zero');\n        if (numerator == 0) return FixedPoint.uq112x112(0);\n\n        if (numerator <= uint144(-1)) {\n            uint256 result = (numerator << RESOLUTION) / denominator;\n            require(result <= uint224(-1), 'FixedPoint::fraction: overflow');\n            return uq112x112(uint224(result));\n        } else {\n            uint256 result = FullMath.mulDiv(numerator, Q112, denominator);\n            require(result <= uint224(-1), 'FixedPoint::fraction: overflow');\n            return uq112x112(uint224(result));\n        }\n    }\n\n    // take the reciprocal of a UQ112x112\n    // reverts on overflow\n    // lossy\n    function reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n        require(self._x != 0, 'FixedPoint::reciprocal: reciprocal of zero');\n        require(self._x != 1, 'FixedPoint::reciprocal: overflow');\n        return uq112x112(uint224(Q224 / self._x));\n    }\n\n    // square root of a UQ112x112\n    // lossy between 0/1 and 40 bits\n    function sqrt(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n        if (self._x <= uint144(-1)) {\n            return uq112x112(uint224(Babylonian.sqrt(uint256(self._x) << 112)));\n        }\n\n        uint8 safeShiftBits = 255 - BitMath.mostSignificantBit(self._x);\n        safeShiftBits -= safeShiftBits % 2;\n        return uq112x112(uint224(Babylonian.sqrt(uint256(self._x) << safeShiftBits) << ((112 - safeShiftBits) / 2)));\n    }\n}\n"
    },
    "@uniswap/lib/contracts/libraries/FullMath.sol": {
      "content": "// SPDX-License-Identifier: CC-BY-4.0\npragma solidity >=0.4.0;\n\n// taken from https://medium.com/coinmonks/math-in-solidity-part-3-percents-and-proportions-4db014e080b1\n// license is CC-BY-4.0\nlibrary FullMath {\n    function fullMul(uint256 x, uint256 y) internal pure returns (uint256 l, uint256 h) {\n        uint256 mm = mulmod(x, y, uint256(-1));\n        l = x * y;\n        h = mm - l;\n        if (mm < l) h -= 1;\n    }\n\n    function fullDiv(\n        uint256 l,\n        uint256 h,\n        uint256 d\n    ) private pure returns (uint256) {\n        uint256 pow2 = d & -d;\n        d /= pow2;\n        l /= pow2;\n        l += h * ((-pow2) / pow2 + 1);\n        uint256 r = 1;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        return l * r;\n    }\n\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 d\n    ) internal pure returns (uint256) {\n        (uint256 l, uint256 h) = fullMul(x, y);\n\n        uint256 mm = mulmod(x, y, d);\n        if (mm > l) h -= 1;\n        l -= mm;\n\n        if (h == 0) return l / d;\n\n        require(h < d, 'FullMath: FULLDIV_OVERFLOW');\n        return fullDiv(l, h, d);\n    }\n}\n"
    },
    "@uniswap/lib/contracts/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.6.0;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::safeApprove: approve failed'\n        );\n    }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::safeTransfer: transfer failed'\n        );\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::transferFrom: transferFrom failed'\n        );\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\n    }\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "contracts/bounties/BountyManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../interfaces/IAToken.sol\";\nimport \"../interfaces/IMultiFeeDistribution.sol\";\nimport \"../uniswap/periphery/interfaces/IUniswapV2Router02.sol\";\nimport \"../dependencies/openzeppelin/contracts/IERC20.sol\";\nimport \"../dependencies/openzeppelin/contracts/SafeERC20.sol\";\nimport \"../dependencies/openzeppelin/contracts/SafeMath.sol\";\nimport \"../dependencies/openzeppelin/upgradeability/Initializable.sol\";\nimport \"../dependencies/openzeppelin/upgradeability/OwnableUpgradeable.sol\";\nimport \"../dependencies/openzeppelin/upgradeability/PausableUpgradeable.sol\";\nimport \"../interfaces/ILendingPoolAddressesProvider.sol\";\nimport \"../interfaces/ILendingPool.sol\";\nimport \"../interfaces/ILockZap.sol\";\nimport \"../interfaces/IChefIncentivesController.sol\";\nimport \"../interfaces/IMultiFeeDistribution.sol\";\nimport \"../interfaces/IPriceProvider.sol\";\nimport \"../interfaces/IEligibilityDataProvider.sol\";\n\ncontract BountyManager is Initializable, OwnableUpgradeable, PausableUpgradeable {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    address public rdnt;\n    address public weth;\n    address mfd;\n    address lpMfd;\n    address chef;\n    address public priceProvider;\n    address public eligibilityDataProvider;\n    uint256 public HUNTER_SHARE;\n    uint256 public baseBountyUsdTarget; // decimals 18\n    uint256 public maxBaseBounty;\n    uint256 public bountyBooster;\n    uint256 public bountyCount;\n    uint256 public minDLPBalance;\n    uint256 slippageLimit;\n\n    // Array of available Bounty functions to run. See getLpMfdBounty, getChefBounty, etc.\n    mapping(uint256 => function(address, bool) returns (address,uint256,bool))\n        private bounties;\n\n    mapping(address => bool) public whitelist;\n    bool public whitelistActive;\n\n    modifier isWhitelisted {\n        if(whitelistActive){\n            require(whitelist[msg.sender], \"!whiteliested\");\n        }\n        _;\n    }\n\n    event Disqualified(address user);\n    event ChefIncentivesControllerUpdated(IChefIncentivesController _chef);\n    event BaseBountyUsdTargetUpdated(uint256 _newVal);\n    event HunterShareUpdated(uint256 _newVal);\n    event MaxBaseBountyUpdated(uint256 _newVal);\n    event BountyBoosterUpdated(uint256 _newVal);\n    event SlippageLimitUpdated(uint256 _newVal);\n    event BountyReserveEmpty(uint256 _bal);\n\n    /**\n     * @notice Initialize\n     * @param _rdnt RDNT address\n     * @param _weth WETH address\n     * @param _lpMfd LP MFD, to query bounties on expired locks + autocompounds\n     * @param _mfd MFD, to send bounties as vesting RDNT to Hunter (user calling bounty)\n     * @param _chef CIC, to query bounties for ineligible emissions\n     * @param _priceProvider PriceProvider service, to get RDNT price for bounty quotes\n     * @param _hunterShare % of reclaimed rewards to send to Hunter\n     * @param _baseBountyUsdTarget Base Bounty is paid in RDNT, will scale to match this USD target value\n     * @param _maxBaseBounty cap the scaling above\n     * @param _bountyBooster when bounties need boosting to clear queue, add this amount (in RDNT)\n     */\n    function initialize(\n        address _rdnt,\n        address _weth,\n        address _lpMfd,\n        address _mfd,\n        address _chef,\n        address _priceProvider,\n        address _eligibilityDataProvider,\n        uint256 _hunterShare,\n        uint256 _baseBountyUsdTarget,\n        uint256 _maxBaseBounty,\n        uint256 _bountyBooster\n    ) external initializer {\n        require(_rdnt != address(0));\n        require(_weth != address(0));\n        require(_lpMfd != address(0));\n        require(_mfd != address(0));\n        require(_chef != address(0));\n        require(_priceProvider != address(0));\n        require(_eligibilityDataProvider != address(0));\n        require(_hunterShare <= 10000);\n        require(_baseBountyUsdTarget != 0);\n        require(_maxBaseBounty != 0);\n\n        rdnt = _rdnt;\n        weth = _weth;\n        lpMfd = _lpMfd;\n        mfd = _mfd;\n        chef = _chef;\n        priceProvider = _priceProvider;\n        eligibilityDataProvider = _eligibilityDataProvider;\n\n        HUNTER_SHARE = _hunterShare;\n        baseBountyUsdTarget = _baseBountyUsdTarget;\n        bountyBooster = _bountyBooster;\n        maxBaseBounty = _maxBaseBounty;\n\n        bounties[1] = getLpMfdBounty;\n        bounties[2] = getChefBounty;\n        bounties[3] = getAutoCompoundBounty;\n        bountyCount = 3;\n\n        slippageLimit = 10;\n        minDLPBalance = uint256(5).mul(10 ** 18);\n\n\n        __Ownable_init();\n        __Pausable_init();\n    }\n\n    /**\n     * @notice Given a user, return their bounty amount. uses staticcall to run same bounty aglo, but without execution\n     * @param _user address\n     * @return bounty amount of RDNT Hunter will recieve. \n     * can be a fixed amt (Base Bounty) or dynamic amt based on rewards removed from target user during execution (ineligible revenue, autocompound fee)\n     * @return actionType which of the 3 bounty types (above) to run. \n     * getBestBounty returns this based on priority (expired locks first, then inelig emissions, then autocompound)\n     */\n    function quote(address _user)\n        public\n        view\n        whenNotPaused\n        returns (uint256 bounty, uint256 actionType)\n    {\n        (bool success, bytes memory data) = address(this).staticcall(\n            abi.encodeWithSignature(\n                \"executeBounty(address,bool,uint256,uint256)\",\n                _user,\n                false,\n                0,\n                0\n            )\n        );\n        require(success, \"quote fail\");\n\n        (bounty, actionType) = abi.decode(data, (uint256, uint256));\n    }\n\n     /**\n     * @notice Execute a bounty. \n     * @param _user address\n     * @param _expectedBounty result from quote above, used for slippage handling\n     * can be a fixed amt (Base Bounty) or dynamic amt based on rewards removed from target user during execution (ineligible revenue, autocompound fee)\n     * @param _actionType which of the 3 bounty types (above) to run. \n     * @return bounty in RDNT to be paid to Hunter (via vesting)\n     * @return actionType which bounty ran\n     */\n    function claim(\n        address _user,\n        uint256 _expectedBounty,\n        uint256 _actionType\n    ) public whenNotPaused isWhitelisted returns (uint256 bounty, uint256 actionType) {\n        return executeBounty(_user, true, _expectedBounty, _actionType);\n    }\n\n    /**\n     * @notice Execute the most appropriate bounty on a user, check returned amount for slippage, calc amount going to Hunter, send to vesting.\n     * @param _user address\n     * @param _execute whether to execute this txn, or just quote what its execution would return\n     * @param _expectedBounty result from quote above, used for slippage handling\n     * can be a fixed amt (Base Bounty) or dynamic amt based on rewards removed from target user during execution (ineligible revenue, autocompound fee)\n     * @param _actionType which of the 3 bounty types (above) to run. \n     * @return bounty in RDNT to be paid to Hunter (via vesting)\n     * @return actionType which bounty ran\n     */\n    function executeBounty(\n        address _user,\n        bool _execute,\n        uint256 _expectedBounty,\n        uint256 _actionType\n    ) public whenNotPaused isWhitelisted returns (uint256 bounty, uint256 actionType) {\n        \n        require(\n            !_execute || (_execute && _expectedBounty != 0),\n            \"quote required\"\n        );\n\n        if(msg.sender != address(this)){\n            (, , uint256 lockedLP, ,) = IMFDPlus(lpMfd).lockedBalances(msg.sender);\n            require(lockedLP >= minDLPBalance, \"No enough DLP balance to be able to bounty\");\n            require(IEligibilityDataProvider(eligibilityDataProvider).isEligibleForRewards(msg.sender), \"Bounty executer must be eligible for rewards.\");\n        }\n\n        uint256 totalBounty;\n        bool issueBaseBounty;\n        address incentivizer;\n        uint256 bb = getBaseBounty();\n\n        (\n            incentivizer,\n            totalBounty,\n            issueBaseBounty,\n            actionType\n        ) = getBestBounty(_user, _execute, _actionType);\n\n        if (issueBaseBounty) {\n            bounty = bb;\n        } else {\n            if (totalBounty != 0) {\n                bounty = totalBounty.mul(HUNTER_SHARE).div(10000);\n            }\n        }\n\n        uint256 minAmountOut = _expectedBounty.sub(\n            _expectedBounty.mul(slippageLimit).div(100)\n        );\n        require(bounty >= minAmountOut, \"too much slippage\");\n\n        if (_execute && bounty != 0) {\n            if (!issueBaseBounty) {\n                IERC20(rdnt).safeTransferFrom(\n                    incentivizer,\n                    address(this),\n                    totalBounty\n                );\n            }\n            _sendBounty(msg.sender, bounty);\n        }\n    }\n\n    /**\n     * @notice Given a user and actionType, execute that bounty on either CIC or MFD.\n     * @param _user address\n     * @param _execute whether to execute this txn, or just quote what its execution would return\n     * @param _actionTypeIndex, which of the 3 bounty types (above) to run. \n     * @return incentivizer the contract that had a bounty operation performed for it. \n     * Either CIC (to remove ineligible user from emission pool, or MFD to remove expired locks)\n     * @return totalBounty raw amount of RDNT returned from Incentivizer. Hunter % will be deducted from this.\n     * @return issueBaseBounty whether Incentivizer will pay bounty from its own RDNT reserve, or from this contracts RDNT reserve\n     * @return actionType the action type index executed\n     */\n    function getBestBounty(\n        address _user,\n        bool _execute,\n        uint256 _actionTypeIndex\n    )\n        internal\n        returns (\n            address incentivizer,\n            uint256 totalBounty,\n            bool issueBaseBounty,\n            uint256 actionType\n        )\n    {\n        if (_actionTypeIndex != 0) {\n            // execute bounty w/ given params\n            (incentivizer, totalBounty, issueBaseBounty) = bounties[\n                _actionTypeIndex\n            ](_user, _execute);\n            actionType = _actionTypeIndex;\n        } else {\n            for (uint256 i = 1; i <= bountyCount; i++) {\n                (incentivizer, totalBounty, issueBaseBounty) = bounties[i](\n                    _user,\n                    _execute\n                );\n                if (totalBounty != 0 || issueBaseBounty) {\n                    actionType = i;\n                    break;\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice call MFDPlus.claimBounty()\n     * @param _user address\n     * @param _execute whether to execute this txn, or just quote what its execution would return\n     * @return incentivizer in this case MFD\n     * @return totalBounty RDNT to pay for this _user's bounty execution\n     * @return issueBaseBounty true when user has autorelock, \n     * false when !autorelock because they will have rewards removed from their ineligible time after locks expired\n     */\n    function getLpMfdBounty(address _user, bool _execute)\n        internal\n        returns (\n            address incentivizer,\n            uint256 totalBounty,\n            bool issueBaseBounty\n        )\n    {\n        (totalBounty, issueBaseBounty) = IMFDPlus(lpMfd).claimBounty(\n            _user,\n            _execute\n        );\n        incentivizer = lpMfd;\n    }\n\n    /**\n     * @notice call CIC.claimBounty()\n     * @param _user address\n     * @param _execute whether to execute this txn, or just quote what its execution would return\n     * @return incentivizer in this case CIC\n     * @return totalBounty RDNT to pay for this _user's bounty execution\n     * @return issueBaseBounty true when user has autorelock or when disqualified because their lock value dropped below 5% threshold\n     * false when !autorelock because they will have rewards removed from their ineligible time after locks expired\n     */\n    function getChefBounty(address _user, bool _execute)\n        internal\n        returns (\n            address incentivizer,\n            uint256 totalBounty,\n            bool issueBaseBounty\n        )\n    {\n        (totalBounty, issueBaseBounty) = IChefIncentivesController(chef)\n            .claimBounty(_user, _execute);\n        incentivizer = chef;\n    }\n\n    /**\n     * @notice call MFDPlus.claimCompound(). compound pending rewards for _user into locked LP\n     * @param _user address\n     * @param _execute whether to execute this txn, or just quote what its execution would return\n     * @return incentivizer in this case MFDPlus\n     * @return totalBounty RDNT to pay for this _user's bounty execution. paid from Autocompound fee\n     * @return issueBaseBounty always false since bounty paid from compound fee\n     */\n    function getAutoCompoundBounty(address _user, bool _execute)\n        internal\n        returns (\n            address incentivizer,\n            uint256 totalBounty,\n            bool issueBaseBounty\n        )\n    {\n        (totalBounty) = IMFDPlus(lpMfd).claimCompound(_user, _execute);\n        issueBaseBounty = false;\n        incentivizer = lpMfd;\n    }\n\n    /**\n     * @notice Vest a bounty in MFD for successful bounty by Hunter\n     * @param _to Hunter address\n     * @param _amount of RDNT\n     * @return amt added to vesting\n     */\n    function _sendBounty(address _to, uint256 _amount)\n        internal\n        returns (uint256)\n    {\n        if (_amount == 0) {\n            return 0;\n        }\n\n        uint256 bountyReserve = IERC20(rdnt).balanceOf(address(this));\n        if(_amount > bountyReserve) {\n            emit BountyReserveEmpty(bountyReserve);\n            _pause();\n        } else {\n            IERC20(rdnt).safeTransfer(address(mfd), _amount);\n            IMFDPlus(mfd).mint(_to, _amount, true);\n            return _amount;\n        }\n    }\n\n    /**\n     * @notice Return RDNT amount for Base Bounty. \n     * Base Bounty used to incentivize operations that dont generate their own reward to pay to Hunter.\n     * @return bounty in RDNT\n     */\n    function getBaseBounty()\n        public\n        view\n        whenNotPaused\n        returns (uint256 bounty)\n    {\n        uint256 rdntPrice = IPriceProvider(priceProvider).getTokenPriceUsd();\n        bounty = baseBountyUsdTarget.mul(1e8).div(rdntPrice);\n        if (bounty > maxBaseBounty) {\n            bounty = maxBaseBounty;\n        }\n    }\n\n    function setMinDLPBalance (uint256 _minDLPBalance) external onlyOwner {\n        minDLPBalance = _minDLPBalance;\n    }\n\n    function setBaseBountyUsdTarget(uint256 _newVal) external onlyOwner {\n        baseBountyUsdTarget = _newVal;\n        emit BaseBountyUsdTargetUpdated(_newVal);\n    }\n\n    function setHunterShare(uint256 _newVal) external onlyOwner {\n        require(_newVal <= 10000, \"override\");\n        HUNTER_SHARE = _newVal;\n        emit HunterShareUpdated(_newVal);\n    }\n\n    function setMaxBaseBounty(uint256 _newVal) external onlyOwner {\n        maxBaseBounty = _newVal;\n        emit MaxBaseBountyUpdated(_newVal);\n    }\n\n    function setBountyBooster(uint256 _newVal) external onlyOwner {\n        bountyBooster = _newVal;\n        emit BountyBoosterUpdated(_newVal);\n    }\n\n    function setSlippageLimit(uint256 _newVal) external onlyOwner {\n        slippageLimit = _newVal;\n        emit SlippageLimitUpdated(_newVal);\n    }\n\n    function setBounties() external onlyOwner {\n        bounties[1] = getLpMfdBounty;\n        bounties[2] = getChefBounty;\n        bounties[3] = getAutoCompoundBounty;\n    }\n\n    function recoverERC20(address tokenAddress, uint256 tokenAmount)\n        external\n        onlyOwner\n    {\n        IERC20(tokenAddress).safeTransfer(owner(), tokenAmount);\n    }\n    function addAddressToWL(address user, bool status) external onlyOwner {\n        whitelist[user] = status;\n    }\n\n    function changeWL(bool status) external onlyOwner {\n        whitelistActive = status;\n    }\n    \n    function onRelockUpdate(address _user, bool oldStatus, bool newStatus) external {\n        if (msg.sender != address(lpMfd) || oldStatus || !newStatus) {\n            return;\n        }\n        (uint256 bounty, ) = quote(_user);\n        if (bounty == 0) {\n            return;\n        }\n        this.executeBounty(_user, true, bounty, 0);\n    }\n}\n"
    },
    "contracts/bounties/BountyManagerBountiesUpgradeTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../interfaces/IAToken.sol\";\nimport \"../interfaces/IMultiFeeDistribution.sol\";\nimport \"../uniswap/periphery/interfaces/IUniswapV2Router02.sol\";\nimport \"../dependencies/openzeppelin/contracts/IERC20.sol\";\nimport \"../dependencies/openzeppelin/contracts/SafeERC20.sol\";\nimport \"../dependencies/openzeppelin/contracts/SafeMath.sol\";\nimport \"../dependencies/openzeppelin/upgradeability/Initializable.sol\";\nimport \"../dependencies/openzeppelin/upgradeability/OwnableUpgradeable.sol\";\nimport \"../dependencies/openzeppelin/upgradeability/PausableUpgradeable.sol\";\nimport \"../interfaces/ILendingPoolAddressesProvider.sol\";\nimport \"../interfaces/ILendingPool.sol\";\nimport \"../interfaces/ILockZap.sol\";\nimport \"../interfaces/IChefIncentivesController.sol\";\nimport \"../interfaces/IMultiFeeDistribution.sol\";\nimport \"../interfaces/IPriceProvider.sol\";\nimport \"../interfaces/IEligibilityDataProvider.sol\";\n\ncontract BountyManagerBountiesUpgradeTest is Initializable, OwnableUpgradeable, PausableUpgradeable {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    address public rdnt;\n    address public weth;\n    address mfd;\n    address lpMfd;\n    address chef;\n    address public priceProvider;\n    address public eligibilityDataProvider;\n    uint256 public HUNTER_SHARE;\n    uint256 public baseBountyUsdTarget; // decimals 18\n    uint256 public maxBaseBounty;\n    uint256 public bountyBooster;\n    uint256 public bountyCount;\n    uint256 public minDLPBalance;\n    uint256 slippageLimit;\n\n    // Array of available Bounty functions to run. See getLpMfdBounty, getChefBounty, etc.\n    mapping(uint256 => function(address, bool) returns (address,uint256,bool))\n        private bounties;\n\n    event Disqualified(address user);\n    event ChefIncentivesControllerUpdated(IChefIncentivesController _chef);\n    event BaseBountyUsdTargetUpdated(uint256 _newVal);\n    event HunterShareUpdated(uint256 _newVal);\n    event MaxBaseBountyUpdated(uint256 _newVal);\n    event BountyBoosterUpdated(uint256 _newVal);\n    event SlippageLimitUpdated(uint256 _newVal);\n    event BountyReserveEmpty(uint256 _bal);\n\n    /**\n     * @notice Initialize\n     * @param _rdnt RDNT address\n     * @param _weth WETH address\n     * @param _lpMfd LP MFD, to query bounties on expired locks + autocompounds\n     * @param _mfd MFD, to send bounties as vesting RDNT to Hunter (user calling bounty)\n     * @param _chef CIC, to query bounties for ineligible emissions\n     * @param _priceProvider PriceProvider service, to get RDNT price for bounty quotes\n     * @param _hunterShare % of reclaimed rewards to send to Hunter\n     * @param _baseBountyUsdTarget Base Bounty is paid in RDNT, will scale to match this USD target value\n     * @param _maxBaseBounty cap the scaling above\n     * @param _bountyBooster when bounties need boosting to clear queue, add this amount (in RDNT)\n     */\n    function initialize(\n        address _rdnt,\n        address _weth,\n        address _lpMfd,\n        address _mfd,\n        address _chef,\n        address _priceProvider,\n        address _eligibilityDataProvider,\n        uint256 _hunterShare,\n        uint256 _baseBountyUsdTarget,\n        uint256 _maxBaseBounty,\n        uint256 _bountyBooster\n    ) external initializer {\n        require(_rdnt != address(0));\n        require(_weth != address(0));\n        require(_lpMfd != address(0));\n        require(_mfd != address(0));\n        require(_chef != address(0));\n        require(_priceProvider != address(0));\n        require(_eligibilityDataProvider != address(0));\n        require(_hunterShare <= 10000);\n        require(_baseBountyUsdTarget != 0);\n        require(_maxBaseBounty != 0);\n\n        rdnt = _rdnt;\n        weth = _weth;\n        lpMfd = _lpMfd;\n        mfd = _mfd;\n        chef = _chef;\n        priceProvider = _priceProvider;\n        eligibilityDataProvider = _eligibilityDataProvider;\n\n        HUNTER_SHARE = _hunterShare;\n        baseBountyUsdTarget = _baseBountyUsdTarget;\n        bountyBooster = _bountyBooster;\n        maxBaseBounty = _maxBaseBounty;\n\n        bounties[1] = getLpMfdBounty;\n        bounties[2] = getChefBounty;\n        bounties[3] = getAutoCompoundBounty;\n        bountyCount = 3;\n\n        slippageLimit = 10;\n        minDLPBalance = uint256(5).mul(10 ** 18);\n\n\n        __Ownable_init();\n        __Pausable_init();\n    }\n\n    /**\n     * @notice Given a user, return their bounty amount. uses staticcall to run same bounty aglo, but without execution\n     * @param _user address\n     * @return bounty amount of RDNT Hunter will recieve. \n     * can be a fixed amt (Base Bounty) or dynamic amt based on rewards removed from target user during execution (ineligible revenue, autocompound fee)\n     * @return actionType which of the 3 bounty types (above) to run. \n     * getBestBounty returns this based on priority (expired locks first, then inelig emissions, then autocompound)\n     */\n    function quote(address _user)\n        public\n        view\n        whenNotPaused\n        returns (uint256 bounty, uint256 actionType)\n    {\n        (bool success, bytes memory data) = address(this).staticcall(\n            abi.encodeWithSignature(\n                \"executeBounty(address,bool,uint256,uint256)\",\n                _user,\n                false,\n                0,\n                0\n            )\n        );\n        require(success, \"quote fail\");\n\n        (bounty, actionType) = abi.decode(data, (uint256, uint256));\n    }\n\n     /**\n     * @notice Execute a bounty. \n     * @param _user address\n     * @param _expectedBounty result from quote above, used for slippage handling\n     * can be a fixed amt (Base Bounty) or dynamic amt based on rewards removed from target user during execution (ineligible revenue, autocompound fee)\n     * @param _actionType which of the 3 bounty types (above) to run. \n     * @return bounty in RDNT to be paid to Hunter (via vesting)\n     * @return actionType which bounty ran\n     */\n    function claim(\n        address _user,\n        uint256 _expectedBounty,\n        uint256 _actionType\n    ) public whenNotPaused returns (uint256 bounty, uint256 actionType) {\n        return executeBounty(_user, true, _expectedBounty, _actionType);\n    }\n\n    /**\n     * @notice Execute the most appropriate bounty on a user, check returned amount for slippage, calc amount going to Hunter, send to vesting.\n     * @param _user address\n     * @param _execute whether to execute this txn, or just quote what its execution would return\n     * @param _expectedBounty result from quote above, used for slippage handling\n     * can be a fixed amt (Base Bounty) or dynamic amt based on rewards removed from target user during execution (ineligible revenue, autocompound fee)\n     * @param _actionType which of the 3 bounty types (above) to run. \n     * @return bounty in RDNT to be paid to Hunter (via vesting)\n     * @return actionType which bounty ran\n     */\n    function executeBounty(\n        address _user,\n        bool _execute,\n        uint256 _expectedBounty,\n        uint256 _actionType\n    ) public whenNotPaused returns (uint256 bounty, uint256 actionType) {\n        \n        require(\n            !_execute || (_execute && _expectedBounty != 0),\n            \"quote required\"\n        );\n\n        if(msg.sender != address(this)){\n            (, , uint256 lockedLP, ,) = IMFDPlus(lpMfd).lockedBalances(msg.sender);\n            require(lockedLP >= minDLPBalance, \"No enough DLP balance to be able to bounty\");\n            require(IEligibilityDataProvider(eligibilityDataProvider).isEligibleForRewards(msg.sender), \"Bounty executer must be eligible for rewards.\");\n        }\n\n        uint256 totalBounty;\n        bool issueBaseBounty;\n        address incentivizer;\n        uint256 bb = getBaseBounty();\n\n        (\n            incentivizer,\n            totalBounty,\n            issueBaseBounty,\n            actionType\n        ) = getBestBounty(_user, _execute, _actionType);\n\n        if (issueBaseBounty) {\n            bounty = bb;\n        } else {\n            if (totalBounty != 0) {\n                bounty = totalBounty.mul(HUNTER_SHARE).div(10000);\n            }\n        }\n\n        uint256 minAmountOut = _expectedBounty.sub(\n            _expectedBounty.mul(slippageLimit).div(100)\n        );\n        require(bounty >= minAmountOut, \"too much slippage\");\n\n        if (_execute && bounty != 0) {\n            if (!issueBaseBounty) {\n                IERC20(rdnt).safeTransferFrom(\n                    incentivizer,\n                    address(this),\n                    totalBounty\n                );\n            }\n            _sendBounty(msg.sender, bounty);\n        }\n    }\n\n    /**\n     * @notice Given a user and actionType, execute that bounty on either CIC or MFD.\n     * @param _user address\n     * @param _execute whether to execute this txn, or just quote what its execution would return\n     * @param _actionTypeIndex, which of the 3 bounty types (above) to run. \n     * @return incentivizer the contract that had a bounty operation performed for it. \n     * Either CIC (to remove ineligible user from emission pool, or MFD to remove expired locks)\n     * @return totalBounty raw amount of RDNT returned from Incentivizer. Hunter % will be deducted from this.\n     * @return issueBaseBounty whether Incentivizer will pay bounty from its own RDNT reserve, or from this contracts RDNT reserve\n     * @return actionType the action type index executed\n     */\n    function getBestBounty(\n        address _user,\n        bool _execute,\n        uint256 _actionTypeIndex\n    )\n        internal\n        returns (\n            address incentivizer,\n            uint256 totalBounty,\n            bool issueBaseBounty,\n            uint256 actionType\n        )\n    {\n        if (_actionTypeIndex != 0) {\n            // execute bounty w/ given params\n            (incentivizer, totalBounty, issueBaseBounty) = bounties[\n                _actionTypeIndex\n            ](_user, _execute);\n            actionType = _actionTypeIndex;\n        } else {\n            for (uint256 i = 1; i <= bountyCount; i++) {\n                (incentivizer, totalBounty, issueBaseBounty) = bounties[i](\n                    _user,\n                    _execute\n                );\n                if (totalBounty != 0 || issueBaseBounty) {\n                    actionType = i;\n                    break;\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice call MFDPlus.claimBounty()\n     * @param _user address\n     * @param _execute whether to execute this txn, or just quote what its execution would return\n     * @return incentivizer in this case MFD\n     * @return totalBounty RDNT to pay for this _user's bounty execution\n     * @return issueBaseBounty true when user has autorelock, \n     * false when !autorelock because they will have rewards removed from their ineligible time after locks expired\n     */\n    function getLpMfdBounty(address _user, bool _execute)\n        internal\n        returns (\n            address incentivizer,\n            uint256 totalBounty,\n            bool issueBaseBounty\n        )\n    {\n        (totalBounty, issueBaseBounty) = IMFDPlus(lpMfd).claimBounty(\n            _user,\n            _execute\n        );\n        incentivizer = lpMfd;\n    }\n\n    /**\n     * @notice call CIC.claimBounty()\n     * @param _user address\n     * @param _execute whether to execute this txn, or just quote what its execution would return\n     * @return incentivizer in this case CIC\n     * @return totalBounty RDNT to pay for this _user's bounty execution\n     * @return issueBaseBounty true when user has autorelock or when disqualified because their lock value dropped below 5% threshold\n     * false when !autorelock because they will have rewards removed from their ineligible time after locks expired\n     */\n    function getChefBounty(address _user, bool _execute)\n        internal\n        returns (\n            address incentivizer,\n            uint256 totalBounty,\n            bool issueBaseBounty\n        )\n    {\n        (totalBounty, issueBaseBounty) = IChefIncentivesController(chef)\n            .claimBounty(_user, _execute);\n        incentivizer = chef;\n    }\n\n    /**\n     * @notice call MFDPlus.claimCompound(). compound pending rewards for _user into locked LP\n     * @param _user address\n     * @param _execute whether to execute this txn, or just quote what its execution would return\n     * @return incentivizer in this case MFDPlus\n     * @return totalBounty RDNT to pay for this _user's bounty execution. paid from Autocompound fee\n     * @return issueBaseBounty always false since bounty paid from compound fee\n     */\n    function getAutoCompoundBounty(address _user, bool _execute)\n        internal\n        returns (\n            address incentivizer,\n            uint256 totalBounty,\n            bool issueBaseBounty\n        )\n    {\n        (totalBounty) = IMFDPlus(lpMfd).claimCompound(_user, _execute);\n        issueBaseBounty = false;\n        incentivizer = lpMfd;\n    }\n\n    /**\n     * @notice just an added function to simulate upgrading the contract to test\n     * the bounties mapping with function pointers\n     * @return derp could be anything really\n     */\n    function getDerp()\n        external\n        view\n        returns (\n            uint256 derp\n        )\n    {\n        derp = 8;\n    }\n\n    /**\n     * @notice Vest a bounty in MFD for successful bounty by Hunter\n     * @param _to Hunter address\n     * @param _amount of RDNT\n     * @return amt added to vesting\n     */\n    function _sendBounty(address _to, uint256 _amount)\n        internal\n        returns (uint256)\n    {\n        if (_amount == 0) {\n            return 0;\n        }\n\n        uint256 bountyReserve = IERC20(rdnt).balanceOf(address(this));\n        if(_amount > bountyReserve) {\n            emit BountyReserveEmpty(bountyReserve);\n            _pause();\n        } else {\n            IERC20(rdnt).safeTransfer(address(mfd), _amount);\n            IMFDPlus(mfd).mint(_to, _amount, true);\n            return _amount;\n        }\n    }\n\n    /**\n     * @notice Return RDNT amount for Base Bounty. \n     * Base Bounty used to incentivize operations that dont generate their own reward to pay to Hunter.\n     * @return bounty in RDNT\n     */\n    function getBaseBounty()\n        public\n        view\n        whenNotPaused\n        returns (uint256 bounty)\n    {\n        uint256 rdntPrice = IPriceProvider(priceProvider).getTokenPriceUsd();\n        bounty = baseBountyUsdTarget.mul(1e8).div(rdntPrice);\n        if (bounty > maxBaseBounty) {\n            bounty = maxBaseBounty;\n        }\n    }\n\n    function setMinDLPBalance (uint256 _minDLPBalance) external onlyOwner {\n        minDLPBalance = _minDLPBalance;\n    }\n\n    function setBaseBountyUsdTarget(uint256 _newVal) external onlyOwner {\n        baseBountyUsdTarget = _newVal;\n        emit BaseBountyUsdTargetUpdated(_newVal);\n    }\n\n    function setHunterShare(uint256 _newVal) external onlyOwner {\n        require(_newVal <= 10000, \"override\");\n        HUNTER_SHARE = _newVal;\n        emit HunterShareUpdated(_newVal);\n    }\n\n    function setMaxBaseBounty(uint256 _newVal) external onlyOwner {\n        maxBaseBounty = _newVal;\n        emit MaxBaseBountyUpdated(_newVal);\n    }\n\n    function setBountyBooster(uint256 _newVal) external onlyOwner {\n        bountyBooster = _newVal;\n        emit BountyBoosterUpdated(_newVal);\n    }\n\n    function setSlippageLimit(uint256 _newVal) external onlyOwner {\n        slippageLimit = _newVal;\n        emit SlippageLimitUpdated(_newVal);\n    }\n\n    function setBounties() external onlyOwner {\n        bounties[1] = getLpMfdBounty;\n        bounties[2] = getChefBounty;\n        bounties[3] = getAutoCompoundBounty;\n    }\n\n    function recoverERC20(address tokenAddress, uint256 tokenAmount)\n        external\n        onlyOwner\n    {\n        IERC20(tokenAddress).safeTransfer(owner(), tokenAmount);\n    }\n}\n"
    },
    "contracts/dependencies/math/BConst.sol": {
      "content": "// https://github.com/balancer-labs/balancer-core/blob/master/contracts/BConst.sol\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity 0.7.6;\n\ncontract BConst {\n  uint public constant BONE = 10**18;\n\n  uint public constant MIN_BOUND_TOKENS = 2;\n  uint public constant MAX_BOUND_TOKENS = 8;\n\n  uint public constant MIN_FEE = BONE / 10**6;\n  uint public constant MAX_FEE = BONE / 10;\n  uint public constant EXIT_FEE = 0;\n\n  uint public constant MIN_WEIGHT = BONE;\n  uint public constant MAX_WEIGHT = BONE * 50;\n  uint public constant MAX_TOTAL_WEIGHT = BONE * 50;\n  uint public constant MIN_BALANCE = BONE / 10**12;\n\n  uint public constant INIT_POOL_SUPPLY = BONE * 100;\n\n  uint public constant MIN_BPOW_BASE = 1 wei;\n  uint public constant MAX_BPOW_BASE = (2 * BONE) - 1 wei;\n  uint public constant BPOW_PRECISION = BONE / 10**10;\n\n  uint public constant MAX_IN_RATIO = BONE / 2;\n  uint public constant MAX_OUT_RATIO = (BONE / 3) + 1 wei;\n}"
    },
    "contracts/dependencies/math/BNum.sol": {
      "content": "// https://github.com/balancer-labs/balancer-core/blob/master/contracts/BNum.sol\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity 0.7.6;\n\nimport './BConst.sol';\n\ncontract BNum is BConst {\n  function btoi(uint a) internal pure returns (uint) {\n    return a / BONE;\n  }\n\n  function bfloor(uint a) internal pure returns (uint) {\n    return btoi(a) * BONE;\n  }\n\n  function badd(uint a, uint b) internal pure returns (uint) {\n    uint c = a + b;\n    require(c >= a, 'ERR_ADD_OVERFLOW');\n    return c;\n  }\n\n  function bsub(uint a, uint b) internal pure returns (uint) {\n    (uint c, bool flag) = bsubSign(a, b);\n    require(!flag, 'ERR_SUB_UNDERFLOW');\n    return c;\n  }\n\n  function bsubSign(uint a, uint b) internal pure returns (uint, bool) {\n    if (a >= b) {\n      return (a - b, false);\n    } else {\n      return (b - a, true);\n    }\n  }\n\n  function bmul(uint a, uint b) internal pure returns (uint) {\n    uint c0 = a * b;\n    require(a == 0 || c0 / a == b, 'ERR_MUL_OVERFLOW');\n    uint c1 = c0 + (BONE / 2);\n    require(c1 >= c0, 'ERR_MUL_OVERFLOW');\n    uint c2 = c1 / BONE;\n    return c2;\n  }\n\n  function bdiv(uint a, uint b) internal pure returns (uint) {\n    require(b != 0, 'ERR_DIV_ZERO');\n    uint c0 = a * BONE;\n    require(a == 0 || c0 / a == BONE, 'ERR_DIV_INTERNAL'); // bmul overflow\n    uint c1 = c0 + (b / 2);\n    require(c1 >= c0, 'ERR_DIV_INTERNAL'); //  badd require\n    uint c2 = c1 / b;\n    return c2;\n  }\n\n  // DSMath.wpow\n  function bpowi(uint a, uint n) internal pure returns (uint) {\n    uint z = n % 2 != 0 ? a : BONE;\n\n    for (n /= 2; n != 0; n /= 2) {\n      a = bmul(a, a);\n\n      if (n % 2 != 0) {\n        z = bmul(z, a);\n      }\n    }\n    return z;\n  }\n\n  // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\n  // Use `bpowi` for `b^e` and `bpowK` for k iterations\n  // of approximation of b^0.w\n  function bpow(uint base, uint exp) internal pure returns (uint) {\n    require(base >= MIN_BPOW_BASE, 'ERR_BPOW_BASE_TOO_LOW');\n    require(base <= MAX_BPOW_BASE, 'ERR_BPOW_BASE_TOO_HIGH');\n\n    uint whole = bfloor(exp);\n    uint remain = bsub(exp, whole);\n\n    uint wholePow = bpowi(base, btoi(whole));\n\n    if (remain == 0) {\n      return wholePow;\n    }\n\n    uint partialResult = bpowApprox(base, remain, BPOW_PRECISION);\n    return bmul(wholePow, partialResult);\n  }\n\n  function bpowApprox(\n    uint base,\n    uint exp,\n    uint precision\n  ) internal pure returns (uint) {\n    // term 0:\n    uint a = exp;\n    (uint x, bool xneg) = bsubSign(base, BONE);\n    uint term = BONE;\n    uint sum = term;\n    bool negative = false;\n\n    // term(k) = numer / denom\n    //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\n    // each iteration, multiply previous term by (a-(k-1)) * x / k\n    // continue until term is less than precision\n    for (uint i = 1; term >= precision; i++) {\n      uint bigK = i * BONE;\n      (uint c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\n      term = bmul(term, bmul(c, x));\n      term = bdiv(term, bigK);\n      if (term == 0) break;\n\n      if (xneg) negative = !negative;\n      if (cneg) negative = !negative;\n      if (negative) {\n        sum = bsub(sum, term);\n      } else {\n        sum = badd(sum, term);\n      }\n    }\n\n    return sum;\n  }\n}"
    },
    "contracts/dependencies/math/HomoraMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\n\nimport \"../openzeppelin/contracts/SafeMath.sol\";\n\nlibrary HomoraMath {\n  using SafeMath for uint;\n\n  function divCeil(uint lhs, uint rhs) internal pure returns (uint) {\n    return lhs.add(rhs).sub(1) / rhs;\n  }\n\n  function fmul(uint lhs, uint rhs) internal pure returns (uint) {\n    return lhs.mul(rhs) / (2**112);\n  }\n\n  function fdiv(uint lhs, uint rhs) internal pure returns (uint) {\n    return lhs.mul(2**112) / rhs;\n  }\n\n  // implementation from https://github.com/Uniswap/uniswap-lib/commit/99f3f28770640ba1bb1ff460ac7c5292fb8291a0\n  // original implementation: https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\n  function sqrt(uint x) internal pure returns (uint) {\n    if (x == 0) return 0;\n    uint xx = x;\n    uint r = 1;\n\n    if (xx >= 0x100000000000000000000000000000000) {\n      xx >>= 128;\n      r <<= 64;\n    }\n\n    if (xx >= 0x10000000000000000) {\n      xx >>= 64;\n      r <<= 32;\n    }\n    if (xx >= 0x100000000) {\n      xx >>= 32;\n      r <<= 16;\n    }\n    if (xx >= 0x10000) {\n      xx >>= 16;\n      r <<= 8;\n    }\n    if (xx >= 0x100) {\n      xx >>= 8;\n      r <<= 4;\n    }\n    if (xx >= 0x10) {\n      xx >>= 4;\n      r <<= 2;\n    }\n    if (xx >= 0x8) {\n      r <<= 1;\n    }\n\n    r = (r + x / r) >> 1;\n    r = (r + x / r) >> 1;\n    r = (r + x / r) >> 1;\n    r = (r + x / r) >> 1;\n    r = (r + x / r) >> 1;\n    r = (r + x / r) >> 1;\n    r = (r + x / r) >> 1; // Seven iterations should be enough\n    uint r1 = x / r;\n    return (r < r1 ? r : r1);\n  }\n}"
    },
    "contracts/dependencies/openzeppelin/contracts/Address.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n  /**\n   * @dev Returns true if `account` is a contract.\n   *\n   * [IMPORTANT]\n   * ====\n   * It is unsafe to assume that an address for which this function returns\n   * false is an externally-owned account (EOA) and not a contract.\n   *\n   * Among others, `isContract` will return false for the following\n   * types of addresses:\n   *\n   *  - an externally-owned account\n   *  - a contract in construction\n   *  - an address where a contract will be created\n   *  - an address where a contract lived, but was destroyed\n   * ====\n   */\n  function isContract(address account) internal view returns (bool) {\n    // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n    // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n    // for accounts without code, i.e. `keccak256('')`\n    bytes32 codehash;\n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      codehash := extcodehash(account)\n    }\n    return (codehash != accountHash && codehash != 0x0);\n  }\n\n  /**\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n   * `recipient`, forwarding all available gas and reverting on errors.\n   *\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\n   * imposed by `transfer`, making them unable to receive funds via\n   * `transfer`. {sendValue} removes this limitation.\n   *\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n   *\n   * IMPORTANT: because control is transferred to `recipient`, care must be\n   * taken to not create reentrancy vulnerabilities. Consider using\n   * {ReentrancyGuard} or the\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n   */\n  function sendValue(address payable recipient, uint256 amount) internal {\n    require(address(this).balance >= amount, 'Address: insufficient balance');\n\n    // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n    (bool success, ) = recipient.call{value: amount}('');\n    require(success, 'Address: unable to send value, recipient may have reverted');\n  }\n}\n"
    },
    "contracts/dependencies/openzeppelin/contracts/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n  function _msgSender() internal view virtual returns (address payable) {\n    return msg.sender;\n  }\n\n  function _msgData() internal view virtual returns (bytes memory) {\n    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n    return msg.data;\n  }\n}\n"
    },
    "contracts/dependencies/openzeppelin/contracts/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity 0.7.6;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}"
    },
    "contracts/dependencies/openzeppelin/contracts/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport './Context.sol';\nimport './IERC20.sol';\nimport './SafeMath.sol';\nimport './Address.sol';\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n  using SafeMath for uint256;\n  using Address for address;\n\n  mapping(address => uint256) private _balances;\n\n  mapping(address => mapping(address => uint256)) private _allowances;\n\n  uint256 private _totalSupply;\n\n  string private _name;\n  string private _symbol;\n  uint8 internal _decimals;\n\n  /**\n   * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n   * a default value of 18.\n   *\n   * To select a different value for {decimals}, use {_setupDecimals}.\n   *\n   * All three of these values are immutable: they can only be set once during\n   * construction.\n   */\n  constructor(string memory name_, string memory symbol_) {\n    _name = name_;\n    _symbol = symbol_;\n    _decimals = 18;\n  }\n\n  /**\n   * @dev Returns the name of the token.\n   */\n  function name() public view returns (string memory) {\n    return _name;\n  }\n\n  /**\n   * @dev Returns the symbol of the token, usually a shorter version of the\n   * name.\n   */\n  function symbol() public view returns (string memory) {\n    return _symbol;\n  }\n\n  /**\n   * @dev Returns the number of decimals used to get its user representation.\n   * For example, if `decimals` equals `2`, a balance of `505` tokens should\n   * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n   *\n   * Tokens usually opt for a value of 18, imitating the relationship between\n   * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n   * called.\n   *\n   * NOTE: This information is only used for _display_ purposes: it in\n   * no way affects any of the arithmetic of the contract, including\n   * {IERC20-balanceOf} and {IERC20-transfer}.\n   */\n  function decimals() public view returns (uint8) {\n    return _decimals;\n  }\n\n  /**\n   * @dev See {IERC20-totalSupply}.\n   */\n  function totalSupply() public view override returns (uint256) {\n    return _totalSupply;\n  }\n\n  /**\n   * @dev See {IERC20-balanceOf}.\n   */\n  function balanceOf(address account) public view override returns (uint256) {\n    return _balances[account];\n  }\n\n  /**\n   * @dev See {IERC20-transfer}.\n   *\n   * Requirements:\n   *\n   * - `recipient` cannot be the zero address.\n   * - the caller must have a balance of at least `amount`.\n   */\n  function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n    _transfer(_msgSender(), recipient, amount);\n    return true;\n  }\n\n  /**\n   * @dev See {IERC20-allowance}.\n   */\n  function allowance(address owner, address spender)\n    public\n    view\n    virtual\n    override\n    returns (uint256)\n  {\n    return _allowances[owner][spender];\n  }\n\n  /**\n   * @dev See {IERC20-approve}.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function approve(address spender, uint256 amount) public virtual override returns (bool) {\n    _approve(_msgSender(), spender, amount);\n    return true;\n  }\n\n  /**\n   * @dev See {IERC20-transferFrom}.\n   *\n   * Emits an {Approval} event indicating the updated allowance. This is not\n   * required by the EIP. See the note at the beginning of {ERC20};\n   *\n   * Requirements:\n   * - `sender` and `recipient` cannot be the zero address.\n   * - `sender` must have a balance of at least `amount`.\n   * - the caller must have allowance for ``sender``'s tokens of at least\n   * `amount`.\n   */\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) public virtual override returns (bool) {\n    _transfer(sender, recipient, amount);\n    _approve(\n      sender,\n      _msgSender(),\n      _allowances[sender][_msgSender()].sub(amount, 'ERC20: transfer amount exceeds allowance')\n    );\n    return true;\n  }\n\n  /**\n   * @dev Atomically increases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to {approve} that can be used as a mitigation for\n   * problems described in {IERC20-approve}.\n   *\n   * Emits an {Approval} event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n    return true;\n  }\n\n  /**\n   * @dev Atomically decreases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to {approve} that can be used as a mitigation for\n   * problems described in {IERC20-approve}.\n   *\n   * Emits an {Approval} event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   * - `spender` must have allowance for the caller of at least\n   * `subtractedValue`.\n   */\n  function decreaseAllowance(address spender, uint256 subtractedValue)\n    public\n    virtual\n    returns (bool)\n  {\n    _approve(\n      _msgSender(),\n      spender,\n      _allowances[_msgSender()][spender].sub(\n        subtractedValue,\n        'ERC20: decreased allowance below zero'\n      )\n    );\n    return true;\n  }\n\n  /**\n   * @dev Moves tokens `amount` from `sender` to `recipient`.\n   *\n   * This is internal function is equivalent to {transfer}, and can be used to\n   * e.g. implement automatic token fees, slashing mechanisms, etc.\n   *\n   * Emits a {Transfer} event.\n   *\n   * Requirements:\n   *\n   * - `sender` cannot be the zero address.\n   * - `recipient` cannot be the zero address.\n   * - `sender` must have a balance of at least `amount`.\n   */\n  function _transfer(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) internal virtual {\n    require(sender != address(0), 'ERC20: transfer from the zero address');\n    require(recipient != address(0), 'ERC20: transfer to the zero address');\n\n    _beforeTokenTransfer(sender, recipient, amount);\n\n    _balances[sender] = _balances[sender].sub(amount, 'ERC20: transfer amount exceeds balance');\n    _balances[recipient] = _balances[recipient].add(amount);\n    emit Transfer(sender, recipient, amount);\n  }\n\n  /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n   * the total supply.\n   *\n   * Emits a {Transfer} event with `from` set to the zero address.\n   *\n   * Requirements\n   *\n   * - `to` cannot be the zero address.\n   */\n  function _mint(address account, uint256 amount) internal virtual {\n    require(account != address(0), 'ERC20: mint to the zero address');\n\n    _beforeTokenTransfer(address(0), account, amount);\n\n    _totalSupply = _totalSupply.add(amount);\n    _balances[account] = _balances[account].add(amount);\n    emit Transfer(address(0), account, amount);\n  }\n\n  /**\n   * @dev Destroys `amount` tokens from `account`, reducing the\n   * total supply.\n   *\n   * Emits a {Transfer} event with `to` set to the zero address.\n   *\n   * Requirements\n   *\n   * - `account` cannot be the zero address.\n   * - `account` must have at least `amount` tokens.\n   */\n  function _burn(address account, uint256 amount) internal virtual {\n    require(account != address(0), 'ERC20: burn from the zero address');\n\n    _beforeTokenTransfer(account, address(0), amount);\n\n    _balances[account] = _balances[account].sub(amount, 'ERC20: burn amount exceeds balance');\n    _totalSupply = _totalSupply.sub(amount);\n    emit Transfer(account, address(0), amount);\n  }\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n   *\n   * This is internal function is equivalent to `approve`, and can be used to\n   * e.g. set automatic allowances for certain subsystems, etc.\n   *\n   * Emits an {Approval} event.\n   *\n   * Requirements:\n   *\n   * - `owner` cannot be the zero address.\n   * - `spender` cannot be the zero address.\n   */\n  function _approve(\n    address owner,\n    address spender,\n    uint256 amount\n  ) internal virtual {\n    require(owner != address(0), 'ERC20: approve from the zero address');\n    require(spender != address(0), 'ERC20: approve to the zero address');\n\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  /**\n    * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n    *\n    * Does not update the allowance amount in case of infinite allowance.\n    * Revert if not enough allowance is available.\n    *\n    * Might emit an {Approval} event.\n    */\n  function _spendAllowance(\n      address owner,\n      address spender,\n      uint256 amount\n  ) internal virtual {\n      uint256 currentAllowance = allowance(owner, spender);\n      if (currentAllowance != type(uint256).max) {\n          require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n          _approve(owner, spender, currentAllowance - amount);\n      }\n  }\n\n  /**\n   * @dev Sets {decimals} to a value other than the default one of 18.\n   *\n   * WARNING: This function should only be called from the constructor. Most\n   * applications that interact with token contracts will not expect\n   * {decimals} to ever change, and may work incorrectly if it does.\n   */\n  function _setupDecimals(uint8 decimals_) internal {\n    _decimals = decimals_;\n  }\n\n  /**\n   * @dev Hook that is called before any transfer of tokens. This includes\n   * minting and burning.\n   *\n   * Calling conditions:\n   *\n   * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n   * will be to transferred to `to`.\n   * - when `from` is zero, `amount` tokens will be minted for `to`.\n   * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n   * - `from` and `to` are never both zero.\n   *\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n   */\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual {}\n}\n"
    },
    "contracts/dependencies/openzeppelin/contracts/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity 0.7.6;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}"
    },
    "contracts/dependencies/openzeppelin/contracts/IERC20.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) external returns (bool);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/dependencies/openzeppelin/contracts/IERC20Detailed.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\nimport {IERC20} from './IERC20.sol';\n\ninterface IERC20Detailed is IERC20 {\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/dependencies/openzeppelin/contracts/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport './Context.sol';\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n  address private _owner;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  /**\n   * @dev Initializes the contract setting the deployer as the initial owner.\n   */\n  constructor() {\n    address msgSender = _msgSender();\n    _owner = msgSender;\n    emit OwnershipTransferred(address(0), msgSender);\n  }\n\n  /**\n   * @dev Returns the address of the current owner.\n   */\n  function owner() public view returns (address) {\n    return _owner;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(_owner == _msgSender(), 'Ownable: caller is not the owner');\n    _;\n  }\n\n  /**\n   * @dev Leaves the contract without owner. It will not be possible to call\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\n   *\n   * NOTE: Renouncing ownership will leave the contract without an owner,\n   * thereby removing any functionality that is only available to the owner.\n   */\n  function renounceOwnership() public virtual onlyOwner {\n    emit OwnershipTransferred(_owner, address(0));\n    _owner = address(0);\n  }\n\n  /**\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\n   * Can only be called by the current owner.\n   */\n  function transferOwnership(address newOwner) public virtual onlyOwner {\n    require(newOwner != address(0), 'Ownable: new owner is the zero address');\n    emit OwnershipTransferred(_owner, newOwner);\n    _owner = newOwner;\n  }\n}\n"
    },
    "contracts/dependencies/openzeppelin/contracts/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity 0.7.6;\n\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}"
    },
    "contracts/dependencies/openzeppelin/contracts/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport {IERC20} from './IERC20.sol';\nimport {SafeMath} from './SafeMath.sol';\nimport {Address} from './Address.sol';\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n  using SafeMath for uint256;\n  using Address for address;\n\n  function safeTransfer(\n    IERC20 token,\n    address to,\n    uint256 value\n  ) internal {\n    callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n  }\n\n  function safeTransferFrom(\n    IERC20 token,\n    address from,\n    address to,\n    uint256 value\n  ) internal {\n    callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n  }\n\n  function safeApprove(\n    IERC20 token,\n    address spender,\n    uint256 value\n  ) internal {\n    require(\n      (value == 0) || (token.allowance(address(this), spender) == 0),\n      'SafeERC20: approve from non-zero to non-zero allowance'\n    );\n    callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n  }\n\n  function callOptionalReturn(IERC20 token, bytes memory data) private {\n    require(address(token).isContract(), 'SafeERC20: call to non-contract');\n\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool success, bytes memory returndata) = address(token).call(data);\n    require(success, 'SafeERC20: low-level call failed');\n\n    if (returndata.length > 0) {\n      // Return data is optional\n      // solhint-disable-next-line max-line-length\n      require(abi.decode(returndata, (bool)), 'SafeERC20: ERC20 operation did not succeed');\n    }\n  }\n}\n"
    },
    "contracts/dependencies/openzeppelin/contracts/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n  /**\n   * @dev Returns the addition of two unsigned integers, reverting on\n   * overflow.\n   *\n   * Counterpart to Solidity's `+` operator.\n   *\n   * Requirements:\n   * - Addition cannot overflow.\n   */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, 'SafeMath: addition overflow');\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the subtraction of two unsigned integers, reverting on\n   * overflow (when the result is negative).\n   *\n   * Counterpart to Solidity's `-` operator.\n   *\n   * Requirements:\n   * - Subtraction cannot overflow.\n   */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    return sub(a, b, 'SafeMath: subtraction overflow');\n  }\n\n  /**\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n   * overflow (when the result is negative).\n   *\n   * Counterpart to Solidity's `-` operator.\n   *\n   * Requirements:\n   * - Subtraction cannot overflow.\n   */\n  function sub(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b <= a, errorMessage);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the multiplication of two unsigned integers, reverting on\n   * overflow.\n   *\n   * Counterpart to Solidity's `*` operator.\n   *\n   * Requirements:\n   * - Multiplication cannot overflow.\n   */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b, 'SafeMath: multiplication overflow');\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the integer division of two unsigned integers. Reverts on\n   * division by zero. The result is rounded towards zero.\n   *\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\n   * uses an invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   * - The divisor cannot be zero.\n   */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return div(a, b, 'SafeMath: division by zero');\n  }\n\n  /**\n   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n   * division by zero. The result is rounded towards zero.\n   *\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\n   * uses an invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   * - The divisor cannot be zero.\n   */\n  function div(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    // Solidity only automatically asserts when dividing by 0\n    require(b > 0, errorMessage);\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n   * Reverts when dividing by zero.\n   *\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\n   * invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   * - The divisor cannot be zero.\n   */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    return mod(a, b, 'SafeMath: modulo by zero');\n  }\n\n  /**\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n   * Reverts with custom message when dividing by zero.\n   *\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\n   * invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   * - The divisor cannot be zero.\n   */\n  function mod(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b != 0, errorMessage);\n    return a % b;\n  }\n\n  function min(uint x, uint y) internal pure returns (uint z) {\n        z = x < y ? x : y;\n    }\n}\n"
    },
    "contracts/dependencies/openzeppelin/upgradeability/AdminUpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\nimport './BaseAdminUpgradeabilityProxy.sol';\n\n/**\n * @title AdminUpgradeabilityProxy\n * @dev Extends from BaseAdminUpgradeabilityProxy with a constructor for\n * initializing the implementation, admin, and init data.\n */\ncontract AdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, UpgradeabilityProxy {\n  /**\n   * Contract constructor.\n   * @param _logic address of the initial implementation.\n   * @param _admin Address of the proxy administrator.\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n   */\n  constructor(\n    address _logic,\n    address _admin,\n    bytes memory _data\n  ) payable UpgradeabilityProxy(_logic, _data) {\n    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));\n    _setAdmin(_admin);\n  }\n\n  /**\n   * @dev Only fall back when the sender is not the admin.\n   */\n  function _willFallback() internal override(BaseAdminUpgradeabilityProxy, Proxy) {\n    BaseAdminUpgradeabilityProxy._willFallback();\n  }\n}\n"
    },
    "contracts/dependencies/openzeppelin/upgradeability/BaseAdminUpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\nimport './UpgradeabilityProxy.sol';\n\n/**\n * @title BaseAdminUpgradeabilityProxy\n * @dev This contract combines an upgradeability proxy with an authorization\n * mechanism for administrative tasks.\n * All external functions in this contract must be guarded by the\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\n * feature proposal that would enable this to be done automatically.\n */\ncontract BaseAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {\n  /**\n   * @dev Emitted when the administration has been transferred.\n   * @param previousAdmin Address of the previous admin.\n   * @param newAdmin Address of the new admin.\n   */\n  event AdminChanged(address previousAdmin, address newAdmin);\n\n  /**\n   * @dev Storage slot with the admin of the contract.\n   * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n   * validated in the constructor.\n   */\n  bytes32 internal constant ADMIN_SLOT =\n    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n  /**\n   * @dev Modifier to check whether the `msg.sender` is the admin.\n   * If it is, it will run the function. Otherwise, it will delegate the call\n   * to the implementation.\n   */\n  modifier ifAdmin() {\n    if (msg.sender == _admin()) {\n      _;\n    } else {\n      _fallback();\n    }\n  }\n\n  /**\n   * @return _address The address of the proxy admin.\n   */\n  function admin() external ifAdmin returns (address _address) {\n    return _admin();\n  }\n\n  /**\n   * @return _address The address of the implementation.\n   */\n  function implementation() external ifAdmin returns (address _address) {\n    return _implementation();\n  }\n\n  /**\n   * @dev Changes the admin of the proxy.\n   * Only the current admin can call this function.\n   * @param newAdmin Address to transfer proxy administration to.\n   */\n  function changeAdmin(address newAdmin) external ifAdmin {\n    require(newAdmin != address(0), 'Cannot change the admin of a proxy to the zero address');\n    emit AdminChanged(_admin(), newAdmin);\n    _setAdmin(newAdmin);\n  }\n\n  /**\n   * @dev Upgrade the backing implementation of the proxy.\n   * Only the admin can call this function.\n   * @param newImplementation Address of the new implementation.\n   */\n  function upgradeTo(address newImplementation) external ifAdmin {\n    _upgradeTo(newImplementation);\n  }\n\n  /**\n   * @dev Upgrade the backing implementation of the proxy and call a function\n   * on the new implementation.\n   * This is useful to initialize the proxied contract.\n   * @param newImplementation Address of the new implementation.\n   * @param data Data to send as msg.data in the low level call.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   */\n  function upgradeToAndCall(address newImplementation, bytes calldata data)\n    external\n    payable\n    ifAdmin\n  {\n    _upgradeTo(newImplementation);\n    (bool success, ) = newImplementation.delegatecall(data);\n    require(success);\n  }\n\n  /**\n   * @return adm The admin slot.\n   */\n  function _admin() internal view returns (address adm) {\n    bytes32 slot = ADMIN_SLOT;\n    //solium-disable-next-line\n    assembly {\n      adm := sload(slot)\n    }\n  }\n\n  /**\n   * @dev Sets the address of the proxy admin.\n   * @param newAdmin Address of the new proxy admin.\n   */\n  function _setAdmin(address newAdmin) internal {\n    bytes32 slot = ADMIN_SLOT;\n    //solium-disable-next-line\n    assembly {\n      sstore(slot, newAdmin)\n    }\n  }\n\n  /**\n   * @dev Only fall back when the sender is not the admin.\n   */\n  function _willFallback() internal virtual override {\n    require(msg.sender != _admin(), 'Cannot call fallback function from the proxy admin');\n    super._willFallback();\n  }\n}\n"
    },
    "contracts/dependencies/openzeppelin/upgradeability/BaseUpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\nimport './Proxy.sol';\nimport '../contracts/Address.sol';\n\n/**\n * @title BaseUpgradeabilityProxy\n * @dev This contract implements a proxy that allows to change the\n * implementation address to which it will delegate.\n * Such a change is called an implementation upgrade.\n */\ncontract BaseUpgradeabilityProxy is Proxy {\n  /**\n   * @dev Emitted when the implementation is upgraded.\n   * @param implementation Address of the new implementation.\n   */\n  event Upgraded(address indexed implementation);\n\n  /**\n   * @dev Storage slot with the address of the current implementation.\n   * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n   * validated in the constructor.\n   */\n  bytes32 internal constant IMPLEMENTATION_SLOT =\n    0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n  /**\n   * @dev Returns the current implementation.\n   * @return impl Address of the current implementation\n   */\n  function _implementation() internal view override returns (address impl) {\n    bytes32 slot = IMPLEMENTATION_SLOT;\n    //solium-disable-next-line\n    assembly {\n      impl := sload(slot)\n    }\n  }\n\n  /**\n   * @dev Upgrades the proxy to a new implementation.\n   * @param newImplementation Address of the new implementation.\n   */\n  function _upgradeTo(address newImplementation) internal {\n    _setImplementation(newImplementation);\n    emit Upgraded(newImplementation);\n  }\n\n  /**\n   * @dev Sets the implementation address of the proxy.\n   * @param newImplementation Address of the new implementation.\n   */\n  function _setImplementation(address newImplementation) internal {\n    require(\n      Address.isContract(newImplementation),\n      'Cannot set a proxy implementation to a non-contract address'\n    );\n\n    bytes32 slot = IMPLEMENTATION_SLOT;\n\n    //solium-disable-next-line\n    assembly {\n      sstore(slot, newImplementation)\n    }\n  }\n}\n"
    },
    "contracts/dependencies/openzeppelin/upgradeability/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\nimport \"./Initializable.sol\";\n\ncontract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address payable) {\n        return payable(msg.sender);\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this;\n        return msg.data;\n    }\n\n    uint256[50] private __gap;\n}"
    },
    "contracts/dependencies/openzeppelin/upgradeability/Initializable.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private initializing;\n\n    /**\n     * @dev Modifier to use in the initializer function of a contract.\n     */\n    modifier initializer() {\n        require(\n            initializing || isConstructor() || !initialized,\n            \"Contract instance has already been initialized\"\n        );\n\n        bool isTopLevelCall = !initializing;\n        if (isTopLevelCall) {\n            initializing = true;\n            initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            initializing = false;\n        }\n    }\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function isConstructor() private view returns (bool) {\n        // extcodesize checks the size of the code stored in an address, and\n        // address returns the current address. Since the code is still not\n        // deployed when running a constructor, any checks on its code size will\n        // yield zero, making it an effective way to detect if a contract is\n        // under construction or not.\n        uint256 cs;\n        //solium-disable-next-line\n        assembly {\n            cs := extcodesize(address())\n        }\n        return cs == 0;\n    }\n\n    modifier onlyInitializing() {\n        require(initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    // Reserved storage space to allow for layout changes in the future.\n    uint256[50] private ______gap;\n}\n"
    },
    "contracts/dependencies/openzeppelin/upgradeability/InitializableAdminUpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\nimport './BaseAdminUpgradeabilityProxy.sol';\nimport './InitializableUpgradeabilityProxy.sol';\n\n/**\n * @title InitializableAdminUpgradeabilityProxy\n * @dev Extends from BaseAdminUpgradeabilityProxy with an initializer for\n * initializing the implementation, admin, and init data.\n */\ncontract InitializableAdminUpgradeabilityProxy is\n  BaseAdminUpgradeabilityProxy,\n  InitializableUpgradeabilityProxy\n{\n  /**\n   * Contract initializer.\n   * @param logic address of the initial implementation.\n   * @param admin Address of the proxy administrator.\n   * @param data Data to send as msg.data to the implementation to initialize the proxied contract.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n   */\n  function initialize(\n    address logic,\n    address admin,\n    bytes memory data\n  ) public payable {\n    require(_implementation() == address(0));\n    InitializableUpgradeabilityProxy.initialize(logic, data);\n    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));\n    _setAdmin(admin);\n  }\n\n  /**\n   * @dev Only fall back when the sender is not the admin.\n   */\n  function _willFallback() internal override(BaseAdminUpgradeabilityProxy, Proxy) {\n    BaseAdminUpgradeabilityProxy._willFallback();\n  }\n}\n"
    },
    "contracts/dependencies/openzeppelin/upgradeability/InitializableUpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\nimport './BaseUpgradeabilityProxy.sol';\n\n/**\n * @title InitializableUpgradeabilityProxy\n * @dev Extends BaseUpgradeabilityProxy with an initializer for initializing\n * implementation and init data.\n */\ncontract InitializableUpgradeabilityProxy is BaseUpgradeabilityProxy {\n  /**\n   * @dev Contract initializer.\n   * @param _logic Address of the initial implementation.\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n   */\n  function initialize(address _logic, bytes memory _data) public payable {\n    require(_implementation() == address(0));\n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));\n    _setImplementation(_logic);\n    if (_data.length > 0) {\n      (bool success, ) = _logic.delegatecall(_data);\n      require(success);\n    }\n  }\n}\n"
    },
    "contracts/dependencies/openzeppelin/upgradeability/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\nimport \"./Initializable.sol\";\nimport \"./ContextUpgradeable.sol\";\n\ncontract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    \n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    \n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n   \n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    \n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    \n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    \n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    uint256[49] private __gap;\n}"
    },
    "contracts/dependencies/openzeppelin/upgradeability/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\nimport \"./Initializable.sol\";\nimport \"./ContextUpgradeable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/dependencies/openzeppelin/upgradeability/Proxy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\n/**\n * @title Proxy\n * @dev Implements delegation of calls to other contracts, with proper\n * forwarding of return values and bubbling of failures.\n * It defines a fallback function that delegates all calls to the address\n * returned by the abstract _implementation() internal function.\n */\nabstract contract Proxy {\n  /**\n   * @dev Fallback function.\n   * Implemented entirely in `_fallback`.\n   */\n  fallback() external payable {\n    _fallback();\n  }\n\n  /**\n   * @return The Address of the implementation.\n   */\n  function _implementation() internal view virtual returns (address);\n\n  /**\n   * @dev Delegates execution to an implementation contract.\n   * This is a low level function that doesn't return to its internal call site.\n   * It will return to the external caller whatever the implementation returns.\n   * @param implementation Address to delegate.\n   */\n  function _delegate(address implementation) internal {\n    //solium-disable-next-line\n    assembly {\n      // Copy msg.data. We take full control of memory in this inline assembly\n      // block because it will not return to Solidity code. We overwrite the\n      // Solidity scratch pad at memory position 0.\n      calldatacopy(0, 0, calldatasize())\n\n      // Call the implementation.\n      // out and outsize are 0 because we don't know the size yet.\n      let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n      // Copy the returned data.\n      returndatacopy(0, 0, returndatasize())\n\n      switch result\n        // delegatecall returns 0 on error.\n        case 0 {\n          revert(0, returndatasize())\n        }\n        default {\n          return(0, returndatasize())\n        }\n    }\n  }\n\n  /**\n   * @dev Function that is run as the first thing in the fallback function.\n   * Can be redefined in derived contracts to add functionality.\n   * Redefinitions must call super._willFallback().\n   */\n  function _willFallback() internal virtual {}\n\n  /**\n   * @dev fallback implementation.\n   * Extracted to enable manual triggering.\n   */\n  function _fallback() internal {\n    _willFallback();\n    _delegate(_implementation());\n  }\n}\n"
    },
    "contracts/dependencies/openzeppelin/upgradeability/UpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\nimport './BaseUpgradeabilityProxy.sol';\n\n/**\n * @title UpgradeabilityProxy\n * @dev Extends BaseUpgradeabilityProxy with a constructor for initializing\n * implementation and init data.\n */\ncontract UpgradeabilityProxy is BaseUpgradeabilityProxy {\n  /**\n   * @dev Contract constructor.\n   * @param _logic Address of the initial implementation.\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n   */\n  constructor(address _logic, bytes memory _data) payable {\n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));\n    _setImplementation(_logic);\n    if (_data.length > 0) {\n      (bool success, ) = _logic.delegatecall(_data);\n      require(success);\n    }\n  }\n}\n"
    },
    "contracts/dependencies/uniswap/contracts/UniswapV2Library.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.5.0;\n\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\nimport {SafeMath} from '../../openzeppelin/contracts/SafeMath.sol';\n\nlibrary UniswapV2Library {\n    using SafeMath for uint;\n\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(uint(keccak256(abi.encodePacked(\n                hex'ff',\n                factory,\n                keccak256(abi.encodePacked(token0, token1)),\n                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\n            ))));\n    }\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\n        (address token0,) = sortTokens(tokenA, tokenB);\n        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\n        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\n        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        amountB = amountA.mul(reserveB) / reserveA;\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        uint amountInWithFee = amountIn.mul(997);\n        uint numerator = amountInWithFee.mul(reserveOut);\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\n        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\n        uint denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n        amounts = new uint[](path.length);\n        amounts[0] = amountIn;\n        for (uint i; i < path.length - 1; i++) {\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n        }\n    }\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n        amounts = new uint[](path.length);\n        amounts[amounts.length - 1] = amountOut;\n        for (uint i = path.length - 1; i > 0; i--) {\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n        }\n    }\n}"
    },
    "contracts/dependencies/uniswap/contracts/UniswapV2OracleLibrary.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.5.0;\n\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\nimport '@uniswap/lib/contracts/libraries/FixedPoint.sol';\n\n// library with helper methods for oracles that are concerned with computing average prices\nlibrary UniswapV2OracleLibrary {\n    using FixedPoint for *;\n\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\n    function currentBlockTimestamp() internal view returns (uint32) {\n        return uint32(block.timestamp % 2 ** 32);\n    }\n\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\n    function currentCumulativePrices(\n        address pair\n    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\n        blockTimestamp = currentBlockTimestamp();\n        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\n        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\n\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\n        if (blockTimestampLast != blockTimestamp) {\n            // subtraction overflow is desired\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n            // addition overflow is desired\n            // counterfactual\n            price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\n            // counterfactual\n            price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\n        }\n    }\n}"
    },
    "contracts/dependencies/uniswap/contracts/UQ112x112.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\n\n// range: [0, 2**112 - 1]\n// resolution: 1 / 2**112\n\nlibrary UQ112x112 {\n    uint224 constant Q112 = 2**112;\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 y) internal pure returns (uint224 z) {\n        z = uint224(y) * Q112; // never overflows\n    }\n\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\n        z = x / uint224(y);\n    }\n}\n"
    },
    "contracts/dependencies/uniswap/contracts/v3/IUniswapV3Pool.sol": {
      "content": "pragma solidity >=0.6.11;\n\nimport './pool/IUniswapV3PoolImmutables.sol';\nimport './pool/IUniswapV3PoolState.sol';\nimport './pool/IUniswapV3PoolDerivedState.sol';\nimport './pool/IUniswapV3PoolActions.sol';\nimport './pool/IUniswapV3PoolOwnerActions.sol';\nimport './pool/IUniswapV3PoolEvents.sol';\n\n/// @title The interface for a Uniswap V3 Pool\n/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\n/// to the ERC20 specification\n/// @dev The pool interface is broken up into many smaller pieces\ninterface IUniswapV3Pool is\n    IUniswapV3PoolImmutables,\n    IUniswapV3PoolState,\n    IUniswapV3PoolDerivedState,\n    IUniswapV3PoolActions,\n    IUniswapV3PoolOwnerActions,\n    IUniswapV3PoolEvents\n{\n}"
    },
    "contracts/dependencies/uniswap/contracts/v3/math/FullMath.sol": {
      "content": "pragma solidity >=0.4.0;\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n    /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    function mulDiv(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        // 512-bit multiply [prod1 prod0] = a * b\n        // Compute the product mod 2**256 and mod 2**256 - 1\n        // then use the Chinese Remainder Theorem to reconstruct\n        // the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2**256 + prod0\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(a, b, not(0))\n            prod0 := mul(a, b)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        // Handle non-overflow cases, 256 by 256 division\n        if (prod1 == 0) {\n            require(denominator > 0);\n            assembly {\n                result := div(prod0, denominator)\n            }\n            return result;\n        }\n\n        // Make sure the result is less than 2**256.\n        // Also prevents denominator == 0\n        require(denominator > prod1);\n\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n\n        // Make division exact by subtracting the remainder from [prod1 prod0]\n        // Compute remainder using mulmod\n        uint256 remainder;\n        assembly {\n            remainder := mulmod(a, b, denominator)\n        }\n        // Subtract 256 bit number from 512 bit number\n        assembly {\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        // Factor powers of two out of denominator\n        // Compute largest power of two divisor of denominator.\n        // Always >= 1.\n        uint256 twos = (type(uint256).max - denominator + 1) & denominator;\n        // Divide denominator by power of two\n        assembly {\n            denominator := div(denominator, twos)\n        }\n\n        // Divide [prod1 prod0] by the factors of two\n        assembly {\n            prod0 := div(prod0, twos)\n        }\n        // Shift in bits from prod1 into prod0. For this we need\n        // to flip `twos` such that it is 2**256 / twos.\n        // If twos is zero, then it becomes one\n        assembly {\n            twos := add(div(sub(0, twos), twos), 1)\n        }\n        prod0 |= prod1 * twos;\n\n        // Invert denominator mod 2**256\n        // Now that denominator is an odd number, it has an inverse\n        // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n        // Compute the inverse by starting with a seed that is correct\n        // correct for four bits. That is, denominator * inv = 1 mod 2**4\n        uint256 inv = (3 * denominator) ^ 2;\n        // Now use Newton-Raphson iteration to improve the precision.\n        // Thanks to Hensel's lifting lemma, this also works in modular\n        // arithmetic, doubling the correct bits in each step.\n        inv *= 2 - denominator * inv; // inverse mod 2**8\n        inv *= 2 - denominator * inv; // inverse mod 2**16\n        inv *= 2 - denominator * inv; // inverse mod 2**32\n        inv *= 2 - denominator * inv; // inverse mod 2**64\n        inv *= 2 - denominator * inv; // inverse mod 2**128\n        inv *= 2 - denominator * inv; // inverse mod 2**256\n\n        // Because the division is now exact we can divide by multiplying\n        // with the modular inverse of denominator. This will give us the\n        // correct result modulo 2**256. Since the precoditions guarantee\n        // that the outcome is less than 2**256, this is the final result.\n        // We don't need to compute the high bits of the result and prod1\n        // is no longer required.\n        result = prod0 * inv;\n        return result;\n    }\n\n    /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    function mulDivRoundingUp(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        result = mulDiv(a, b, denominator);\n        if (mulmod(a, b, denominator) > 0) {\n            require(result < type(uint256).max);\n            result++;\n        }\n    }\n}"
    },
    "contracts/dependencies/uniswap/contracts/v3/math/TickMath.sol": {
      "content": "pragma solidity >=0.5.0;\n\n/// @title Math library for computing sqrt prices from ticks and vice versa\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\n/// prices between 2**-128 and 2**128\nlibrary TickMath {\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\n    int24 internal constant MIN_TICK = -887272;\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\n    int24 internal constant MAX_TICK = -MIN_TICK;\n\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\n    /// @dev Throws if |tick| > max tick\n    /// @param tick The input tick for the above formula\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\n    /// at the given tick\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\n        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\n        require(int256(absTick) <= int256(MAX_TICK), 'T');\n\n        uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\n        if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n        if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n        if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n        if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n        if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n        if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n        if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n        if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n        if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n        if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n        if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n        if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n        if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n        if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n        if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n        if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n        if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n        if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n        if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n\n        if (tick > 0) ratio = type(uint256).max / ratio;\n\n        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\n        sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\n    }\n\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\n    /// ever return.\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n        // second inequality must be < because the price can never reach the price at the max tick\n        require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, 'R');\n        uint256 ratio = uint256(sqrtPriceX96) << 32;\n\n        uint256 r = ratio;\n        uint256 msb = 0;\n\n        assembly {\n            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(5, gt(r, 0xFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(4, gt(r, 0xFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(3, gt(r, 0xFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(2, gt(r, 0xF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(1, gt(r, 0x3))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := gt(r, 0x1)\n            msb := or(msb, f)\n        }\n\n        if (msb >= 128) r = ratio >> (msb - 127);\n        else r = ratio << (127 - msb);\n\n        int256 log_2 = (int256(msb) - 128) << 64;\n\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(63, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(62, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(61, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(60, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(59, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(58, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(57, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(56, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(55, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(54, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(53, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(52, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(51, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(50, f))\n        }\n\n        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\n\n        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\n        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\n\n        tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\n    }\n}"
    },
    "contracts/dependencies/uniswap/contracts/v3/OracleLibrary.sol": {
      "content": "pragma solidity >= 0.6.12;\n\nimport './math/FullMath.sol';\nimport './math/TickMath.sol';\nimport './IUniswapV3Pool.sol';\n\n/// @title Oracle library\n/// @notice Provides functions to integrate with V3 pool oracle\nlibrary OracleLibrary {\n    /// @notice Calculates time-weighted means of tick and liquidity for a given Uniswap V3 pool\n    /// @param pool Address of the pool that we want to observe\n    /// @param secondsAgo Number of seconds in the past from which to calculate the time-weighted means\n    /// @return arithmeticMeanTick The arithmetic mean tick from (block.timestamp - secondsAgo) to block.timestamp\n    /// @return harmonicMeanLiquidity The harmonic mean liquidity from (block.timestamp - secondsAgo) to block.timestamp\n    function consult(address pool, uint32 secondsAgo)\n        internal\n        view\n        returns (int24 arithmeticMeanTick, uint128 harmonicMeanLiquidity)\n    {\n        require(secondsAgo != 0, 'BP');\n\n        uint32[] memory secondsAgos = new uint32[](2);\n        secondsAgos[0] = secondsAgo;\n        secondsAgos[1] = 0;\n\n        (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s) =\n            IUniswapV3Pool(pool).observe(secondsAgos);\n\n        int56 tickCumulativesDelta = tickCumulatives[1] - tickCumulatives[0];\n        uint160 secondsPerLiquidityCumulativesDelta =\n            secondsPerLiquidityCumulativeX128s[1] - secondsPerLiquidityCumulativeX128s[0];\n\n        arithmeticMeanTick = int24(tickCumulativesDelta / int32(secondsAgo));\n        // Always round to negative infinity\n        if (tickCumulativesDelta < 0 && (tickCumulativesDelta % int32(secondsAgo) != 0)) arithmeticMeanTick--;\n\n        // We are multiplying here instead of shifting to ensure that harmonicMeanLiquidity doesn't overflow uint128\n        uint192 secondsAgoX160 = uint192(secondsAgo) * type(uint160).max;\n        harmonicMeanLiquidity = uint128(secondsAgoX160 / (uint192(secondsPerLiquidityCumulativesDelta) << 32));\n    }\n\n    /// @notice Given a tick and a token amount, calculates the amount of token received in exchange\n    /// @param tick Tick value used to calculate the quote\n    /// @param baseAmount Amount of token to be converted\n    /// @param baseToken Address of an ERC20 token contract used as the baseAmount denomination\n    /// @param quoteToken Address of an ERC20 token contract used as the quoteAmount denomination\n    /// @return quoteAmount Amount of quoteToken received for baseAmount of baseToken\n    function getQuoteAtTick(\n        int24 tick,\n        uint128 baseAmount,\n        address baseToken,\n        address quoteToken\n    ) internal pure returns (uint256 quoteAmount) {\n        uint160 sqrtRatioX96 = TickMath.getSqrtRatioAtTick(tick);\n\n        // Calculate quoteAmount with better precision if it doesn't overflow when multiplied by itself\n        if (sqrtRatioX96 <= type(uint128).max) {\n            uint256 ratioX192 = uint256(sqrtRatioX96) * sqrtRatioX96;\n            quoteAmount = baseToken < quoteToken\n                ? FullMath.mulDiv(ratioX192, baseAmount, 1 << 192)\n                : FullMath.mulDiv(1 << 192, baseAmount, ratioX192);\n        } else {\n            uint256 ratioX128 = FullMath.mulDiv(sqrtRatioX96, sqrtRatioX96, 1 << 64);\n            quoteAmount = baseToken < quoteToken\n                ? FullMath.mulDiv(ratioX128, baseAmount, 1 << 128)\n                : FullMath.mulDiv(1 << 128, baseAmount, ratioX128);\n        }\n    }\n\n    /// @notice Given a pool, it returns the number of seconds ago of the oldest stored observation\n    /// @param pool Address of Uniswap V3 pool that we want to observe\n    /// @return secondsAgo The number of seconds ago of the oldest observation stored for the pool\n    function getOldestObservationSecondsAgo(address pool) internal view returns (uint32 secondsAgo) {\n        (, , uint16 observationIndex, uint16 observationCardinality, , , ) = IUniswapV3Pool(pool).slot0();\n        require(observationCardinality > 0, 'NI');\n\n        (uint32 observationTimestamp, , , bool initialized) =\n            IUniswapV3Pool(pool).observations((observationIndex + 1) % observationCardinality);\n\n        // The next index might not be initialized if the cardinality is in the process of increasing\n        // In this case the oldest observation is always in index 0\n        if (!initialized) {\n            (observationTimestamp, , , ) = IUniswapV3Pool(pool).observations(0);\n        }\n\n        secondsAgo = uint32(block.timestamp) - observationTimestamp;\n    }\n\n    /// @notice Given a pool, it returns the tick value as of the start of the current block\n    /// @param pool Address of Uniswap V3 pool\n    /// @return The tick that the pool was in at the start of the current block\n    function getBlockStartingTickAndLiquidity(address pool) internal view returns (int24, uint128) {\n        (, int24 tick, uint16 observationIndex, uint16 observationCardinality, , , ) = IUniswapV3Pool(pool).slot0();\n\n        // 2 observations are needed to reliably calculate the block starting tick\n        require(observationCardinality > 1, 'NEO');\n\n        // If the latest observation occurred in the past, then no tick-changing trades have happened in this block\n        // therefore the tick in `slot0` is the same as at the beginning of the current block.\n        // We don't need to check if this observation is initialized - it is guaranteed to be.\n        (uint32 observationTimestamp, int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128, ) =\n            IUniswapV3Pool(pool).observations(observationIndex);\n        if (observationTimestamp != uint32(block.timestamp)) {\n            return (tick, IUniswapV3Pool(pool).liquidity());\n        }\n\n        uint256 prevIndex = (uint256(observationIndex) + observationCardinality - 1) % observationCardinality;\n        (\n            uint32 prevObservationTimestamp,\n            int56 prevTickCumulative,\n            uint160 prevSecondsPerLiquidityCumulativeX128,\n            bool prevInitialized\n        ) = IUniswapV3Pool(pool).observations(prevIndex);\n\n        require(prevInitialized, 'ONI');\n\n        uint32 delta = observationTimestamp - prevObservationTimestamp;\n        tick = int24((tickCumulative - prevTickCumulative) / int56(int32(delta)));\n        uint128 liquidity =\n            uint128(\n                (uint192(delta) * type(uint160).max) /\n                    (uint192(secondsPerLiquidityCumulativeX128 - prevSecondsPerLiquidityCumulativeX128) << 32)\n            );\n        return (tick, liquidity);\n    }\n\n    /// @notice Information for calculating a weighted arithmetic mean tick\n    struct WeightedTickData {\n        int24 tick;\n        uint128 weight;\n    }\n\n    /// @notice Given an array of ticks and weights, calculates the weighted arithmetic mean tick\n    /// @param weightedTickData An array of ticks and weights\n    /// @return weightedArithmeticMeanTick The weighted arithmetic mean tick\n    /// @dev Each entry of `weightedTickData` should represents ticks from pools with the same underlying pool tokens. If they do not,\n    /// extreme care must be taken to ensure that ticks are comparable (including decimal differences).\n    /// @dev Note that the weighted arithmetic mean tick corresponds to the weighted geometric mean price.\n    function getWeightedArithmeticMeanTick(WeightedTickData[] memory weightedTickData)\n        internal\n        pure\n        returns (int24 weightedArithmeticMeanTick)\n    {\n        // Accumulates the sum of products between each tick and its weight\n        int256 numerator;\n\n        // Accumulates the sum of the weights\n        uint256 denominator;\n\n        // Products fit in 152 bits, so it would take an array of length ~2**104 to overflow this logic\n        for (uint256 i; i < weightedTickData.length; i++) {\n            numerator += weightedTickData[i].tick * int256(int128(weightedTickData[i].weight));\n            denominator += weightedTickData[i].weight;\n        }\n\n        weightedArithmeticMeanTick = int24(numerator / int256(denominator));\n        // Always round to negative infinity\n        if (numerator < 0 && (numerator % int256(denominator) != 0)) weightedArithmeticMeanTick--;\n    }\n\n    /// @notice Returns the \"synthetic\" tick which represents the price of the first entry in `tokens` in terms of the last\n    /// @dev Useful for calculating relative prices along routes.\n    /// @dev There must be one tick for each pairwise set of tokens.\n    /// @param tokens The token contract addresses\n    /// @param ticks The ticks, representing the price of each token pair in `tokens`\n    /// @return syntheticTick The synthetic tick, representing the relative price of the outermost tokens in `tokens`\n    function getChainedPrice(address[] memory tokens, int24[] memory ticks)\n        internal\n        pure\n        returns (int256 syntheticTick)\n    {\n        require(tokens.length - 1 == ticks.length, 'DL');\n        for (uint256 i = 1; i <= ticks.length; i++) {\n            // check the tokens for address sort order, then accumulate the\n            // ticks into the running synthetic tick, ensuring that intermediate tokens \"cancel out\"\n            tokens[i - 1] < tokens[i] ? syntheticTick += ticks[i - 1] : syntheticTick -= ticks[i - 1];\n        }\n    }\n}"
    },
    "contracts/dependencies/uniswap/contracts/v3/pool/IUniswapV3PoolActions.sol": {
      "content": "pragma solidity >=0.6.11;\n\n/// @title Permissionless pool actions\n/// @notice Contains pool methods that can be called by anyone\ninterface IUniswapV3PoolActions {\n    /// @notice Sets the initial price for the pool\n    /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\n    /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\n    function initialize(uint160 sqrtPriceX96) external;\n\n    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\n    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\n    /// on tickLower, tickUpper, the amount of liquidity, and the current price.\n    /// @param recipient The address for which the liquidity will be created\n    /// @param tickLower The lower tick of the position in which to add liquidity\n    /// @param tickUpper The upper tick of the position in which to add liquidity\n    /// @param amount The amount of liquidity to mint\n    /// @param data Any data that should be passed through to the callback\n    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    function mint(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Collects tokens owed to a position\n    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\n    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\n    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\n    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\n    /// @param recipient The address which should receive the fees collected\n    /// @param tickLower The lower tick of the position for which to collect fees\n    /// @param tickUpper The upper tick of the position for which to collect fees\n    /// @param amount0Requested How much token0 should be withdrawn from the fees owed\n    /// @param amount1Requested How much token1 should be withdrawn from the fees owed\n    /// @return amount0 The amount of fees collected in token0\n    /// @return amount1 The amount of fees collected in token1\n    function collect(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n\n    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\n    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\n    /// @dev Fees must be collected separately via a call to #collect\n    /// @param tickLower The lower tick of the position for which to burn liquidity\n    /// @param tickUpper The upper tick of the position for which to burn liquidity\n    /// @param amount How much liquidity to burn\n    /// @return amount0 The amount of token0 sent to the recipient\n    /// @return amount1 The amount of token1 sent to the recipient\n    function burn(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Swap token0 for token1, or token1 for token0\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\n    /// @param recipient The address to receive the output of the swap\n    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\n    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\n    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\n    /// @param data Any data to be passed through to the callback\n    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n\n    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\n    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\n    /// with 0 amount{0,1} and sending the donation amount(s) from the callback\n    /// @param recipient The address which will receive the token0 and token1 amounts\n    /// @param amount0 The amount of token0 to send\n    /// @param amount1 The amount of token1 to send\n    /// @param data Any data to be passed through to the callback\n    function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n\n    /// @notice Increase the maximum number of price and liquidity observations that this pool will store\n    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\n    /// the input observationCardinalityNext.\n    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}"
    },
    "contracts/dependencies/uniswap/contracts/v3/pool/IUniswapV3PoolDerivedState.sol": {
      "content": "pragma solidity >=0.6.11;\n\n/// @title Pool state that is not stored\n/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\n/// blockchain. The functions here may have variable gas costs.\ninterface IUniswapV3PoolDerivedState {\n    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\n    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\n    /// you must call it with secondsAgos = [3600, 0].\n    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\n    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\n    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\n    /// timestamp\n    function observe(uint32[] calldata secondsAgos)\n        external\n        view\n        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n\n    /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\n    /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\n    /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\n    /// snapshot is taken and the second snapshot is taken.\n    /// @param tickLower The lower tick of the range\n    /// @param tickUpper The upper tick of the range\n    /// @return tickCumulativeInside The snapshot of the tick accumulator for the range\n    /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\n    /// @return secondsInside The snapshot of seconds per liquidity for the range\n    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\n        external\n        view\n        returns (\n            int56 tickCumulativeInside,\n            uint160 secondsPerLiquidityInsideX128,\n            uint32 secondsInside\n        );\n}"
    },
    "contracts/dependencies/uniswap/contracts/v3/pool/IUniswapV3PoolEvents.sol": {
      "content": "pragma solidity >=0.6.11;\n\n/// @title Events emitted by a pool\n/// @notice Contains all events emitted by the pool\ninterface IUniswapV3PoolEvents {\n    /// @notice Emitted exactly once by a pool when #initialize is first called on the pool\n    /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\n    /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96\n    /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\n    event Initialize(uint160 sqrtPriceX96, int24 tick);\n\n    /// @notice Emitted when liquidity is minted for a given position\n    /// @param sender The address that minted the liquidity\n    /// @param owner The owner of the position and recipient of any minted liquidity\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity minted to the position range\n    /// @param amount0 How much token0 was required for the minted liquidity\n    /// @param amount1 How much token1 was required for the minted liquidity\n    event Mint(\n        address sender,\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted when fees are collected by the owner of a position\n    /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\n    /// @param owner The owner of the position for which fees are collected\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount0 The amount of token0 fees collected\n    /// @param amount1 The amount of token1 fees collected\n    event Collect(\n        address indexed owner,\n        address recipient,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount0,\n        uint128 amount1\n    );\n\n    /// @notice Emitted when a position's liquidity is removed\n    /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\n    /// @param owner The owner of the position for which liquidity is removed\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity to remove\n    /// @param amount0 The amount of token0 withdrawn\n    /// @param amount1 The amount of token1 withdrawn\n    event Burn(\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted by the pool for any swaps between token0 and token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the output of the swap\n    /// @param amount0 The delta of the token0 balance of the pool\n    /// @param amount1 The delta of the token1 balance of the pool\n    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n    /// @param liquidity The liquidity of the pool after the swap\n    /// @param tick The log base 1.0001 of price of the pool after the swap\n    event Swap(\n        address indexed sender,\n        address indexed recipient,\n        int256 amount0,\n        int256 amount1,\n        uint160 sqrtPriceX96,\n        uint128 liquidity,\n        int24 tick\n    );\n\n    /// @notice Emitted by the pool for any flashes of token0/token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the tokens from flash\n    /// @param amount0 The amount of token0 that was flashed\n    /// @param amount1 The amount of token1 that was flashed\n    /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\n    /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\n    event Flash(\n        address indexed sender,\n        address indexed recipient,\n        uint256 amount0,\n        uint256 amount1,\n        uint256 paid0,\n        uint256 paid1\n    );\n\n    /// @notice Emitted by the pool for increases to the number of observations that can be stored\n    /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\n    /// just before a mint/swap/burn.\n    /// @param observationCardinalityNextOld The previous value of the next observation cardinality\n    /// @param observationCardinalityNextNew The updated value of the next observation cardinality\n    event IncreaseObservationCardinalityNext(\n        uint16 observationCardinalityNextOld,\n        uint16 observationCardinalityNextNew\n    );\n\n    /// @notice Emitted when the protocol fee is changed by the pool\n    /// @param feeProtocol0Old The previous value of the token0 protocol fee\n    /// @param feeProtocol1Old The previous value of the token1 protocol fee\n    /// @param feeProtocol0New The updated value of the token0 protocol fee\n    /// @param feeProtocol1New The updated value of the token1 protocol fee\n    event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);\n\n    /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner\n    /// @param sender The address that collects the protocol fees\n    /// @param recipient The address that receives the collected protocol fees\n    /// @param amount0 The amount of token0 protocol fees that is withdrawn\n    /// @param amount0 The amount of token1 protocol fees that is withdrawn\n    event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);\n}"
    },
    "contracts/dependencies/uniswap/contracts/v3/pool/IUniswapV3PoolImmutables.sol": {
      "content": "pragma solidity >=0.6.11;\n\n/// @title Pool state that never changes\n/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\ninterface IUniswapV3PoolImmutables {\n    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\n    /// @return The contract address\n    function factory() external view returns (address);\n\n    /// @notice The first of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token0() external view returns (address);\n\n    /// @notice The second of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token1() external view returns (address);\n\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n    /// @return The fee\n    function fee() external view returns (uint24);\n\n    /// @notice The pool tick spacing\n    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\n    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\n    /// This value is an int24 to avoid casting even though it is always positive.\n    /// @return The tick spacing\n    function tickSpacing() external view returns (int24);\n\n    /// @notice The maximum amount of position liquidity that can use any tick in the range\n    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\n    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\n    /// @return The max amount of liquidity per tick\n    function maxLiquidityPerTick() external view returns (uint128);\n}"
    },
    "contracts/dependencies/uniswap/contracts/v3/pool/IUniswapV3PoolOwnerActions.sol": {
      "content": "pragma solidity >=0.6.11;\n\n/// @title Permissioned pool actions\n/// @notice Contains pool methods that may only be called by the factory owner\ninterface IUniswapV3PoolOwnerActions {\n    /// @notice Set the denominator of the protocol's % share of the fees\n    /// @param feeProtocol0 new protocol fee for token0 of the pool\n    /// @param feeProtocol1 new protocol fee for token1 of the pool\n    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;\n\n    /// @notice Collect the protocol fee accrued to the pool\n    /// @param recipient The address to which collected protocol fees should be sent\n    /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1\n    /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0\n    /// @return amount0 The protocol fee collected in token0\n    /// @return amount1 The protocol fee collected in token1\n    function collectProtocol(\n        address recipient,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n}"
    },
    "contracts/dependencies/uniswap/contracts/v3/pool/IUniswapV3PoolState.sol": {
      "content": "pragma solidity >=0.6.11;\n\n/// @title Pool state that can change\n/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\n/// per transaction\ninterface IUniswapV3PoolState {\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\n    /// when accessed externally.\n    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\n    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\n    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\n    /// boundary.\n    /// observationIndex The index of the last oracle observation that was written,\n    /// observationCardinality The current maximum number of observations stored in the pool,\n    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\n    /// feeProtocol The protocol fee for both tokens of the pool.\n    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\n    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\n    /// unlocked Whether the pool is currently locked to reentrancy\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n\n    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal0X128() external view returns (uint256);\n\n    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal1X128() external view returns (uint256);\n\n    /// @notice The amounts of token0 and token1 that are owed to the protocol\n    /// @dev Protocol fees will never exceed uint128 max in either token\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\n\n    /// @notice The currently in range liquidity available to the pool\n    /// @dev This value has no relationship to the total liquidity across all ticks\n    function liquidity() external view returns (uint128);\n\n    /// @notice Look up information about a specific tick in the pool\n    /// @param tick The tick to look up\n    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\n    /// tick upper,\n    /// liquidityNet how much liquidity changes when the pool price crosses the tick,\n    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\n    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\n    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\n    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\n    /// secondsOutside the seconds spent on the other side of the tick from the current tick,\n    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\n    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\n    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\n    /// a specific position.\n    function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n\n    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\n\n    /// @notice Returns the information about a position by the position's key\n    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\n    /// @return _liquidity The amount of liquidity in the position,\n    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\n    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\n    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\n    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\n    function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 _liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n\n    /// @notice Returns data about a specific observation index\n    /// @param index The element of the observations array to fetch\n    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\n    /// ago, rather than at a specific index in the array.\n    /// @return blockTimestamp The timestamp of the observation,\n    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\n    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\n    /// Returns initialized whether the observation has been initialized and the values are safe to use\n    function observations(uint256 index)\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );\n}"
    },
    "contracts/deployments/ATokensAndRatesHelper.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {LendingPool} from '../protocol/lendingpool/LendingPool.sol';\nimport {\n  LendingPoolAddressesProvider\n} from '../protocol/configuration/LendingPoolAddressesProvider.sol';\nimport {LendingPoolConfigurator} from '../protocol/lendingpool/LendingPoolConfigurator.sol';\nimport {AToken} from '../protocol/tokenization/AToken.sol';\nimport {\n  DefaultReserveInterestRateStrategy\n} from '../protocol/lendingpool/DefaultReserveInterestRateStrategy.sol';\nimport {Ownable} from '../dependencies/openzeppelin/contracts/Ownable.sol';\n\ncontract ATokensAndRatesHelper is Ownable {\n  address payable private pool;\n  address private addressesProvider;\n  address private poolConfigurator;\n  event deployedContracts(address aToken, address strategy);\n\n  struct InitDeploymentInput {\n    address asset;\n    uint256[6] rates;\n  }\n\n  struct ConfigureReserveInput {\n    address asset;\n    uint256 baseLTV;\n    uint256 liquidationThreshold;\n    uint256 liquidationBonus;\n    uint256 reserveFactor;\n    bool stableBorrowingEnabled;\n    bool borrowingEnabled;\n  }\n\n  constructor(\n    address payable _pool,\n    address _addressesProvider,\n    address _poolConfigurator\n  ) {\n    pool = _pool;\n    addressesProvider = _addressesProvider;\n    poolConfigurator = _poolConfigurator;\n  }\n\n  function initDeployment(InitDeploymentInput[] calldata inputParams) external onlyOwner {\n    for (uint256 i = 0; i < inputParams.length; i++) {\n      emit deployedContracts(\n        address(new AToken()),\n        address(\n          new DefaultReserveInterestRateStrategy(\n            LendingPoolAddressesProvider(addressesProvider),\n            inputParams[i].rates[0],\n            inputParams[i].rates[1],\n            inputParams[i].rates[2],\n            inputParams[i].rates[3],\n            inputParams[i].rates[4],\n            inputParams[i].rates[5]\n          )\n        )\n      );\n    }\n  }\n\n  function configureReserves(ConfigureReserveInput[] calldata inputParams) external onlyOwner {\n    LendingPoolConfigurator configurator = LendingPoolConfigurator(poolConfigurator);\n    for (uint256 i = 0; i < inputParams.length; i++) {\n      configurator.configureReserveAsCollateral(\n        inputParams[i].asset,\n        inputParams[i].baseLTV,\n        inputParams[i].liquidationThreshold,\n        inputParams[i].liquidationBonus\n      );\n\n      if (inputParams[i].borrowingEnabled) {\n        configurator.enableBorrowingOnReserve(\n          inputParams[i].asset,\n          inputParams[i].stableBorrowingEnabled\n        );\n      }\n      configurator.setReserveFactor(inputParams[i].asset, inputParams[i].reserveFactor);\n    }\n  }\n}\n"
    },
    "contracts/deployments/StableAndVariableTokensHelper.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {StableDebtToken} from '../protocol/tokenization/StableDebtToken.sol';\nimport {VariableDebtToken} from '../protocol/tokenization/VariableDebtToken.sol';\nimport {LendingRateOracle} from '../mocks/oracle/LendingRateOracle.sol';\nimport {Ownable} from '../dependencies/openzeppelin/contracts/Ownable.sol';\n\ncontract StableAndVariableTokensHelper is Ownable {\n  address payable private pool;\n  address private addressesProvider;\n  event deployedContracts(address stableToken, address variableToken);\n\n  constructor(address payable _pool, address _addressesProvider) {\n    pool = _pool;\n    addressesProvider = _addressesProvider;\n  }\n\n  function initDeployment(address[] calldata tokens, string[] calldata symbols) external onlyOwner {\n    require(tokens.length == symbols.length, 'Arrays not same length');\n    require(pool != address(0), 'Pool can not be zero address');\n    for (uint256 i = 0; i < tokens.length; i++) {\n      emit deployedContracts(address(new StableDebtToken()), address(new VariableDebtToken()));\n    }\n  }\n\n  function setOracleBorrowRates(\n    address[] calldata assets,\n    uint256[] calldata rates,\n    address oracle\n  ) external onlyOwner {\n    require(assets.length == rates.length, 'Arrays not same length');\n\n    for (uint256 i = 0; i < assets.length; i++) {\n      // LendingRateOracle owner must be this contract\n      LendingRateOracle(oracle).setMarketBorrowRate(assets[i], rates[i]);\n    }\n  }\n\n  function setOracleOwnership(address oracle, address admin) external onlyOwner {\n    require(admin != address(0), 'owner can not be zero');\n    require(LendingRateOracle(oracle).owner() == address(this), 'helper is not owner');\n    LendingRateOracle(oracle).transferOwnership(admin);\n  }\n}\n"
    },
    "contracts/eligibility/EligibilityDataProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../interfaces/ILendingPool.sol\";\nimport \"../interfaces/IMultiFeeDistribution.sol\";\nimport \"../interfaces/IChefIncentivesController.sol\";\nimport \"../interfaces/IPriceProvider.sol\";\nimport \"../interfaces/IMiddleFeeDistribution.sol\";\nimport \"../interfaces/LockedBalance.sol\";\nimport \"../interfaces/uniswap/IUniswapV2Router02.sol\";\nimport \"../interfaces/uniswap/IUniswapV2Factory.sol\";\nimport \"../interfaces/uniswap/IUniswapV2Pair.sol\";\nimport \"../interfaces/IChainlinkAggregator.sol\";\n\nimport \"../dependencies/openzeppelin/contracts/SafeMath.sol\";\nimport \"../dependencies/openzeppelin/contracts/Ownable.sol\";\n\n/// @title Eligible Deposit Provider\n/// @author Radiant Labs\n/// @dev All function calls are currently implemented without side effects\ncontract EligibilityDataProvider is Ownable {\n    using SafeMath for uint256;\n\n    /********************** Common Info ***********************/\n\n    /// @notice RATIO BASE equal to 100%\n    uint256 public constant RATIO_DIVISOR = 10000;\n\n    /// @notice Address of Lending Pool\n    ILendingPool public lendingPool;\n\n    /// @notice Address of CIC\n    IChefIncentivesController public chef;\n\n    /// @notice Address of Middle fee distribution\n    IMiddleFeeDistribution public middleFeeDistribution;\n\n    /// @notice RDNT + LP price provider\n    IPriceProvider public priceProvider;\n\n    /// @notice Required ratio of TVL to get reward; in bips\n    uint256 public requiredDepositRatio;\n\n    /// @notice RDNT-ETH LP token\n    address public lpToken;\n\n    /********************** Eligible info ***********************/\n\n    /// @notice Last eligible status of the user\n    mapping(address => bool) public lastEligibleStatus;\n\n    /// @notice Disqualified time of the user\n    mapping(address => uint256) public disqualifiedTime;\n\n    // Elgible deposits per rToken\n    mapping(address => uint256) private eligibleDeposits;\n\n    /// @notice User's deposits per rToken; rToken => user => amount\n    mapping(address => mapping(address => uint256)) public userDeposits;\n\n    /********************** Events ***********************/\n\n     /// @notice Emitted when CIC is set\n    event ChefIncentivesControllerUpdated(IChefIncentivesController _chef);\n\n    /// @notice Emitted when LP token is set\n    event LPTokenUpdated(address _lpToken);\n\n    /// @notice Emitted when required TVL ratio is updated\n    event RequiredDepositRatioUpdated(uint256 requiredDepositRatio);\n\n    /// @notice Emitted when DQ time is set\n    event DqTimeUpdated(address _user, uint256 _time);\n\n    /// @notice Emitted when a new token is added\n    event AddToken(address indexed token);\n\n    /**\n     * @notice Constructor\n     * @param _lendingPool Address of lending pool.\n     * @param _middleFeeDistribution MiddleFeeDistribution address.\n     * @param _priceProvider PriceProvider address.\n     */\n    constructor(\n        ILendingPool _lendingPool,\n        IMiddleFeeDistribution _middleFeeDistribution,\n        IPriceProvider _priceProvider\n    ) Ownable() {\n        require(address(_lendingPool) != address(0), \"Not a valid address\");\n        require(address(_middleFeeDistribution) != (address(0)), \"Not a valid address\");\n        require(address(_priceProvider) != (address(0)), \"Not a valid address\");\n\n        lendingPool = _lendingPool;\n        middleFeeDistribution = _middleFeeDistribution;\n        priceProvider = _priceProvider;\n        requiredDepositRatio = 500;\n    }\n\n    /********************** Setters ***********************/\n\n    /**\n     * @notice Set CIC\n     * @param _chef address.\n     */\n    function setChefIncentivesController(IChefIncentivesController _chef)\n        external\n        onlyOwner\n    {\n        chef = _chef;\n        emit ChefIncentivesControllerUpdated(_chef);\n    }\n\n    /**\n     * @notice Set LP token\n     */\n    function setLPToken(address _lpToken) external onlyOwner {\n        require(lpToken == address(0), \"LP token already set\");\n        lpToken = _lpToken;\n\n        emit LPTokenUpdated(_lpToken);\n    }\n\n    /**\n     * @notice Sets required tvl ratio. Can only be called by the owner.\n     * @param _requiredDepositRatio Ratio in bips.\n     */\n    function setRequiredDepositRatio(uint256 _requiredDepositRatio) external onlyOwner {\n        require(_requiredDepositRatio <= RATIO_DIVISOR, \"Invalid ratio\");\n        requiredDepositRatio = _requiredDepositRatio;\n\n        emit RequiredDepositRatioUpdated(_requiredDepositRatio);\n    }\n\n    /**\n     * @notice Sets DQ time of the user\n     * @dev Only callable by CIC\n     * @param _user's address\n     * @param _time for DQ\n     */\n    function setDqTime(address _user, uint256 _time) external {\n        require(msg.sender == address(chef), \"Only CIC\");\n        disqualifiedTime[_user] = _time;\n\n        emit DqTimeUpdated(_user, _time);\n    }\n\n    /********************** View functions ***********************/\n\n    /**\n     * @notice Returns locked RDNT and LP token value in eth\n     * @param user's address\n     */\n    function lockedUsdValue(address user) public view returns (uint256) {\n        IMultiFeeDistribution lpFeeDistribution = IMultiFeeDistribution(\n            middleFeeDistribution.getLPFeeDistributionAddress()\n        );\n        IMultiFeeDistribution multiFeeDistribution = IMultiFeeDistribution(\n            middleFeeDistribution.getMultiFeeDistributionAddress()\n        );\n        (, , uint256 lockedLP, ,) = lpFeeDistribution.lockedBalances(user);\n        (, , uint256 lockedRdnt, ,) = multiFeeDistribution.lockedBalances(user);\n        return _lockedUsdValue(lockedLP, lockedRdnt);\n    }\n\n    /**\n     * @notice Returns USD value required to be locked\n     * @param user's address\n     * @return required USD value.\n     */\n    function requiredUsdValue(address user)\n        public\n        view\n        returns (uint256 required)\n    {\n        (uint256 totalCollateralUSD, , , , , ) = lendingPool.getUserAccountData(\n            user\n        );\n        required = totalCollateralUSD.mul(requiredDepositRatio).div(RATIO_DIVISOR);\n    }\n\n    /**\n     * @notice Is user DQed due to lock expire or price update\n     * @param _user's address\n     */\n    function isMarketDisqualified(address _user)\n        public\n        view\n        returns (bool)\n    {\n        return \n            requiredUsdValue(_user) > 0 &&\n            !isEligibleForRewards(_user) && \n            lastEligibleTime(_user) > block.timestamp;\n    }\n\n    /**\n     * @notice Returns if the user is eligible to receive rewards\n     * @param _user's address\n     */\n    function isEligibleForRewards(address _user)\n        public\n        view\n        returns (bool isEligible)\n    {\n        uint256 lockedValue = lockedUsdValue(_user);\n        uint256 requiredValue = requiredUsdValue(_user);\n        return requiredValue != 0 && lockedValue >= requiredValue;\n    }\n\n    /**\n     * @notice Returns DQ time of the user\n     * @param _user's address\n     */\n    function getDqTime(address _user) public view returns (uint256) {\n        return disqualifiedTime[_user];\n    }\n\n    /**\n     * @notice Returns last eligible time of the user\n     * @dev If user is still eligible, it will return future time\n     *  CAUTION: this function only works perfect when the array\n     *  is ordered by lock time. This is assured when _stake happens.\n     * @param user's address\n     */\n    function lastEligibleTime(address user)\n        public\n        view\n        returns (uint256 lastEligibleTimestamp)\n    {\n        uint256 requiredValue = requiredUsdValue(user);\n\n        IMultiFeeDistribution lpFeeDistribution = IMultiFeeDistribution(\n            middleFeeDistribution.getLPFeeDistributionAddress()\n        );\n        IMultiFeeDistribution multiFeeDistribution = IMultiFeeDistribution(\n            middleFeeDistribution.getMultiFeeDistributionAddress()\n        );\n        LockedBalance[] memory lpLockData = lpFeeDistribution.lockInfo(user);\n        LockedBalance[] memory rndtLockData = multiFeeDistribution.lockInfo(\n            user\n        );\n\n        uint256 lockedLP;\n        uint256 lockedRdnt;\n        uint256 i = lpLockData.length;\n        uint256 j = rndtLockData.length;\n        while (true) {\n            if (i == 0 && j == 0) {\n                // return 0;\n                break;\n            }\n            if (i == 0) {\n                j = j - 1;\n                lastEligibleTimestamp = rndtLockData[j].unlockTime;\n                lockedRdnt = lockedRdnt + rndtLockData[j].amount;\n            } else if (j == 0) {\n                i = i - 1;\n                lastEligibleTimestamp = lpLockData[i].unlockTime;\n                lockedLP = lockedLP + lpLockData[i].amount;\n            } else if (\n                lpLockData[i - 1].unlockTime < rndtLockData[j - 1].unlockTime\n            ) {\n                j = j - 1;\n                lastEligibleTimestamp = rndtLockData[j].unlockTime;\n                lockedRdnt = lockedRdnt + rndtLockData[j].amount;\n            } else {\n                i = i - 1;\n                lastEligibleTimestamp = lpLockData[i].unlockTime;\n                lockedLP = lockedLP + lpLockData[i].amount;\n            }\n\n            if (_lockedUsdValue(lockedLP, lockedRdnt) >= requiredValue) {\n                break;\n            }\n        }\n    }\n\n    /********************** Operate functions ***********************/\n\n    /**\n     * @notice Update token price\n     */\n    function updatePrice() public {\n        priceProvider.update();\n    }\n\n    /**\n     * @notice Refresh token amount for eligibility\n     * @param user's address\n     */\n    function refresh(address user) external {\n        require(msg.sender == address(chef), \"Can only be called by CIC\");\n        assert(user != address(0));\n\n        updatePrice();\n\n        bool currentEligble = isEligibleForRewards(user);\n        if (currentEligble && disqualifiedTime[user] != 0) {\n            disqualifiedTime[user] = 0;\n        }\n        lastEligibleStatus[user] = currentEligble;\n    }\n\n    /********************** Internal functions ***********************/\n\n    /**\n     * @notice Returns locked RDNT and LP token value in eth\n     * @param lockedLP is locked lp amount\n     * @param lockedRdnt is locked RDNT amount\n     */\n    function _lockedUsdValue(uint256 lockedLP, uint256 lockedRdnt)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 rdntPrice = priceProvider.getTokenPriceUsd();\n        uint256 lpPrice = priceProvider.getLpTokenPriceUsd();\n\n        uint256 userRdntValueUsd = lockedRdnt.mul(rdntPrice).div(10**18);\n        uint256 userLpValueUsd = lockedLP.mul(lpPrice).div(10**18);\n\n        uint256 usdLockedVal = userRdntValueUsd.add(userLpValueUsd);\n        return usdLockedVal;\n    }\n}\n"
    },
    "contracts/flashloan/base/FlashLoanReceiverBase.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\nimport {SafeMath} from '../../dependencies/openzeppelin/contracts/SafeMath.sol';\nimport {IERC20} from '../../dependencies/openzeppelin/contracts/IERC20.sol';\nimport {SafeERC20} from '../../dependencies/openzeppelin/contracts/SafeERC20.sol';\nimport {IFlashLoanReceiver} from '../interfaces/IFlashLoanReceiver.sol';\nimport {ILendingPoolAddressesProvider} from '../../interfaces/ILendingPoolAddressesProvider.sol';\nimport {ILendingPool} from '../../interfaces/ILendingPool.sol';\n\nabstract contract FlashLoanReceiverBase is IFlashLoanReceiver {\n  using SafeERC20 for IERC20;\n  using SafeMath for uint256;\n\n  ILendingPoolAddressesProvider public immutable override ADDRESSES_PROVIDER;\n  ILendingPool public immutable override LENDING_POOL;\n\n  constructor(ILendingPoolAddressesProvider provider) {\n    ADDRESSES_PROVIDER = provider;\n    LENDING_POOL = ILendingPool(provider.getLendingPool());\n  }\n}\n"
    },
    "contracts/flashloan/interfaces/IFlashLoanReceiver.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\nimport {ILendingPoolAddressesProvider} from '../../interfaces/ILendingPoolAddressesProvider.sol';\nimport {ILendingPool} from '../../interfaces/ILendingPool.sol';\n\n/**\n * @title IFlashLoanReceiver interface\n * @notice Interface for the Aave fee IFlashLoanReceiver.\n * @author Aave\n * @dev implement this interface to develop a flashloan-compatible flashLoanReceiver contract\n **/\ninterface IFlashLoanReceiver {\n  function executeOperation(\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata premiums,\n    address initiator,\n    bytes calldata params\n  ) external returns (bool);\n\n  function ADDRESSES_PROVIDER() external view returns (ILendingPoolAddressesProvider);\n\n  function LENDING_POOL() external view returns (ILendingPool);\n}\n"
    },
    "contracts/interfaces/AggregatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface AggregatorInterface {\n  function latestAnswer() external view returns (int256);\n\n  function latestTimestamp() external view returns (uint256);\n\n  function latestRound() external view returns (uint256);\n\n  function getAnswer(uint256 roundId) external view returns (int256);\n\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\n\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\n"
    },
    "contracts/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "contracts/interfaces/balancer/IWeightedPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.7.0;\npragma abicoder v2;\nimport {IERC20} from \"../../dependencies/openzeppelin/contracts/IERC20.sol\";\n\ninterface IBasePool is IERC20 {\n\n    function getSwapFeePercentage() external view returns (uint256);\n\n    function setSwapFeePercentage(uint256 swapFeePercentage) external;\n\n    function setAssetManagerPoolConfig(IERC20 token, IAssetManager.PoolConfig memory poolConfig) external;\n\n    function setPaused(bool paused) external;\n\n    function getVault() external view returns (IVault);\n\n    function getPoolId() external view returns (bytes32);\n\n    function getOwner() external view returns (address);\n}\n\ninterface IWeightedPoolFactory {\n  function create ( string memory name,\n        string memory symbol,\n        IERC20[] memory tokens,\n        uint256[] memory weights,\n        uint256 swapFeePercentage,\n        address owner ) external returns ( address );\n}\n\ninterface IWeightedPool is IBasePool {\n    function getSwapEnabled() external view returns (bool);\n\n    function getNormalizedWeights() external view returns (uint256[] memory);\n\n    function getGradualWeightUpdateParams()\n        external\n        view\n        returns (\n            uint256 startTime,\n            uint256 endTime,\n            uint256[] memory endWeights\n        );\n\n    function setSwapEnabled(bool swapEnabled) external;\n\n    function updateWeightsGradually(\n        uint256 startTime,\n        uint256 endTime,\n        uint256[] memory endWeights\n    ) external;\n\n    function withdrawCollectedManagementFees(address recipient) external;   \n\n    enum JoinKind { INIT, EXACT_TOKENS_IN_FOR_BPT_OUT, TOKEN_IN_FOR_EXACT_BPT_OUT }\n    enum ExitKind { EXACT_BPT_IN_FOR_ONE_TOKEN_OUT, EXACT_BPT_IN_FOR_TOKENS_OUT, BPT_IN_FOR_EXACT_TOKENS_OUT }\n}\n\ninterface IAssetManager {\n    struct PoolConfig {\n        uint64 targetPercentage;\n        uint64 criticalPercentage;\n        uint64 feePercentage;\n    }\n\n    function setPoolConfig(bytes32 poolId, PoolConfig calldata config) external;\n}\n\ninterface IAsset {\n\n}\n\ninterface IVault {\n    function hasApprovedRelayer(address user, address relayer) external view returns (bool);\n    function setRelayerApproval(\n        address sender,\n        address relayer,\n        bool approved\n    ) external;\n\n    event RelayerApprovalChanged(address indexed relayer, address indexed sender, bool approved);\n    function getInternalBalance(address user, IERC20[] memory tokens) external view returns (uint256[] memory);\n    function manageUserBalance(UserBalanceOp[] memory ops) external payable;\n    struct UserBalanceOp {\n        UserBalanceOpKind kind;\n        IAsset asset;\n        uint256 amount;\n        address sender;\n        address payable recipient;\n    }\n\n    enum UserBalanceOpKind { DEPOSIT_INTERNAL, WITHDRAW_INTERNAL, TRANSFER_INTERNAL, TRANSFER_EXTERNAL }\n    event InternalBalanceChanged(address indexed user, IERC20 indexed token, int256 delta);\n    event ExternalBalanceTransfer(IERC20 indexed token, address indexed sender, address recipient, uint256 amount);\n\n    enum PoolSpecialization { GENERAL, MINIMAL_SWAP_INFO, TWO_TOKEN }\n    function registerPool(PoolSpecialization specialization) external returns (bytes32);\n    event PoolRegistered(bytes32 indexed poolId, address indexed poolAddress, PoolSpecialization specialization);\n    function getPool(bytes32 poolId) external view returns (address, PoolSpecialization);\n    function registerTokens(\n        bytes32 poolId,\n        IERC20[] memory tokens,\n        address[] memory assetManagers\n    ) external;\n    event TokensRegistered(bytes32 indexed poolId, IERC20[] tokens, address[] assetManagers);\n    function deregisterTokens(bytes32 poolId, IERC20[] memory tokens) external;\n    event TokensDeregistered(bytes32 indexed poolId, IERC20[] tokens);\n    function getPoolTokenInfo(bytes32 poolId, IERC20 token)\n        external\n        view\n        returns (\n            uint256 cash,\n            uint256 managed,\n            uint256 lastChangeBlock,\n            address assetManager\n        );\n\n    function getPoolTokens(bytes32 poolId)\n        external\n        view\n        returns (\n            IERC20[] memory tokens,\n            uint256[] memory balances,\n            uint256 lastChangeBlock\n        );\n\n    function joinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        JoinPoolRequest memory request\n    ) external payable;\n\n    struct JoinPoolRequest {\n        IAsset[] assets;\n        uint256[] maxAmountsIn;\n        bytes userData;\n        bool fromInternalBalance;\n    }\n    function exitPool(\n        bytes32 poolId,\n        address sender,\n        address payable recipient,\n        ExitPoolRequest memory request\n    ) external;\n\n    struct ExitPoolRequest {\n        IAsset[] assets;\n        uint256[] minAmountsOut;\n        bytes userData;\n        bool toInternalBalance;\n    }\n\n    event PoolBalanceChanged(\n        bytes32 indexed poolId,\n        address indexed liquidityProvider,\n        IERC20[] tokens,\n        int256[] deltas,\n        uint256[] protocolFeeAmounts\n    );\n\n    enum PoolBalanceChangeKind { JOIN, EXIT }\n\n    enum SwapKind { GIVEN_IN, GIVEN_OUT }\n    function swap(\n        SingleSwap memory singleSwap,\n        FundManagement memory funds,\n        uint256 limit,\n        uint256 deadline\n    ) external payable returns (uint256);\n\n    struct SingleSwap {\n        bytes32 poolId;\n        SwapKind kind;\n        IAsset assetIn;\n        IAsset assetOut;\n        uint256 amount;\n        bytes userData;\n    }\n    function batchSwap(\n        SwapKind kind,\n        BatchSwapStep[] memory swaps,\n        IAsset[] memory assets,\n        FundManagement memory funds,\n        int256[] memory limits,\n        uint256 deadline\n    ) external payable returns (int256[] memory);\n\n    struct BatchSwapStep {\n        bytes32 poolId;\n        uint256 assetInIndex;\n        uint256 assetOutIndex;\n        uint256 amount;\n        bytes userData;\n    }\n\n    event Swap(\n        bytes32 indexed poolId,\n        IERC20 indexed tokenIn,\n        IERC20 indexed tokenOut,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n    struct FundManagement {\n        address sender;\n        bool fromInternalBalance;\n        address payable recipient;\n        bool toInternalBalance;\n    }\n\n    function queryBatchSwap(\n        SwapKind kind,\n        BatchSwapStep[] memory swaps,\n        IAsset[] memory assets,\n        FundManagement memory funds\n    ) external returns (int256[] memory assetDeltas);\n    function managePoolBalance(PoolBalanceOp[] memory ops) external;\n\n    struct PoolBalanceOp {\n        PoolBalanceOpKind kind;\n        bytes32 poolId;\n        IERC20 token;\n        uint256 amount;\n    }\n\n    enum PoolBalanceOpKind { WITHDRAW, DEPOSIT, UPDATE }\n    event PoolBalanceManaged(\n        bytes32 indexed poolId,\n        address indexed assetManager,\n        IERC20 indexed token,\n        int256 cashDelta,\n        int256 managedDelta\n    );\n\n\n    function setPaused(bool paused) external;\n}\n"
    },
    "contracts/interfaces/IAaveIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\n\ninterface IAaveIncentivesController {\n  event RewardsAccrued(address indexed user, uint256 amount);\n\n  event RewardsClaimed(address indexed user, address indexed to, uint256 amount);\n\n  event RewardsClaimed(\n    address indexed user,\n    address indexed to,\n    address indexed claimer,\n    uint256 amount\n  );\n\n  event ClaimerSet(address indexed user, address indexed claimer);\n\n  /*\n   * @dev Returns the configuration of the distribution for a certain asset\n   * @param asset The address of the reference asset of the distribution\n   * @return The asset index, the emission per second and the last updated timestamp\n   **/\n  function getAssetData(address asset)\n    external\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    );\n\n  /**\n   * @dev Whitelists an address to claim the rewards on behalf of another address\n   * @param user The address of the user\n   * @param claimer The address of the claimer\n   */\n  function setClaimer(address user, address claimer) external;\n\n  /**\n   * @dev Returns the whitelisted claimer for a certain address (0x0 if not set)\n   * @param user The address of the user\n   * @return The claimer address\n   */\n  function getClaimer(address user) external view returns (address);\n\n  /**\n   * @dev Configure assets for a certain rewards emission\n   * @param assets The assets to incentivize\n   * @param emissionsPerSecond The emission for each asset\n   */\n  function configureAssets(address[] calldata assets, uint256[] calldata emissionsPerSecond)\n    external;\n\n  /**\n   * @dev Called by the corresponding asset on any update that affects the rewards distribution\n   * @param user The address of the user\n   **/\n  function handleActionBefore(\n    address user\n  ) external;\n\n  /**\n   * @dev Called by the corresponding asset on any update that affects the rewards distribution\n   * @param user The address of the user\n   * @param userBalance The balance of the user of the asset in the lending pool\n   * @param totalSupply The total supply of the asset in the lending pool\n   **/\n  function handleActionAfter(\n    address user,\n    uint256 userBalance,\n    uint256 totalSupply\n  ) external;\n\n  /**\n   * @dev Returns the total of rewards of an user, already accrued + not yet accrued\n   * @param user The address of the user\n   * @return The rewards\n   **/\n  function getRewardsBalance(address[] calldata assets, address user)\n    external\n    view\n    returns (uint256);\n\n  /**\n   * @dev Claims reward for an user, on all the assets of the lending pool, accumulating the pending rewards\n   * @param amount Amount of rewards to claim\n   * @param to Address that will be receiving the rewards\n   * @return Rewards claimed\n   **/\n  function claimRewards(\n    address[] calldata assets,\n    uint256 amount,\n    address to\n  ) external returns (uint256);\n\n  /**\n   * @dev Claims reward for an user on behalf, on all the assets of the lending pool, accumulating the pending rewards. The caller must\n   * be whitelisted via \"allowClaimOnBehalf\" function by the RewardsAdmin role manager\n   * @param amount Amount of rewards to claim\n   * @param user Address to check and claim rewards\n   * @param to Address that will be receiving the rewards\n   * @return Rewards claimed\n   **/\n  function claimRewardsOnBehalf(\n    address[] calldata assets,\n    uint256 amount,\n    address user,\n    address to\n  ) external returns (uint256);\n\n  /**\n   * @dev returns the unclaimed rewards of the user\n   * @param user the address of the user\n   * @return the unclaimed user rewards\n   */\n  function getUserUnclaimedRewards(address user) external view returns (uint256);\n\n  /**\n   * @dev returns the unclaimed rewards of the user\n   * @param user the address of the user\n   * @param asset The asset to incentivize\n   * @return the user index for the asset\n   */\n  function getUserAssetData(address user, address asset) external view returns (uint256);\n\n  /**\n   * @dev for backward compatibility with previous implementation of the Incentives controller\n   */\n  function REWARD_TOKEN() external view returns (address);\n\n  /**\n   * @dev for backward compatibility with previous implementation of the Incentives controller\n   */\n  function PRECISION() external view returns (uint8);\n\n  /**\n   * @dev Gets the distribution end timestamp of the emissions\n   */\n  function DISTRIBUTION_END() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IAToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\nimport {IERC20} from '../dependencies/openzeppelin/contracts/IERC20.sol';\nimport {IScaledBalanceToken} from './IScaledBalanceToken.sol';\nimport {IInitializableAToken} from './IInitializableAToken.sol';\nimport {IAaveIncentivesController} from './IAaveIncentivesController.sol';\n\ninterface IAToken is IERC20, IScaledBalanceToken, IInitializableAToken {\n  /**\n   * @dev Emitted after the mint action\n   * @param from The address performing the mint\n   * @param value The amount being\n   * @param index The new liquidity index of the reserve\n   **/\n  event Mint(address indexed from, uint256 value, uint256 index);\n\n  /**\n   * @dev Mints `amount` aTokens to `user`\n   * @param user The address receiving the minted tokens\n   * @param amount The amount of tokens getting minted\n   * @param index The new liquidity index of the reserve\n   * @return `true` if the the previous balance of the user was 0\n   */\n  function mint(\n    address user,\n    uint256 amount,\n    uint256 index\n  ) external returns (bool);\n\n  /**\n   * @dev Emitted after aTokens are burned\n   * @param from The owner of the aTokens, getting them burned\n   * @param target The address that will receive the underlying\n   * @param value The amount being burned\n   * @param index The new liquidity index of the reserve\n   **/\n  event Burn(address indexed from, address indexed target, uint256 value, uint256 index);\n\n  /**\n   * @dev Emitted during the transfer action\n   * @param from The user whose tokens are being transferred\n   * @param to The recipient\n   * @param value The amount being transferred\n   * @param index The new liquidity index of the reserve\n   **/\n  event BalanceTransfer(address indexed from, address indexed to, uint256 value, uint256 index);\n\n  /**\n   * @dev Burns aTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\n   * @param user The owner of the aTokens, getting them burned\n   * @param receiverOfUnderlying The address that will receive the underlying\n   * @param amount The amount being burned\n   * @param index The new liquidity index of the reserve\n   **/\n  function burn(\n    address user,\n    address receiverOfUnderlying,\n    uint256 amount,\n    uint256 index\n  ) external;\n\n  /**\n   * @dev Mints aTokens to the reserve treasury\n   * @param amount The amount of tokens getting minted\n   * @param index The new liquidity index of the reserve\n   */\n  function mintToTreasury(uint256 amount, uint256 index) external;\n\n  /**\n   * @dev Transfers aTokens in the event of a borrow being liquidated, in case the liquidators reclaims the aToken\n   * @param from The address getting liquidated, current owner of the aTokens\n   * @param to The recipient\n   * @param value The amount of tokens getting transferred\n   **/\n  function transferOnLiquidation(\n    address from,\n    address to,\n    uint256 value\n  ) external;\n\n  /**\n   * @dev Transfers the underlying asset to `target`. Used by the LendingPool to transfer\n   * assets in borrow(), withdraw() and flashLoan()\n   * @param user The recipient of the underlying\n   * @param amount The amount getting transferred\n   * @return The amount transferred\n   **/\n  function transferUnderlyingTo(address user, uint256 amount) external returns (uint256);\n\n  /**\n   * @dev Invoked to execute actions on the aToken side after a repayment.\n   * @param user The user executing the repayment\n   * @param amount The amount getting repaid\n   **/\n  function handleRepayment(address user, uint256 amount) external;\n\n  /**\n   * @dev Returns the address of the incentives controller contract\n   **/\n  function getIncentivesController() external view returns (IAaveIncentivesController);\n\n  /**\n   * @dev Returns the address of the underlying asset of this aToken (E.g. WETH for aWETH)\n   **/\n  function UNDERLYING_ASSET_ADDRESS() external view returns (address);\n}\n"
    },
    "contracts/interfaces/IBaseOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\ninterface IBaseOracle {\n   function latestAnswer() external view returns (uint256 price);\n   function latestAnswerInEth() external view returns (uint256 price);\n   function update() external;\n   function canUpdate() external view returns (bool);\n   function consult() external view returns (uint256 price);\n}"
    },
    "contracts/interfaces/IBounty.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\ninterface IBounty {\n    function quote(address _param) external returns (uint256 bounty);\n    function claim(address _param) external returns(uint256 bounty);\n    function minDLPBalance() external view returns (uint256 minDLPBalance);\n    function onRelockUpdate(address _user, bool oldStatus, bool newStatus) external;\n}"
    },
    "contracts/interfaces/IChainlinkAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Code from https://github.com/smartcontractkit/chainlink/blob/master/evm-contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\n\npragma solidity 0.7.6;\n\nimport './AggregatorInterface.sol';\nimport './AggregatorV3Interface.sol';\n\ninterface IChainlinkAggregator is AggregatorInterface, AggregatorV3Interface {}\n"
    },
    "contracts/interfaces/IChefIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\n\ninterface IChefIncentivesController {\n\n  /**\n   * @dev Called by the corresponding asset on any update that affects the rewards distribution\n   * @param user The address of the user\n   **/\n  function handleActionBefore(\n    address user\n  ) external;\n\n  /**\n   * @dev Called by the corresponding asset on any update that affects the rewards distribution\n   * @param user The address of the user\n   * @param userBalance The balance of the user of the asset in the lending pool\n   * @param totalSupply The total supply of the asset in the lending pool\n   **/\n  function handleActionAfter(\n    address user,\n    uint256 userBalance,\n    uint256 totalSupply\n  ) external;\n\n  /**\n   * @dev Called by the locking contracts after locking or unlocking happens\n   * @param user The address of the user\n   **/\n  function beforeLockUpdate(address user) external;\n\n  /**\n    * @notice Hook for lock update.\n    * @dev Called by the locking contracts after locking or unlocking happens\n    */\n  function afterLockUpdate(address _user) external;\n\n  function addPool(address _token, uint256 _allocPoint) external;\n\n  function claim(address _user, address[] calldata _tokens) external;\n\n  function setClaimReceiver(address _user, address _receiver) external;\n  function getRegisteredTokens () external view returns (address[] memory);\n  function disqualifyUser(address _user, address _hunter) external returns (uint256 bounty);\n  function bountyForUser(address _user) external view returns (uint256 bounty);\n\n  function allPendingRewards(address _user) external view returns (uint256 pending);\n  function claimAll(address _user) external;\n\n  function claimBounty(address _user, bool _execute) external returns (uint256 bountyAmt, bool useBountyReserve);\n}\n"
    },
    "contracts/interfaces/ICreditDelegationToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\ninterface ICreditDelegationToken {\n  event BorrowAllowanceDelegated(\n    address indexed fromUser,\n    address indexed toUser,\n    address asset,\n    uint256 amount\n  );\n\n  /**\n   * @dev delegates borrowing power to a user on the specific debt token\n   * @param delegatee the address receiving the delegated borrowing power\n   * @param amount the maximum amount being delegated. Delegation will still\n   * respect the liquidation constraints (even if delegated, a delegatee cannot\n   * force a delegator HF to go below 1)\n   **/\n  function approveDelegation(address delegatee, uint256 amount) external;\n\n  /**\n   * @dev returns the borrow allowance of the user\n   * @param fromUser The user to giving allowance\n   * @param toUser The user to give allowance to\n   * @return the current allowance of toUser\n   **/\n  function borrowAllowance(address fromUser, address toUser) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IEligibilityDataProvider.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\n\ninterface IEligibilityDataProvider {\n    function refresh(address user) external;\n\n    function updatePrice() external;\n\n    function requiredEthValue(address user)\n        external\n        view\n        returns (uint256 required);\n\n    function isEligibleForRewards(address _user)\n        external\n        view\n        returns (bool isEligible);\n\n    function lastEligibleTime(address user)\n        external\n        view\n        returns (uint256 lastEligibleTimestamp);\n\n    function lockedUsdValue(address user)\n        external\n        view\n        returns (uint256);\n\n    function requiredUsdValue(address user)\n        external\n        view\n        returns (uint256 required);\n\n    function lastEligibleStatus(address user)\n        external\n        view\n        returns (bool);\n\n    function isMarketDisqualified(address user)\n        external\n        view\n        returns (bool);\n\n    function rewardEligibleAmount(address token)\n        external\n        view\n        returns (uint256);\n\n    function setDqTime(address _user, uint256 _time) external;\n    function getDqTime(address _user) external view returns (uint256);\n    function autoprune() external returns (uint256 processed);\n    function requiredDepositRatio() external view returns (uint256);\n    function RATIO_DIVISOR() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IExchangeAdapter.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\nimport {IERC20} from '../dependencies/openzeppelin/contracts/IERC20.sol';\n\ninterface IExchangeAdapter {\n  event Exchange(\n    address indexed from,\n    address indexed to,\n    address indexed platform,\n    uint256 fromAmount,\n    uint256 toAmount\n  );\n\n  function approveExchange(IERC20[] calldata tokens) external;\n\n  function exchange(\n    address from,\n    address to,\n    uint256 amount,\n    uint256 maxSlippage\n  ) external returns (uint256);\n}\n"
    },
    "contracts/interfaces/IFeeDistribution.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"./LockedBalance.sol\";\n\ninterface IFeeDistribution {\n    struct RewardData {\n        address token;\n        uint256 amount;\n    }\n    function addReward(address rewardsToken) external;\n    function lockedBalances(address user) external view returns (uint256, uint256, uint256, uint256, LockedBalance[] memory);\n}"
    },
    "contracts/interfaces/IIncentivizedERC20.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\nimport {IERC20} from '../dependencies/openzeppelin/contracts/IERC20.sol';\nimport {IScaledBalanceToken} from './IScaledBalanceToken.sol';\nimport {IInitializableAToken} from './IInitializableAToken.sol';\nimport {IAaveIncentivesController} from './IAaveIncentivesController.sol';\n\ninterface IIncentivizedERC20 {\n  function getAssetPrice() external view returns (uint256);\n  function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/interfaces/IInitializableAToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\nimport {ILendingPool} from './ILendingPool.sol';\nimport {IAaveIncentivesController} from './IAaveIncentivesController.sol';\n\n/**\n * @title IInitializableAToken\n * @notice Interface for the initialize function on AToken\n * @author Aave\n **/\ninterface IInitializableAToken {\n  /**\n   * @dev Emitted when an aToken is initialized\n   * @param underlyingAsset The address of the underlying asset\n   * @param pool The address of the associated lending pool\n   * @param treasury The address of the treasury\n   * @param incentivesController The address of the incentives controller for this aToken\n   * @param aTokenDecimals the decimals of the underlying\n   * @param aTokenName the name of the aToken\n   * @param aTokenSymbol the symbol of the aToken\n   * @param params A set of encoded parameters for additional initialization\n   **/\n  event Initialized(\n    address indexed underlyingAsset,\n    address indexed pool,\n    address treasury,\n    address incentivesController,\n    uint8 aTokenDecimals,\n    string aTokenName,\n    string aTokenSymbol,\n    bytes params\n  );\n\n  /**\n   * @dev Initializes the aToken\n   * @param pool The address of the lending pool where this aToken will be used\n   * @param treasury The address of the Aave treasury, receiving the fees on this aToken\n   * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH)\n   * @param incentivesController The smart contract managing potential incentives distribution\n   * @param aTokenDecimals The decimals of the aToken, same as the underlying asset's\n   * @param aTokenName The name of the aToken\n   * @param aTokenSymbol The symbol of the aToken\n   */\n  function initialize(\n    ILendingPool pool,\n    address treasury,\n    address underlyingAsset,\n    IAaveIncentivesController incentivesController,\n    uint8 aTokenDecimals,\n    string calldata aTokenName,\n    string calldata aTokenSymbol,\n    bytes calldata params\n  ) external;\n}\n"
    },
    "contracts/interfaces/IInitializableDebtToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\nimport {ILendingPool} from './ILendingPool.sol';\nimport {IAaveIncentivesController} from './IAaveIncentivesController.sol';\n\n/**\n * @title IInitializableDebtToken\n * @notice Interface for the initialize function common between debt tokens\n * @author Aave\n **/\ninterface IInitializableDebtToken {\n  /**\n   * @dev Emitted when a debt token is initialized\n   * @param underlyingAsset The address of the underlying asset\n   * @param pool The address of the associated lending pool\n   * @param incentivesController The address of the incentives controller for this aToken\n   * @param debtTokenDecimals the decimals of the debt token\n   * @param debtTokenName the name of the debt token\n   * @param debtTokenSymbol the symbol of the debt token\n   * @param params A set of encoded parameters for additional initialization\n   **/\n  event Initialized(\n    address indexed underlyingAsset,\n    address indexed pool,\n    address incentivesController,\n    uint8 debtTokenDecimals,\n    string debtTokenName,\n    string debtTokenSymbol,\n    bytes params\n  );\n\n  /**\n   * @dev Initializes the debt token.\n   * @param pool The address of the lending pool where this aToken will be used\n   * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH)\n   * @param incentivesController The smart contract managing potential incentives distribution\n   * @param debtTokenDecimals The decimals of the debtToken, same as the underlying asset's\n   * @param debtTokenName The name of the token\n   * @param debtTokenSymbol The symbol of the token\n   */\n  function initialize(\n    ILendingPool pool,\n    address underlyingAsset,\n    IAaveIncentivesController incentivesController,\n    uint8 debtTokenDecimals,\n    string memory debtTokenName,\n    string memory debtTokenSymbol,\n    bytes calldata params\n  ) external;\n}\n"
    },
    "contracts/interfaces/ILendingPool.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {ILendingPoolAddressesProvider} from './ILendingPoolAddressesProvider.sol';\nimport {DataTypes} from '../protocol/libraries/types/DataTypes.sol';\n\ninterface ILendingPool {\n  /**\n   * @dev Emitted on deposit()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the deposit\n   * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens\n   * @param amount The amount deposited\n   * @param referral The referral code used\n   **/\n  event Deposit(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint16 indexed referral\n  );\n\n  /**\n   * @dev Emitted on withdraw()\n   * @param reserve The address of the underlyng asset being withdrawn\n   * @param user The address initiating the withdrawal, owner of aTokens\n   * @param to Address that will receive the underlying\n   * @param amount The amount to be withdrawn\n   **/\n  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\n\n  /**\n   * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\n   * @param reserve The address of the underlying asset being borrowed\n   * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\n   * initiator of the transaction on flashLoan()\n   * @param onBehalfOf The address that will be getting the debt\n   * @param amount The amount borrowed out\n   * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable\n   * @param borrowRate The numeric rate at which the user has borrowed\n   * @param referral The referral code used\n   **/\n  event Borrow(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint256 borrowRateMode,\n    uint256 borrowRate,\n    uint16 indexed referral\n  );\n\n  /**\n   * @dev Emitted on repay()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The beneficiary of the repayment, getting his debt reduced\n   * @param repayer The address of the user initiating the repay(), providing the funds\n   * @param amount The amount repaid\n   **/\n  event Repay(\n    address indexed reserve,\n    address indexed user,\n    address indexed repayer,\n    uint256 amount\n  );\n\n  /**\n   * @dev Emitted on swapBorrowRateMode()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user swapping his rate mode\n   * @param rateMode The rate mode that the user wants to swap to\n   **/\n  event Swap(address indexed reserve, address indexed user, uint256 rateMode);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   **/\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   **/\n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on rebalanceStableBorrowRate()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user for which the rebalance has been executed\n   **/\n  event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on flashLoan()\n   * @param target The address of the flash loan receiver contract\n   * @param initiator The address initiating the flash loan\n   * @param asset The address of the asset being flash borrowed\n   * @param amount The amount flash borrowed\n   * @param premium The fee flash borrowed\n   * @param referralCode The referral code used\n   **/\n  event FlashLoan(\n    address indexed target,\n    address indexed initiator,\n    address indexed asset,\n    uint256 amount,\n    uint256 premium,\n    uint16 referralCode\n  );\n\n  /**\n   * @dev Emitted when the pause is triggered.\n   */\n  event Paused();\n\n  /**\n   * @dev Emitted when the pause is lifted.\n   */\n  event Unpaused();\n\n  /**\n   * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via\n   * LendingPoolCollateral manager using a DELEGATECALL\n   * This allows to have the events in the generated ABI for LendingPool.\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator\n   * @param liquidator The address of the liquidator\n   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   **/\n  event LiquidationCall(\n    address indexed collateralAsset,\n    address indexed debtAsset,\n    address indexed user,\n    uint256 debtToCover,\n    uint256 liquidatedCollateralAmount,\n    address liquidator,\n    bool receiveAToken\n  );\n\n  /**\n   * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared\n   * in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal,\n   * the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it\n   * gets added to the LendingPool ABI\n   * @param reserve The address of the underlying asset of the reserve\n   * @param liquidityRate The new liquidity rate\n   * @param stableBorrowRate The new stable borrow rate\n   * @param variableBorrowRate The new variable borrow rate\n   * @param liquidityIndex The new liquidity index\n   * @param variableBorrowIndex The new variable borrow index\n   **/\n  event ReserveDataUpdated(\n    address indexed reserve,\n    uint256 liquidityRate,\n    uint256 stableBorrowRate,\n    uint256 variableBorrowRate,\n    uint256 liquidityIndex,\n    uint256 variableBorrowIndex\n  );\n\n  /**\n   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\n   * @param asset The address of the underlying asset to deposit\n   * @param amount The amount to be deposited\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function deposit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n\n  function depositWithAutoDLP(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n   * @param to Address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   **/\n  function withdraw(\n    address asset,\n    uint256 amount,\n    address to\n  ) external returns (uint256);\n\n  /**\n   * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n   * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\n   * corresponding debt token (StableDebtToken or VariableDebtToken)\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n   * if he has been given credit delegation allowance\n   **/\n  function borrow(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    uint16 referralCode,\n    address onBehalfOf\n  ) external;\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @return The final amount repaid\n   **/\n  function repay(\n    address asset,\n    uint256 amount,\n    uint256 rateMode,\n    address onBehalfOf\n  ) external returns (uint256);\n\n  /**\n   * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa\n   * @param asset The address of the underlying asset borrowed\n   * @param rateMode The rate mode that the user wants to swap to\n   **/\n  function swapBorrowRateMode(address asset, uint256 rateMode) external;\n\n  /**\n   * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n   * - Users can be rebalanced if the following conditions are satisfied:\n   *     1. Usage ratio is above 95%\n   *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been\n   *        borrowed at a stable rate and depositors are not earning enough\n   * @param asset The address of the underlying asset borrowed\n   * @param user The address of the user to be rebalanced\n   **/\n  function rebalanceStableBorrowRate(address asset, address user) external;\n\n  /**\n   * @dev Allows depositors to enable/disable a specific deposited asset as collateral\n   * @param asset The address of the underlying asset deposited\n   * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\n   **/\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   **/\n  function liquidationCall(\n    address collateralAsset,\n    address debtAsset,\n    address user,\n    uint256 debtToCover,\n    bool receiveAToken\n  ) external;\n\n  /**\n   * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.\n   * For further details please visit https://developers.aave.com\n   * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface\n   * @param assets The addresses of the assets being flash-borrowed\n   * @param amounts The amounts amounts being flash-borrowed\n   * @param modes Types of the debt to open if the flash loan is not returned:\n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n   *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function flashLoan(\n    address receiverAddress,\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata modes,\n    address onBehalfOf,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @dev Returns the user account data across all the reserves\n   * @param user The address of the user\n   * @return totalCollateralETH the total collateral in ETH of the user\n   * @return totalDebtETH the total debt in ETH of the user\n   * @return availableBorrowsETH the borrowing power left of the user\n   * @return currentLiquidationThreshold the liquidation threshold of the user\n   * @return ltv the loan to value of the user\n   * @return healthFactor the current health factor of the user\n   **/\n  function getUserAccountData(address user)\n    external\n    view\n    returns (\n      uint256 totalCollateralETH,\n      uint256 totalDebtETH,\n      uint256 availableBorrowsETH,\n      uint256 currentLiquidationThreshold,\n      uint256 ltv,\n      uint256 healthFactor\n    );\n\n  function initReserve(\n    address reserve,\n    address aTokenAddress,\n    address stableDebtAddress,\n    address variableDebtAddress,\n    address interestRateStrategyAddress\n  ) external;\n\n  function setReserveInterestRateStrategyAddress(address reserve, address rateStrategyAddress)\n    external;\n\n  function setConfiguration(address reserve, uint256 configuration) external;\n\n  /**\n   * @dev Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   **/\n  function getConfiguration(address asset)\n    external\n    view\n    returns (DataTypes.ReserveConfigurationMap memory);\n\n  /**\n   * @dev Returns the configuration of the user across all the reserves\n   * @param user The user address\n   * @return The configuration of the user\n   **/\n  function getUserConfiguration(address user)\n    external\n    view\n    returns (DataTypes.UserConfigurationMap memory);\n\n  /**\n   * @dev Returns the normalized income normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset) external view returns (uint256);\n\n  /**\n   * @dev Returns the normalized variable debt per unit of asset\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\n\n  /**\n   * @dev Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state of the reserve\n   **/\n  function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\n\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address to,\n    uint256 amount,\n    uint256 balanceFromAfter,\n    uint256 balanceToBefore\n  ) external;\n\n  function getReservesList() external view returns (address[] memory);\n\n  function getAddressesProvider() external view returns (ILendingPoolAddressesProvider);\n\n  function setPause(bool val) external;\n\n  function paused() external view returns (bool);\n}\n"
    },
    "contracts/interfaces/ILendingPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\n/**\n * @title LendingPoolAddressesProvider contract\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\n * - Owned by the Aave Governance\n * @author Aave\n **/\ninterface ILendingPoolAddressesProvider {\n  event MarketIdSet(string newMarketId);\n  event LendingPoolUpdated(address indexed newAddress);\n  event ConfigurationAdminUpdated(address indexed newAddress);\n  event EmergencyAdminUpdated(address indexed newAddress);\n  event LendingPoolConfiguratorUpdated(address indexed newAddress);\n  event LendingPoolCollateralManagerUpdated(address indexed newAddress);\n  event PriceOracleUpdated(address indexed newAddress);\n  event LendingRateOracleUpdated(address indexed newAddress);\n  event ProxyCreated(bytes32 id, address indexed newAddress);\n  event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);\n\n  function getMarketId() external view returns (string memory);\n\n  function setMarketId(string calldata marketId) external;\n\n  function setAddress(bytes32 id, address newAddress) external;\n\n  function setAddressAsProxy(bytes32 id, address impl) external;\n\n  function getAddress(bytes32 id) external view returns (address);\n\n  function getLendingPool() external view returns (address);\n\n  function setLendingPoolImpl(address pool) external;\n\n  function getLendingPoolConfigurator() external view returns (address);\n\n  function setLendingPoolConfiguratorImpl(address configurator) external;\n\n  function getLendingPoolCollateralManager() external view returns (address);\n\n  function setLendingPoolCollateralManager(address manager) external;\n\n  function getPoolAdmin() external view returns (address);\n\n  function setPoolAdmin(address admin) external;\n\n  function getEmergencyAdmin() external view returns (address);\n\n  function setEmergencyAdmin(address admin) external;\n\n  function getPriceOracle() external view returns (address);\n\n  function setPriceOracle(address priceOracle) external;\n\n  function getLendingRateOracle() external view returns (address);\n\n  function setLendingRateOracle(address lendingRateOracle) external;\n\n  function getLiquidationFeeTo() external view returns (address);\n\n  function setLiquidationFeeTo(address liquidationFeeTo) external;\n}\n"
    },
    "contracts/interfaces/ILendingPoolAddressesProviderRegistry.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\n/**\n * @title LendingPoolAddressesProviderRegistry contract\n * @dev Main registry of LendingPoolAddressesProvider of multiple Aave protocol's markets\n * - Used for indexing purposes of Aave protocol's markets\n * - The id assigned to a LendingPoolAddressesProvider refers to the market it is connected with,\n *   for example with `0` for the Aave main market and `1` for the next created\n * @author Aave\n **/\ninterface ILendingPoolAddressesProviderRegistry {\n  event AddressesProviderRegistered(address indexed newAddress);\n  event AddressesProviderUnregistered(address indexed newAddress);\n\n  function getAddressesProvidersList() external view returns (address[] memory);\n\n  function getAddressesProviderIdByAddress(address addressesProvider)\n    external\n    view\n    returns (uint256);\n\n  function registerAddressesProvider(address provider, uint256 id) external;\n\n  function unregisterAddressesProvider(address provider) external;\n}\n"
    },
    "contracts/interfaces/ILendingPoolCollateralManager.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\n/**\n * @title ILendingPoolCollateralManager\n * @author Aave\n * @notice Defines the actions involving management of collateral in the protocol.\n **/\ninterface ILendingPoolCollateralManager {\n  /**\n   * @dev Emitted when a borrower is liquidated\n   * @param collateral The address of the collateral being liquidated\n   * @param principal The address of the reserve\n   * @param user The address of the user being liquidated\n   * @param debtToCover The total amount liquidated\n   * @param liquidatedCollateralAmount The amount of collateral being liquidated\n   * @param liquidator The address of the liquidator\n   * @param receiveAToken true if the liquidator wants to receive aTokens, false otherwise\n   **/\n  event LiquidationCall(\n    address indexed collateral,\n    address indexed principal,\n    address indexed user,\n    uint256 debtToCover,\n    uint256 liquidatedCollateralAmount,\n    address liquidator,\n    bool receiveAToken,\n    address liquidationFeeTo\n  );\n\n  /**\n   * @dev Emitted when a reserve is disabled as collateral for an user\n   * @param reserve The address of the reserve\n   * @param user The address of the user\n   **/\n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted when a reserve is enabled as collateral for an user\n   * @param reserve The address of the reserve\n   * @param user The address of the user\n   **/\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Users can invoke this function to liquidate an undercollateralized position.\n   * @param collateral The address of the collateral to liquidated\n   * @param principal The address of the principal reserve\n   * @param user The address of the borrower\n   * @param debtToCover The amount of principal that the liquidator wants to repay\n   * @param receiveAToken true if the liquidators wants to receive the aTokens, false if\n   * he wants to receive the underlying asset directly\n   **/\n  function liquidationCall(\n    address collateral,\n    address principal,\n    address user,\n    uint256 debtToCover,\n    bool receiveAToken,\n    address liquidationFeeTo\n  ) external returns (uint256, string memory);\n}\n"
    },
    "contracts/interfaces/ILendingPoolConfigurator.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\n\ninterface ILendingPoolConfigurator {\n  struct InitReserveInput {\n    address aTokenImpl;\n    address stableDebtTokenImpl;\n    address variableDebtTokenImpl;\n    uint8 underlyingAssetDecimals;\n    address interestRateStrategyAddress;\n    address underlyingAsset;\n    address treasury;\n    address incentivesController;\n    uint256 allocPoint;\n    string underlyingAssetName;\n    string aTokenName;\n    string aTokenSymbol;\n    string variableDebtTokenName;\n    string variableDebtTokenSymbol;\n    string stableDebtTokenName;\n    string stableDebtTokenSymbol;\n    bytes params;\n  }\n\n  struct UpdateATokenInput {\n    address asset;\n    address treasury;\n    address incentivesController;\n    string name;\n    string symbol;\n    address implementation;\n    bytes params;\n  }\n\n  struct UpdateDebtTokenInput {\n    address asset;\n    address incentivesController;\n    string name;\n    string symbol;\n    address implementation;\n    bytes params;\n  }\n\n  /**\n   * @dev Emitted when a reserve is initialized.\n   * @param asset The address of the underlying asset of the reserve\n   * @param aToken The address of the associated aToken contract\n   * @param stableDebtToken The address of the associated stable rate debt token\n   * @param variableDebtToken The address of the associated variable rate debt token\n   * @param interestRateStrategyAddress The address of the interest rate strategy for the reserve\n   **/\n  event ReserveInitialized(\n    address indexed asset,\n    address indexed aToken,\n    address stableDebtToken,\n    address variableDebtToken,\n    address interestRateStrategyAddress\n  );\n\n  /**\n   * @dev Emitted when borrowing is enabled on a reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @param stableRateEnabled True if stable rate borrowing is enabled, false otherwise\n   **/\n  event BorrowingEnabledOnReserve(address indexed asset, bool stableRateEnabled);\n\n  /**\n   * @dev Emitted when borrowing is disabled on a reserve\n   * @param asset The address of the underlying asset of the reserve\n   **/\n  event BorrowingDisabledOnReserve(address indexed asset);\n\n  /**\n   * @dev Emitted when the collateralization risk parameters for the specified asset are updated.\n   * @param asset The address of the underlying asset of the reserve\n   * @param ltv The loan to value of the asset when used as collateral\n   * @param liquidationThreshold The threshold at which loans using this asset as collateral will be considered undercollateralized\n   * @param liquidationBonus The bonus liquidators receive to liquidate this asset\n   **/\n  event CollateralConfigurationChanged(\n    address indexed asset,\n    uint256 ltv,\n    uint256 liquidationThreshold,\n    uint256 liquidationBonus\n  );\n\n  /**\n   * @dev Emitted when stable rate borrowing is enabled on a reserve\n   * @param asset The address of the underlying asset of the reserve\n   **/\n  event StableRateEnabledOnReserve(address indexed asset);\n\n  /**\n   * @dev Emitted when stable rate borrowing is disabled on a reserve\n   * @param asset The address of the underlying asset of the reserve\n   **/\n  event StableRateDisabledOnReserve(address indexed asset);\n\n  /**\n   * @dev Emitted when a reserve is activated\n   * @param asset The address of the underlying asset of the reserve\n   **/\n  event ReserveActivated(address indexed asset);\n\n  /**\n   * @dev Emitted when a reserve is deactivated\n   * @param asset The address of the underlying asset of the reserve\n   **/\n  event ReserveDeactivated(address indexed asset);\n\n  /**\n   * @dev Emitted when a reserve is frozen\n   * @param asset The address of the underlying asset of the reserve\n   **/\n  event ReserveFrozen(address indexed asset);\n\n  /**\n   * @dev Emitted when a reserve is unfrozen\n   * @param asset The address of the underlying asset of the reserve\n   **/\n  event ReserveUnfrozen(address indexed asset);\n\n  /**\n   * @dev Emitted when a reserve factor is updated\n   * @param asset The address of the underlying asset of the reserve\n   * @param factor The new reserve factor\n   **/\n  event ReserveFactorChanged(address indexed asset, uint256 factor);\n\n  /**\n   * @dev Emitted when the reserve decimals are updated\n   * @param asset The address of the underlying asset of the reserve\n   * @param decimals The new decimals\n   **/\n  event ReserveDecimalsChanged(address indexed asset, uint256 decimals);\n\n  /**\n   * @dev Emitted when a reserve interest strategy contract is updated\n   * @param asset The address of the underlying asset of the reserve\n   * @param strategy The new address of the interest strategy contract\n   **/\n  event ReserveInterestRateStrategyChanged(address indexed asset, address strategy);\n\n  /**\n   * @dev Emitted when an aToken implementation is upgraded\n   * @param asset The address of the underlying asset of the reserve\n   * @param proxy The aToken proxy address\n   * @param implementation The new aToken implementation\n   **/\n  event ATokenUpgraded(\n    address indexed asset,\n    address indexed proxy,\n    address indexed implementation\n  );\n\n  /**\n   * @dev Emitted when the implementation of a stable debt token is upgraded\n   * @param asset The address of the underlying asset of the reserve\n   * @param proxy The stable debt token proxy address\n   * @param implementation The new aToken implementation\n   **/\n  event StableDebtTokenUpgraded(\n    address indexed asset,\n    address indexed proxy,\n    address indexed implementation\n  );\n\n  /**\n   * @dev Emitted when the implementation of a variable debt token is upgraded\n   * @param asset The address of the underlying asset of the reserve\n   * @param proxy The variable debt token proxy address\n   * @param implementation The new aToken implementation\n   **/\n  event VariableDebtTokenUpgraded(\n    address indexed asset,\n    address indexed proxy,\n    address indexed implementation\n  );\n}\n"
    },
    "contracts/interfaces/ILendingRateOracle.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\n/**\n * @title ILendingRateOracle interface\n * @notice Interface for the Aave borrow rate oracle. Provides the average market borrow rate to be used as a base for the stable borrow rate calculations\n **/\n\ninterface ILendingRateOracle {\n  /**\n    @dev returns the market borrow rate in ray\n    **/\n  function getMarketBorrowRate(address asset) external view returns (uint256);\n\n  /**\n    @dev sets the market borrow rate. Rate value must be in ray\n    **/\n  function setMarketBorrowRate(address asset, uint256 rate) external;\n}\n"
    },
    "contracts/interfaces/ILeverager.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\n\ninterface ILeverager {\n    function wethToZap (address user) external view returns (uint256);\n    function zapWETHWithBorrow (uint256 amount, address borrower) external returns(uint256 liquidity);\n    function zapWETHWithBorrow (uint256 amount, address borrower, address onBehalfOf) external returns(uint256 liquidity);\n}\n"
    },
    "contracts/interfaces/ILiquidityZap.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\ninterface ILiquidityZap {\n  function _WETH (  ) external view returns ( address );\n  function _token (  ) external view returns ( address );\n  function _tokenWETHPair (  ) external view returns ( address );\n  function addLiquidityETHOnly ( address to ) external returns ( uint256 liquidity );\n  function addLiquidityTokensOnly ( address from, address to, uint256 amount ) external returns ( uint256 liquidity );\n  function getLPTokenPerEthUnit ( uint256 ethAmt ) external view returns ( uint256 liquidity );\n  function initLiquidityZap ( address token, address WETH, address tokenWethPair ) external;\n  function quote ( uint256 wethAmount ) external view returns ( uint256 optimalTokenAmount );\n  function quoteFromToken ( uint256 tokenAmount ) external view returns ( uint256 optimalWETHAmount );\n  function removeAllLiquidityETHOnly ( address to ) external returns ( uint256 amount );\n  function removeAllLiquidityTokenOnly ( address to ) external returns ( uint256 amount );\n  function removeLiquidity ( address tokenA, address tokenB, uint256 liquidity, address to ) external returns ( uint256 amountA, uint256 amountB );\n  function removeLiquidityETHOnly ( address to, uint256 liquidity ) external returns ( uint256 amountOut );\n  function removeLiquidityTokenOnly ( address to, uint256 liquidity ) external returns ( uint256 amount );\n  function standardAdd ( uint256 tokenAmount, uint256 _wethAmt, address to ) external payable returns ( uint256 liquidity );\n  function unzap (  ) external returns ( uint256 amountToken, uint256 amountETH );\n  function unzapToETH (  ) external returns ( uint256 amount );\n  function unzapToTokens (  ) external returns ( uint256 amount );\n  function zapETH (address payable _onBehalf) external payable returns ( uint256 liquidity );\n  function zapTokens ( uint256 amount ) external returns ( uint256 liquidity );\n  function addLiquidityWETHOnly(uint256 _amount, address payable to) external returns (uint256 liquidity);\n}\n"
    },
    "contracts/interfaces/ILockerList.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\ninterface ILockerList {\n    function lockersCount() external view returns (uint256);\n    function getUsers(uint256 page, uint256 limit) external view returns (address[] memory);\n    function addToList(address user) external;\n    function removeFromList(address user) external;\n}\n"
    },
    "contracts/interfaces/ILockZap.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\n\ninterface ILockZap {\n    function zap(bool _borrow, uint256 _wethAmt, uint256 _rdntAmt, uint256 _lockTypeIndex) external returns (uint256 liquidity);\n    function zapOnBehalf(bool _borrow, uint256 _wethAmt, uint256 _rdntAmt, address _onBehalf) external returns (uint256 liquidity);\n\n}\n"
    },
    "contracts/interfaces/IMFDHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"./IFeeDistribution.sol\";\ninterface IMFDHelper {\n\n    function getUnderlying(address token) external view returns (address underlying);\n    function getLendingPool() external view returns (address);\n    function getRewardToBaseRoute(address token) external view returns (address[] memory);\n    function getRouteToRdnt() external view returns (address[] memory routeToRdnt);\n    function quoteSelfCompound() external view returns (uint256 tokensOut); \n\n    function getIneligibleRewards(\n        IFeeDistribution.RewardData[] memory pendingRewards,\n        LockedBalance[] memory locks,\n        uint256 lastClaimTime\n    )\n    external\n    view\n    returns (IFeeDistribution.RewardData[] memory bounties);\n\n\n}"
    },
    "contracts/interfaces/IMFDstats.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\ninterface IMFDstats {\n    struct AddTransferParam {\n        address asset;\n        uint256 amount;\n        address treasury;\n    }\n\n    function getTotal() external view returns (uint256);\n\n    function getLastDayTotal() external view returns (uint256);\n\n    function addTransfer(AddTransferParam memory param) external;\n}\n"
    },
    "contracts/interfaces/IMiddleFeeDistribution.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"./LockedBalance.sol\";\nimport {IFeeDistribution} from \"./IMultiFeeDistribution.sol\";\n\ninterface IMiddleFeeDistribution is IFeeDistribution {\n    function forwardReward(address[] memory _rewardTokens) external;\n    function getMFDstatsAddress () external view returns (address);\n    function lpLockingRewardRatio () external view returns (uint256);\n    function getRdntTokenAddress () external view returns (address);\n    function getLPFeeDistributionAddress () external view returns (address);\n    function getMultiFeeDistributionAddress () external view returns (address);\n    function operationExpenseRatio () external view returns (uint256);\n    function operationExpenses () external view returns (address);\n    function isRewardToken(address) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IMintableToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\n\npragma solidity 0.7.6;\n\nimport \"../dependencies/openzeppelin/contracts/IERC20.sol\";\n\ninterface IMintableToken is IERC20 {\n    function mint(address _receiver, uint256 _amount) external returns (bool);\n    function burn(uint256 _amount) external returns (bool);\n    function setMinter(address _minter) external returns (bool);\n}\n"
    },
    "contracts/interfaces/IMultiFeeDistribution.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"./LockedBalance.sol\";\nimport \"./IFeeDistribution.sol\";\ninterface IMultiFeeDistribution is IFeeDistribution {\n    function exit(bool claimRewards) external;\n    function stake(uint256 amount, address onBehalfOf, uint256 typeIndex) external;\n    function lockInfo(address user) external view returns (LockedBalance[] memory);\n    function defaultLockIndex(address _user) external view returns (uint256);\n    function autoRelockDisabled(address user) external view returns (bool);\n    function totalBalance(address user) external view returns (uint256);\n    function zapVestingToLp (address _address) external returns (uint256);\n    function withdrawExpiredLocksFor(address _address) external returns (uint256);\n    function claimableRewards(address account) external view returns (IFeeDistribution.RewardData[] memory rewards);\n    function setDefaultRelockTypeIndex(uint256 _index) external;\n    function daoTreasury() external view returns (address);\n    function stakingToken() external view returns (address);\n    function mint(address user, uint256 amount, bool withPenalty) external;\n}\n\ninterface IMFDPlus is IMultiFeeDistribution {\n    function getLastClaimTime(address _user) external returns (uint256);\n    function claimFromConverter(address) external;\n    function bountyForUser(address _user) external view returns (IFeeDistribution.RewardData[] memory bounties);\n    function claimBounty(address _user, bool _execute) external returns (uint256 bountyAmt, bool issueBaseBounty);\n    function claimCompound(address _user, bool _execute) external returns (uint256 bountyAmt);\n    function setAutocompound(bool _newVal) external;\n    function getAutocompoundEnabled(address _user) external view returns(bool);\n}"
    },
    "contracts/interfaces/IOnwardIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\ninterface IOnwardIncentivesController {\n    function handleAction(\n        address _token,\n        address _user,\n        uint256 _balance,\n        uint256 _totalSupply\n    ) external;\n}\n"
    },
    "contracts/interfaces/IPoolHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport {IERC20} from \"../dependencies/openzeppelin/contracts/IERC20.sol\";\n\ninterface IPoolHelper {\n    function lpTokenAddr() external view returns (address);\n    function initializePool() external;\n    function zapWETH(uint256 amount) external returns (uint256);\n    function zapTokens(uint256 _wethAmt, uint256 _rdntAmt) external returns (uint256);\n    function quoteFromToken(uint256 tokenAmount) external view returns (uint256 optimalWETHAmount);\n    function getLpPrice(uint rdntPriceInEth) external view returns (uint256 priceInEth);\n    function getReserves() external view returns (uint256 rdnt,uint256 weth, uint256 lpTokenSupply);\n}\n\ninterface ITestPoolHelper is IPoolHelper {\n    function sell(uint256 _amount) external returns (uint256 amountOut);\n}\n"
    },
    "contracts/interfaces/IPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\n/************\n@title IPriceOracle interface\n@notice Interface for the Aave price oracle.*/\ninterface IPriceOracle {\n  /***********\n    @dev returns the asset price in ETH\n     */\n  function getAssetPrice(address asset) external view returns (uint256);\n\n  /***********\n    @dev sets the asset price, in wei\n     */\n  function setAssetPrice(address asset, uint256 price) external;\n}\n"
    },
    "contracts/interfaces/IPriceOracleGetter.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\n/**\n * @title IPriceOracleGetter interface\n * @notice Interface for the Aave price oracle.\n **/\n\ninterface IPriceOracleGetter {\n  /**\n   * @dev returns the asset price in ETH\n   * @param asset the address of the asset\n   * @return the ETH price of the asset\n   **/\n  function getAssetPrice(address asset) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\ninterface IPriceProvider {\n    function getTokenPrice() external view returns (uint256);\n    function getTokenPriceUsd() external view returns (uint256);\n    function getLpTokenPrice() external view returns (uint256);\n    function getLpTokenPriceUsd() external view returns (uint256);\n    function decimals() external view returns (uint256);\n    function update() external;\n    function baseTokenPriceInUsdProxyAggregator() external view returns (address);\n}"
    },
    "contracts/interfaces/IReserveInterestRateStrategy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\n/**\n * @title IReserveInterestRateStrategyInterface interface\n * @dev Interface for the calculation of the interest rates\n * @author Aave\n */\ninterface IReserveInterestRateStrategy {\n  function baseVariableBorrowRate() external view returns (uint256);\n\n  function getMaxVariableBorrowRate() external view returns (uint256);\n\n  function calculateInterestRates(\n    address reserve,\n    uint256 availableLiquidity,\n    uint256 totalStableDebt,\n    uint256 totalVariableDebt,\n    uint256 averageStableBorrowRate,\n    uint256 reserveFactor\n  )\n    external\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    );\n\n  function calculateInterestRates(\n    address reserve,\n    address aToken,\n    uint256 liquidityAdded,\n    uint256 liquidityTaken,\n    uint256 totalStableDebt,\n    uint256 totalVariableDebt,\n    uint256 averageStableBorrowRate,\n    uint256 reserveFactor\n  )\n    external\n    view\n    returns (\n      uint256 liquidityRate,\n      uint256 stableBorrowRate,\n      uint256 variableBorrowRate\n    );\n}\n"
    },
    "contracts/interfaces/IRouterETH.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\ninterface IRouterETH {\n    function swapETH(\n        uint16 _dstChainId, // destination Stargate chainId\n        address payable _refundAddress, // refund additional messageFee to this address\n        bytes calldata _toAddress, // the receiver of the destination ETH\n        uint256 _amountLD, // the amount, in Local Decimals, to be swapped\n        uint256 _minAmountLD // the minimum amount accepted out on destination\n    ) external payable;\n}"
    },
    "contracts/interfaces/IScaledBalanceToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\ninterface IScaledBalanceToken {\n  /**\n   * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the\n   * updated stored balance divided by the reserve's liquidity index at the moment of the update\n   * @param user The user whose balance is calculated\n   * @return The scaled balance of the user\n   **/\n  function scaledBalanceOf(address user) external view returns (uint256);\n\n  /**\n   * @dev Returns the scaled balance of the user and the scaled total supply.\n   * @param user The address of the user\n   * @return The scaled balance of the user\n   * @return The scaled balance and the scaled total supply\n   **/\n  function getScaledUserBalanceAndSupply(address user) external view returns (uint256, uint256);\n\n  /**\n   * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index)\n   * @return The scaled total supply\n   **/\n  function scaledTotalSupply() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IStableDebtToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\nimport {IInitializableDebtToken} from './IInitializableDebtToken.sol';\nimport {IAaveIncentivesController} from './IAaveIncentivesController.sol';\n\n/**\n * @title IStableDebtToken\n * @notice Defines the interface for the stable debt token\n * @dev It does not inherit from IERC20 to save in code size\n * @author Aave\n **/\n\ninterface IStableDebtToken is IInitializableDebtToken {\n  /**\n   * @dev Emitted when new stable debt is minted\n   * @param user The address of the user who triggered the minting\n   * @param onBehalfOf The recipient of stable debt tokens\n   * @param amount The amount minted\n   * @param currentBalance The current balance of the user\n   * @param balanceIncrease The increase in balance since the last action of the user\n   * @param newRate The rate of the debt after the minting\n   * @param avgStableRate The new average stable rate after the minting\n   * @param newTotalSupply The new total supply of the stable debt token after the action\n   **/\n  event Mint(\n    address indexed user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint256 currentBalance,\n    uint256 balanceIncrease,\n    uint256 newRate,\n    uint256 avgStableRate,\n    uint256 newTotalSupply\n  );\n\n  /**\n   * @dev Emitted when new stable debt is burned\n   * @param user The address of the user\n   * @param amount The amount being burned\n   * @param currentBalance The current balance of the user\n   * @param balanceIncrease The the increase in balance since the last action of the user\n   * @param avgStableRate The new average stable rate after the burning\n   * @param newTotalSupply The new total supply of the stable debt token after the action\n   **/\n  event Burn(\n    address indexed user,\n    uint256 amount,\n    uint256 currentBalance,\n    uint256 balanceIncrease,\n    uint256 avgStableRate,\n    uint256 newTotalSupply\n  );\n\n  /**\n   * @dev Mints debt token to the `onBehalfOf` address.\n   * - The resulting rate is the weighted average between the rate of the new debt\n   * and the rate of the previous debt\n   * @param user The address receiving the borrowed underlying, being the delegatee in case\n   * of credit delegate, or same as `onBehalfOf` otherwise\n   * @param onBehalfOf The address receiving the debt tokens\n   * @param amount The amount of debt tokens to mint\n   * @param rate The rate of the debt being minted\n   **/\n  function mint(\n    address user,\n    address onBehalfOf,\n    uint256 amount,\n    uint256 rate\n  ) external returns (bool);\n\n  /**\n   * @dev Burns debt of `user`\n   * - The resulting rate is the weighted average between the rate of the new debt\n   * and the rate of the previous debt\n   * @param user The address of the user getting his debt burned\n   * @param amount The amount of debt tokens getting burned\n   **/\n  function burn(address user, uint256 amount) external;\n\n  /**\n   * @dev Returns the average rate of all the stable rate loans.\n   * @return The average stable rate\n   **/\n  function getAverageStableRate() external view returns (uint256);\n\n  /**\n   * @dev Returns the stable rate of the user debt\n   * @return The stable rate of the user\n   **/\n  function getUserStableRate(address user) external view returns (uint256);\n\n  /**\n   * @dev Returns the timestamp of the last update of the user\n   * @return The timestamp\n   **/\n  function getUserLastUpdated(address user) external view returns (uint40);\n\n  /**\n   * @dev Returns the principal, the total supply and the average stable rate\n   **/\n  function getSupplyData()\n    external\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256,\n      uint40\n    );\n\n  /**\n   * @dev Returns the timestamp of the last update of the total supply\n   * @return The timestamp\n   **/\n  function getTotalSupplyLastUpdated() external view returns (uint40);\n\n  /**\n   * @dev Returns the total supply and the average stable rate\n   **/\n  function getTotalSupplyAndAvgRate() external view returns (uint256, uint256);\n\n  /**\n   * @dev Returns the principal debt balance of the user\n   * @return The debt balance of the user since the last burn/mint action\n   **/\n  function principalBalanceOf(address user) external view returns (uint256);\n\n  /**\n   * @dev Returns the address of the incentives controller contract\n   **/\n  function getIncentivesController() external view returns (IAaveIncentivesController);\n}\n"
    },
    "contracts/interfaces/IStargateRouter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\ninterface IStargateRouter {\n    struct lzTxObj {\n        uint256 dstGasForCall;\n        uint256 dstNativeAmount;\n        bytes dstNativeAddr;\n    }\n\n    function addLiquidity(\n        uint256 _poolId,\n        uint256 _amountLD,\n        address _to\n    ) external;\n\n    function swap(\n        uint16 _dstChainId,\n        uint256 _srcPoolId,\n        uint256 _dstPoolId,\n        address payable _refundAddress,\n        uint256 _amountLD,\n        uint256 _minAmountLD,\n        lzTxObj memory _lzTxParams,\n        bytes calldata _to,\n        bytes calldata _payload\n    ) external payable;\n\n    function redeemRemote(\n        uint16 _dstChainId,\n        uint256 _srcPoolId,\n        uint256 _dstPoolId,\n        address payable _refundAddress,\n        uint256 _amountLP,\n        uint256 _minAmountLD,\n        bytes calldata _to,\n        lzTxObj memory _lzTxParams\n    ) external payable;\n\n    function instantRedeemLocal(\n        uint16 _srcPoolId,\n        uint256 _amountLP,\n        address _to\n    ) external returns (uint256);\n\n    function redeemLocal(\n        uint16 _dstChainId,\n        uint256 _srcPoolId,\n        uint256 _dstPoolId,\n        address payable _refundAddress,\n        uint256 _amountLP,\n        bytes calldata _to,\n        lzTxObj memory _lzTxParams\n    ) external payable;\n\n    function sendCredits(\n        uint16 _dstChainId,\n        uint256 _srcPoolId,\n        uint256 _dstPoolId,\n        address payable _refundAddress\n    ) external payable;\n\n    function quoteLayerZeroFee(\n        uint16 _dstChainId,\n        uint8 _functionType,\n        bytes calldata _toAddress,\n        bytes calldata _transferAndCallPayload,\n        lzTxObj memory _lzTxParams\n    ) external view returns (uint256, uint256);\n}"
    },
    "contracts/interfaces/IVariableDebtToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\nimport {IScaledBalanceToken} from './IScaledBalanceToken.sol';\nimport {IInitializableDebtToken} from './IInitializableDebtToken.sol';\nimport {IAaveIncentivesController} from './IAaveIncentivesController.sol';\n\n/**\n * @title IVariableDebtToken\n * @author Aave\n * @notice Defines the basic interface for a variable debt token.\n **/\ninterface IVariableDebtToken is IScaledBalanceToken, IInitializableDebtToken {\n  /**\n   * @dev Emitted after the mint action\n   * @param from The address performing the mint\n   * @param onBehalfOf The address of the user on which behalf minting has been performed\n   * @param value The amount to be minted\n   * @param index The last index of the reserve\n   **/\n  event Mint(address indexed from, address indexed onBehalfOf, uint256 value, uint256 index);\n\n  /**\n   * @dev Mints debt token to the `onBehalfOf` address\n   * @param user The address receiving the borrowed underlying, being the delegatee in case\n   * of credit delegate, or same as `onBehalfOf` otherwise\n   * @param onBehalfOf The address receiving the debt tokens\n   * @param amount The amount of debt being minted\n   * @param index The variable debt index of the reserve\n   * @return `true` if the the previous balance of the user is 0\n   **/\n  function mint(\n    address user,\n    address onBehalfOf,\n    uint256 amount,\n    uint256 index\n  ) external returns (bool);\n\n  /**\n   * @dev Emitted when variable debt is burnt\n   * @param user The user which debt has been burned\n   * @param amount The amount of debt being burned\n   * @param index The index of the user\n   **/\n  event Burn(address indexed user, uint256 amount, uint256 index);\n\n  /**\n   * @dev Burns user variable debt\n   * @param user The user which debt is burnt\n   * @param index The variable debt index of the reserve\n   **/\n  function burn(\n    address user,\n    uint256 amount,\n    uint256 index\n  ) external;\n\n  /**\n   * @dev Returns the address of the incentives controller contract\n   **/\n  function getIncentivesController() external view returns (IAaveIncentivesController);\n}\n"
    },
    "contracts/interfaces/LockedBalance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nstruct LockedBalance {\n    uint256 amount;\n    uint256 unlockTime;\n    uint256 multiplier;\n    uint256 duration;\n}\n\nstruct EarnedBalance {\n    uint256 amount;\n    uint256 unlockTime;\n    uint256 penalty;\n}"
    },
    "contracts/interfaces/uniswap/IUniswapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}"
    },
    "contracts/interfaces/uniswap/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint256 reserve0, uint256 reserve1, uint256 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}"
    },
    "contracts/interfaces/uniswap/IUniswapV2Router01.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}"
    },
    "contracts/interfaces/uniswap/IUniswapV2Router02.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}"
    },
    "contracts/leverage/Leverager.sol": {
      "content": "pragma solidity 0.7.6;\npragma abicoder v2;\n\n// SPDX-License-Identifier: MIT\n\nimport \"../dependencies/openzeppelin/contracts/SafeMath.sol\";\nimport \"../dependencies/openzeppelin/contracts/IERC20.sol\";\nimport \"../dependencies/openzeppelin/contracts/IERC20Detailed.sol\";\nimport \"../dependencies/openzeppelin/contracts/SafeERC20.sol\";\nimport \"../dependencies/openzeppelin/contracts/Ownable.sol\";\n\nimport \"../interfaces/ILendingPool.sol\";\nimport \"../interfaces/IEligibilityDataProvider.sol\";\nimport \"../interfaces/IChainlinkAggregator.sol\";\nimport \"../interfaces/ILockZap.sol\";\nimport \"../misc/interfaces/IAaveOracle.sol\";\nimport \"../misc/interfaces/IWETH.sol\";\n\n/// @title Leverager Contract\n/// @author Radiant\n/// @dev All function calls are currently implemented without side effects\ncontract Leverager is Ownable {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    /// @notice Ratio Divisor\n    uint256 public constant RATIO_DIVISOR = 10000;\n\n    /// @notice Mock ETH address\n    address public constant API_ETH_MOCK_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice Lending Pool address\n    ILendingPool public lendingPool;\n\n    /// @notice EligibilityDataProvider contract address\n    IEligibilityDataProvider public eligibilityDataProvider;\n\n    /// @notice LockZap contract address\n    ILockZap public lockZap;\n\n    /// @notice Wrapped ETH contract address\n    IWETH public weth;\n\n    /// @notice Aave oracle address\n    IAaveOracle public aaveOracle;\n\n    /// @notice Fee ratio\n    uint256 public feePercent;\n\n    /// @notice Treasury address\n    address public treasury;\n\n    /// @notice Emitted when fee ratio is updated\n    event FeePercentUpdated(uint256 _feePercent);\n\n    /// @notice Emitted when treasury is updated\n    event TreasuryUpdated(address indexed _treasury);\n\n    /**\n     * @notice Constructor\n     * @param _lendingPool Address of lending pool.\n     * @param _rewardEligibleDataProvider EligibilityProvider address.\n     * @param _aaveOracle address.\n     * @param _lockZap address.\n     * @param _weth WETH address.\n     * @param _feePercent leveraging fee ratio.\n     * @param _treasury address.\n     */\n    constructor(\n        ILendingPool _lendingPool,\n        IEligibilityDataProvider _rewardEligibleDataProvider,\n        IAaveOracle _aaveOracle,\n        ILockZap _lockZap,\n        IWETH _weth,\n        uint256 _feePercent,\n        address _treasury\n    ) Ownable() {\n\n        require(address(_lendingPool) != (address(0)), 'Not a valid address');\n        require(address(_rewardEligibleDataProvider) != (address(0)), 'Not a valid address');\n        require(address(_aaveOracle) != (address(0)), 'Not a valid address');\n        require(address(_lockZap) != (address(0)), 'Not a valid address');\n        require(address(_weth) != (address(0)), 'Not a valid address');\n        require(_treasury != address(0), 'Not a valid address');\n        \n        lendingPool = _lendingPool;\n        eligibilityDataProvider = _rewardEligibleDataProvider;\n        lockZap = _lockZap;\n        aaveOracle = _aaveOracle;\n        weth = _weth;\n        feePercent = _feePercent;\n        treasury = _treasury;\n    }\n\n    /**\n    * @dev Only WETH contract is allowed to transfer ETH here. Prevent other addresses to send Ether to this contract.\n    */\n    receive() external payable {\n        require(msg.sender == address(weth), 'Receive not allowed');\n    }\n\n    /**\n    * @dev Revert fallback calls\n    */\n    fallback() external payable {\n        revert('Fallback not allowed');\n    }\n\n    /**\n     * @notice Sets fee ratio\n     * @param _feePercent fee ratio.\n     */\n    function setFeePercent(uint256 _feePercent) external onlyOwner {\n        require(_feePercent <= 1e4, \"Invalid ratio\");\n        feePercent = _feePercent; \n        emit FeePercentUpdated(_feePercent);\n    }\n\n    /**\n     * @notice Sets fee ratio\n     * @param _treasury address\n     */\n    function setTreasury(address _treasury) external onlyOwner {\n        treasury = _treasury;\n        emit TreasuryUpdated(_treasury);\n    }\n\n    /**\n     * @dev Returns the configuration of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The configuration of the reserve\n     **/\n    function getConfiguration(address asset) external view returns (DataTypes.ReserveConfigurationMap memory) {\n        return lendingPool.getConfiguration(asset);\n    }\n\n    /**\n     * @dev Returns variable debt token address of asset\n     * @param asset The address of the underlying asset of the reserve\n     * @return varaiableDebtToken address of the asset\n     **/\n    function getVDebtToken(address asset) public view returns (address) {\n        DataTypes.ReserveData memory reserveData = lendingPool.getReserveData(asset);\n        return reserveData.variableDebtTokenAddress;\n    }\n\n    /**\n     * @dev Returns loan to value\n     * @param asset The address of the underlying asset of the reserve\n     * @return ltv of the asset\n     **/\n    function ltv(address asset) public view returns (uint256) {\n        DataTypes.ReserveConfigurationMap memory conf =  lendingPool.getConfiguration(asset);\n        return conf.data % (2 ** 16);\n    }\n\n    /**\n     * @dev Loop the deposit and borrow of an asset\n     * @param asset for loop\n     * @param amount for the initial deposit\n     * @param interestRateMode stable or variable borrow mode\n     * @param borrowRatio Ratio of tokens to borrow\n     * @param loopCount Repeat count for loop\n     * @param isBorrow true when the loop without deposit tokens \n     **/\n    function loop(\n        address asset,\n        uint256 amount,\n        uint256 interestRateMode,\n        uint256 borrowRatio,\n        uint256 loopCount,\n        bool    isBorrow\n    ) external {\n        require(borrowRatio <= RATIO_DIVISOR, \"Invalid ratio\");\n        uint16 referralCode = 0;\n        uint256 fee;\n        if (!isBorrow) {\n            IERC20(asset).safeTransferFrom(msg.sender, address(this), amount);\n            fee = amount.mul(feePercent).div(RATIO_DIVISOR);\n            IERC20(asset).safeTransfer(treasury, fee);\n            amount = amount.sub(fee);\n        }\n        if (IERC20(asset).allowance(address(this), address(lendingPool)) == 0) {\n            IERC20(asset).safeApprove(address(lendingPool), type(uint256).max);\n        }\n        if (IERC20(asset).allowance(address(this), address(treasury)) == 0) {\n            IERC20(asset).safeApprove(treasury, type(uint256).max);\n        }\n\n        if (!isBorrow) {\n            lendingPool.deposit(asset, amount, msg.sender, referralCode);\n        }\n\n        for (uint256 i = 0; i < loopCount; i += 1) {\n            amount = amount.mul(borrowRatio).div(RATIO_DIVISOR);\n            lendingPool.borrow(asset, amount, interestRateMode, referralCode, msg.sender);\n\n            fee = amount.mul(feePercent).div(RATIO_DIVISOR);\n            IERC20(asset).safeTransfer(treasury, fee);\n            lendingPool.deposit(asset, amount.sub(fee), msg.sender, referralCode);\n        }\n            \n        zapWETHWithBorrow(wethToZap(msg.sender), msg.sender);\n    }\n\n    /**\n     * @dev Loop the deposit and borrow of ETH\n     * @param interestRateMode stable or variable borrow mode\n     * @param borrowRatio Ratio of tokens to borrow\n     * @param loopCount Repeat count for loop\n     **/\n    function loopETH(\n        uint256 interestRateMode,\n        uint256 borrowRatio,\n        uint256 loopCount\n    ) external payable {\n        uint16 referralCode = 0;\n        uint256 amount = msg.value;\n        if (IERC20(address(weth)).allowance(address(this), address(lendingPool)) == 0) {\n            IERC20(address(weth)).safeApprove(address(lendingPool), type(uint256).max);\n        }\n        if (IERC20(address(weth)).allowance(address(this), address(treasury)) == 0) {\n            IERC20(address(weth)).safeApprove(treasury, type(uint256).max);\n        }\n\n        uint256 fee = amount.mul(feePercent).div(RATIO_DIVISOR);\n        _safeTransferETH(treasury, fee);\n        \n        amount = amount.sub(fee);\n\n        weth.deposit{value: amount}();\n        lendingPool.deposit(address(weth), amount, msg.sender, referralCode);\n\n        for (uint256 i = 0; i < loopCount; i += 1) {\n            amount = amount.mul(borrowRatio).div(RATIO_DIVISOR);\n            lendingPool.borrow(address(weth), amount, interestRateMode, referralCode, msg.sender);\n            weth.withdraw(amount);\n\n            fee = amount.mul(feePercent).div(RATIO_DIVISOR);\n            _safeTransferETH(treasury, fee);\n\n            weth.deposit{value: amount.sub(fee)}();\n            lendingPool.deposit(address(weth), amount.sub(fee), msg.sender, referralCode);\n        }\n\n        zapWETHWithBorrow(wethToZap(msg.sender), msg.sender);\n    }\n\n    /**\n     * @notice Return estimated zap WETH amount for eligbility after loop.\n     * @param user for zap\n     * @param asset src token\n     * @param amount of `asset`\n     * @param borrowRatio Single ratio of borrow\n     * @param loopCount Repeat count for loop\n     **/\n    function wethToZapEstimation(address user, address asset, uint256 amount, uint256 borrowRatio, uint256 loopCount) external view returns (uint256) {\n        if (asset == API_ETH_MOCK_ADDRESS) {\n            asset = address(weth);\n        }\n        uint256 required = eligibilityDataProvider.requiredUsdValue(user);\n        uint256 locked = eligibilityDataProvider.lockedUsdValue(user);\n\n        uint256 fee = amount.mul(feePercent).div(RATIO_DIVISOR);\n        amount = amount.sub(fee);\n\n        required = required.add(requiredLocked(asset, amount));\n\n        for (uint256 i = 0; i < loopCount; i += 1) {\n            amount = amount.mul(borrowRatio).div(RATIO_DIVISOR);\n            fee = amount.mul(feePercent).div(RATIO_DIVISOR);\n            required = required.add(requiredLocked(asset, amount.sub(fee)));\n        }\n\n        if (locked >= required) {\n            return 0;\n        } else {\n            uint256 deltaUsdValue = required.sub(locked); //decimals === 8\n            uint256 wethPrice = aaveOracle.getAssetPrice(address(weth));\n            uint8 priceDecimal = IChainlinkAggregator(aaveOracle.getSourceOfAsset(address(weth))).decimals();\n            uint256 wethAmount = deltaUsdValue.mul(10 ** 18).mul(10 ** priceDecimal).div(wethPrice).div(10 ** 8);\n            wethAmount = wethAmount.add(wethAmount.mul(6).div(100));\n            return wethAmount;\n        }\n    }\n\n    /**\n     * @notice Return estimated zap WETH amount for eligbility.\n     * @param user for zap\n     **/\n    function wethToZap(address user) public view returns (uint256){\n        uint256 required = eligibilityDataProvider.requiredUsdValue(user);\n        uint256 locked = eligibilityDataProvider.lockedUsdValue(user);\n        if (locked >= required) {\n            return 0;\n        } else {\n            uint256 deltaUsdValue = required.sub(locked); //decimals === 8\n            uint256 wethPrice = aaveOracle.getAssetPrice(address(weth));\n            uint8 priceDecimal = IChainlinkAggregator(aaveOracle.getSourceOfAsset(address(weth))).decimals();\n            uint256 wethAmount = deltaUsdValue.mul(10 ** 18).mul(10 ** priceDecimal).div(wethPrice).div(10 ** 8);\n            wethAmount = wethAmount.add(wethAmount.mul(6).div(100));\n            return wethAmount;\n        }\n    }\n\n    /**\n     * @notice Zap WETH by borrowing.\n     * @param amount to zap\n     * @param borrower to zap\n     * @return liquidity amount by zapping\n     **/\n    function zapWETHWithBorrow(uint256 amount, address borrower) public returns (uint256 liquidity){\n        require(msg.sender == borrower || msg.sender == address(lendingPool));\n\n        if (amount > 0) {\n            uint16 referralCode = 0;\n            lendingPool.borrow(address(weth), amount, 2, referralCode, borrower);\n            if (IERC20(address(weth)).allowance(address(this), address(lockZap)) == 0) {\n                IERC20(address(weth)).safeApprove(address(lockZap), type(uint256).max);\n            }\n            liquidity = lockZap.zapOnBehalf(false, amount, 0, borrower);\n        }\n    }\n\n    /**\n     * @notice Returns required LP lock amount.\n     * @param asset underlyig asset\n     * @param amount of tokens\n     **/\n    function requiredLocked(address asset, uint256 amount) internal view returns (uint256) {\n        uint256 assetPrice = aaveOracle.getAssetPrice(asset);\n        uint8 assetDecimal = IERC20Detailed(asset).decimals();\n        uint256 requiredVal = assetPrice.mul(amount).div(10 ** assetDecimal).mul(eligibilityDataProvider.requiredDepositRatio()).div(eligibilityDataProvider.RATIO_DIVISOR());\n        return requiredVal;\n    }\n\n    /**\n    * @dev transfer ETH to an address, revert if it fails.\n    * @param to recipient of the transfer\n    * @param value the amount to send\n    */\n    function _safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, 'ETH_TRANSFER_FAILED');\n    }\n}"
    },
    "contracts/libraries/AddressPagination.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nlibrary AddressPagination {\n    function paginate(\n        address[] memory array,\n        uint256 page,\n        uint256 limit\n    ) internal pure returns (address[] memory result) {\n        result = new address[](limit);\n        for (uint256 i = 0; i < limit; i++) {\n            if (page * limit + i >= array.length) {\n                result[i] = address(0);\n            } else {\n                result[i] = array[page * limit + i];\n            }\n        }\n    }\n}\n"
    },
    "contracts/lock/Timelock.sol": {
      "content": "// SPDX-License-Identifier: NONE\n\npragma solidity 0.7.6;\n\nimport \"../dependencies/openzeppelin/contracts/SafeMath.sol\";\n\ncontract Timelock {\n    using SafeMath for uint;\n\n    event NewAdmin(address indexed newAdmin);\n    event NewPendingAdmin(address indexed newPendingAdmin);\n    event NewDelay(uint256 indexed newDelay);\n    event CancelTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);\n    event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);\n    event QueueTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);\n\n    uint256 public constant GRACE_PERIOD = 14 days;\n    uint256 public constant MINIMUM_DELAY = 2 seconds;\n    uint256 public constant MAXIMUM_DELAY = 30 days;\n\n    address public admin;\n    address public pendingAdmin;\n    uint256 public delay;\n\n    mapping (bytes32 => bool) public queuedTransactions;\n\n    constructor(address admin_, uint256 delay_) {\n        require(delay_ >= MINIMUM_DELAY, \"Timelock::constructor: Delay must exceed minimum delay.\");\n        require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n\n        admin = admin_;\n        delay = delay_;\n    }\n\n    receive() external payable {}\n\n    function setDelay(uint256 delay_) public {\n        require(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\");\n        require(delay_ >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\n        require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n        delay = delay_;\n\n        emit NewDelay(delay);\n    }\n\n    function acceptAdmin() public {\n        require(msg.sender == pendingAdmin, \"Timelock::acceptAdmin: Call must come from pendingAdmin.\");\n        admin = msg.sender;\n        pendingAdmin = address(0);\n\n        emit NewAdmin(admin);\n    }\n\n    function setPendingAdmin(address pendingAdmin_) public {\n        require(msg.sender == address(this), \"Timelock::setPendingAdmin: Call must come from Timelock.\");\n        pendingAdmin = pendingAdmin_;\n\n        emit NewPendingAdmin(pendingAdmin);\n    }\n\n    function queueTransaction(address target, uint256 value, string memory signature, bytes memory data, uint256 eta) public returns (bytes32) {\n        require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\n        require(eta >= getBlockTimestamp().add(delay), \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = true;\n\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\n        return txHash;\n    }\n\n    function cancelTransaction(address target, uint256 value, string memory signature, bytes memory data, uint256 eta) public {\n        require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = false;\n\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\n    }\n\n    function executeTransaction(address target, uint256 value, string memory signature, bytes memory data, uint256 eta) public payable returns (bytes memory) {\n        require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\n        require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\n        require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\n\n        queuedTransactions[txHash] = false;\n\n        bytes memory callData;\n\n        if (bytes(signature).length == 0) {\n            callData = data;\n        } else {\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n        }\n\n        // solium-disable-next-line security/no-call-value\n        (bool success, bytes memory returnData) = target.call{value: value}(callData);\n        require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\n\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n        return returnData;\n    }\n\n    function getBlockTimestamp() internal view returns (uint) {\n        // solium-disable-next-line security/no-block-members\n        return block.timestamp;\n    }\n}"
    },
    "contracts/misc/AaveOracle.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\nimport {Ownable} from '../dependencies/openzeppelin/contracts/Ownable.sol';\nimport {IERC20} from '../dependencies/openzeppelin/contracts/IERC20.sol';\n\nimport {IPriceOracleGetter} from '../interfaces/IPriceOracleGetter.sol';\nimport {IChainlinkAggregator} from '../interfaces/IChainlinkAggregator.sol';\nimport {SafeERC20} from '../dependencies/openzeppelin/contracts/SafeERC20.sol';\n\n/// @title AaveOracle\n/// @author Aave\n/// @notice Proxy smart contract to get the price of an asset from a price source, with Chainlink Aggregator\n///         smart contracts as primary option\n/// - If the returned price by a Chainlink aggregator is <= 0, the call is forwarded to a fallbackOracle\n/// - Owned by the Aave governance system, allowed to add sources for assets, replace them\n///   and change the fallbackOracle\ncontract AaveOracle is IPriceOracleGetter, Ownable {\n  using SafeERC20 for IERC20;\n\n  event BaseCurrencySet(address indexed baseCurrency, uint256 baseCurrencyUnit);\n  event AssetSourceUpdated(address indexed asset, address indexed source);\n  event FallbackOracleUpdated(address indexed fallbackOracle);\n\n  mapping(address => IChainlinkAggregator) private assetsSources;\n  IPriceOracleGetter private _fallbackOracle;\n  address public immutable BASE_CURRENCY;\n  uint256 public immutable BASE_CURRENCY_UNIT;\n\n  /// @notice Constructor\n  /// @param assets The addresses of the assets\n  /// @param sources The address of the source of each asset\n  /// @param fallbackOracle The address of the fallback oracle to use if the data of an\n  ///        aggregator is not consistent\n  /// @param baseCurrency the base currency used for the price quotes. If USD is used, base currency is 0x0\n  /// @param baseCurrencyUnit the unit of the base currency\n  constructor(\n    address[] memory assets,\n    address[] memory sources,\n    address fallbackOracle,\n    address baseCurrency,\n    uint256 baseCurrencyUnit\n  ) {\n    _setFallbackOracle(fallbackOracle);\n    _setAssetsSources(assets, sources);\n    BASE_CURRENCY = baseCurrency;\n    BASE_CURRENCY_UNIT = baseCurrencyUnit;\n    emit BaseCurrencySet(baseCurrency, baseCurrencyUnit);\n  }\n\n  /// @notice External function called by the Aave governance to set or replace sources of assets\n  /// @param assets The addresses of the assets\n  /// @param sources The address of the source of each asset\n  function setAssetSources(address[] calldata assets, address[] calldata sources)\n    external\n    onlyOwner\n  {\n    _setAssetsSources(assets, sources);\n  }\n\n  /// @notice Sets the fallbackOracle\n  /// - Callable only by the Aave governance\n  /// @param fallbackOracle The address of the fallbackOracle\n  function setFallbackOracle(address fallbackOracle) external onlyOwner {\n    _setFallbackOracle(fallbackOracle);\n  }\n\n  /// @notice Internal function to set the sources for each asset\n  /// @param assets The addresses of the assets\n  /// @param sources The address of the source of each asset\n  function _setAssetsSources(address[] memory assets, address[] memory sources) internal {\n    require(assets.length == sources.length, 'INCONSISTENT_PARAMS_LENGTH');\n    for (uint256 i = 0; i < assets.length; i++) {\n      assetsSources[assets[i]] = IChainlinkAggregator(sources[i]);\n      emit AssetSourceUpdated(assets[i], sources[i]);\n    }\n  }\n\n  /// @notice Internal function to set the fallbackOracle\n  /// @param fallbackOracle The address of the fallbackOracle\n  function _setFallbackOracle(address fallbackOracle) internal {\n    _fallbackOracle = IPriceOracleGetter(fallbackOracle);\n    emit FallbackOracleUpdated(fallbackOracle);\n  }\n\n  /// @notice Gets an asset price by address\n  /// @param asset The asset address\n  function getAssetPrice(address asset) public view override returns (uint256) {\n    IChainlinkAggregator source = assetsSources[asset];\n\n    if (asset == BASE_CURRENCY) {\n      return BASE_CURRENCY_UNIT;\n    } else if (address(source) == address(0)) {\n      return _fallbackOracle.getAssetPrice(asset);\n    } else {\n      int256 price = IChainlinkAggregator(source).latestAnswer();\n      if (price > 0) {\n        return uint256(price);\n      } else {\n        return _fallbackOracle.getAssetPrice(asset);\n      }\n    }\n  }\n\n  /// @notice Gets a list of prices from a list of assets addresses\n  /// @param assets The list of assets addresses\n  function getAssetsPrices(address[] calldata assets) external view returns (uint256[] memory) {\n    uint256[] memory prices = new uint256[](assets.length);\n    for (uint256 i = 0; i < assets.length; i++) {\n      prices[i] = getAssetPrice(assets[i]);\n    }\n    return prices;\n  }\n\n  /// @notice Gets the address of the source for an asset address\n  /// @param asset The address of the asset\n  /// @return address The address of the source\n  function getSourceOfAsset(address asset) external view returns (address) {\n    return address(assetsSources[asset]);\n  }\n\n  /// @notice Gets the address of the fallback oracle\n  /// @return address The addres of the fallback oracle\n  function getFallbackOracle() external view returns (address) {\n    return address(_fallbackOracle);\n  }\n}\n"
    },
    "contracts/misc/AaveProtocolDataProvider.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {IERC20Detailed} from '../dependencies/openzeppelin/contracts/IERC20Detailed.sol';\nimport {ILendingPoolAddressesProvider} from '../interfaces/ILendingPoolAddressesProvider.sol';\nimport {ILendingPool} from '../interfaces/ILendingPool.sol';\nimport {IStableDebtToken} from '../interfaces/IStableDebtToken.sol';\nimport {IVariableDebtToken} from '../interfaces/IVariableDebtToken.sol';\nimport {ReserveConfiguration} from '../protocol/libraries/configuration/ReserveConfiguration.sol';\nimport {UserConfiguration} from '../protocol/libraries/configuration/UserConfiguration.sol';\nimport {DataTypes} from '../protocol/libraries/types/DataTypes.sol';\n\ncontract AaveProtocolDataProvider {\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using UserConfiguration for DataTypes.UserConfigurationMap;\n\n  address constant MKR = 0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2;\n  address constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n  struct TokenData {\n    string symbol;\n    address tokenAddress;\n  }\n\n  ILendingPoolAddressesProvider public immutable ADDRESSES_PROVIDER;\n\n  constructor(ILendingPoolAddressesProvider addressesProvider) {\n    ADDRESSES_PROVIDER = addressesProvider;\n  }\n\n  function getAllReservesTokens() external view returns (TokenData[] memory) {\n    ILendingPool pool = ILendingPool(ADDRESSES_PROVIDER.getLendingPool());\n    address[] memory reserves = pool.getReservesList();\n    TokenData[] memory reservesTokens = new TokenData[](reserves.length);\n    for (uint256 i = 0; i < reserves.length; i++) {\n      if (reserves[i] == MKR) {\n        reservesTokens[i] = TokenData({symbol: 'MKR', tokenAddress: reserves[i]});\n        continue;\n      }\n      if (reserves[i] == ETH) {\n        reservesTokens[i] = TokenData({symbol: 'ETH', tokenAddress: reserves[i]});\n        continue;\n      }\n      reservesTokens[i] = TokenData({\n        symbol: IERC20Detailed(reserves[i]).symbol(),\n        tokenAddress: reserves[i]\n      });\n    }\n    return reservesTokens;\n  }\n\n  function getAllATokens() external view returns (TokenData[] memory) {\n    ILendingPool pool = ILendingPool(ADDRESSES_PROVIDER.getLendingPool());\n    address[] memory reserves = pool.getReservesList();\n    TokenData[] memory aTokens = new TokenData[](reserves.length);\n    for (uint256 i = 0; i < reserves.length; i++) {\n      DataTypes.ReserveData memory reserveData = pool.getReserveData(reserves[i]);\n      aTokens[i] = TokenData({\n        symbol: IERC20Detailed(reserveData.aTokenAddress).symbol(),\n        tokenAddress: reserveData.aTokenAddress\n      });\n    }\n    return aTokens;\n  }\n\n  function getReserveConfigurationData(address asset)\n    external\n    view\n    returns (\n      uint256 decimals,\n      uint256 ltv,\n      uint256 liquidationThreshold,\n      uint256 liquidationBonus,\n      uint256 reserveFactor,\n      bool usageAsCollateralEnabled,\n      bool borrowingEnabled,\n      bool stableBorrowRateEnabled,\n      bool isActive,\n      bool isFrozen\n    )\n  {\n    DataTypes.ReserveConfigurationMap memory configuration =\n      ILendingPool(ADDRESSES_PROVIDER.getLendingPool()).getConfiguration(asset);\n\n    (ltv, liquidationThreshold, liquidationBonus, decimals, reserveFactor) = configuration\n      .getParamsMemory();\n\n    (isActive, isFrozen, borrowingEnabled, stableBorrowRateEnabled) = configuration\n      .getFlagsMemory();\n\n    usageAsCollateralEnabled = liquidationThreshold > 0;\n  }\n\n  function getReserveData(address asset)\n    external\n    view\n    returns (\n      uint256 availableLiquidity,\n      uint256 totalStableDebt,\n      uint256 totalVariableDebt,\n      uint256 liquidityRate,\n      uint256 variableBorrowRate,\n      uint256 stableBorrowRate,\n      uint256 averageStableBorrowRate,\n      uint256 liquidityIndex,\n      uint256 variableBorrowIndex,\n      uint40 lastUpdateTimestamp\n    )\n  {\n    DataTypes.ReserveData memory reserve =\n      ILendingPool(ADDRESSES_PROVIDER.getLendingPool()).getReserveData(asset);\n\n    return (\n      IERC20Detailed(asset).balanceOf(reserve.aTokenAddress),\n      IERC20Detailed(reserve.stableDebtTokenAddress).totalSupply(),\n      IERC20Detailed(reserve.variableDebtTokenAddress).totalSupply(),\n      reserve.currentLiquidityRate,\n      reserve.currentVariableBorrowRate,\n      reserve.currentStableBorrowRate,\n      IStableDebtToken(reserve.stableDebtTokenAddress).getAverageStableRate(),\n      reserve.liquidityIndex,\n      reserve.variableBorrowIndex,\n      reserve.lastUpdateTimestamp\n    );\n  }\n\n  function getUserReserveData(address asset, address user)\n    external\n    view\n    returns (\n      uint256 currentATokenBalance,\n      uint256 currentStableDebt,\n      uint256 currentVariableDebt,\n      uint256 principalStableDebt,\n      uint256 scaledVariableDebt,\n      uint256 stableBorrowRate,\n      uint256 liquidityRate,\n      uint40 stableRateLastUpdated,\n      bool usageAsCollateralEnabled\n    )\n  {\n    DataTypes.ReserveData memory reserve =\n      ILendingPool(ADDRESSES_PROVIDER.getLendingPool()).getReserveData(asset);\n\n    DataTypes.UserConfigurationMap memory userConfig =\n      ILendingPool(ADDRESSES_PROVIDER.getLendingPool()).getUserConfiguration(user);\n\n    currentATokenBalance = IERC20Detailed(reserve.aTokenAddress).balanceOf(user);\n    currentVariableDebt = IERC20Detailed(reserve.variableDebtTokenAddress).balanceOf(user);\n    currentStableDebt = IERC20Detailed(reserve.stableDebtTokenAddress).balanceOf(user);\n    principalStableDebt = IStableDebtToken(reserve.stableDebtTokenAddress).principalBalanceOf(user);\n    scaledVariableDebt = IVariableDebtToken(reserve.variableDebtTokenAddress).scaledBalanceOf(user);\n    liquidityRate = reserve.currentLiquidityRate;\n    stableBorrowRate = IStableDebtToken(reserve.stableDebtTokenAddress).getUserStableRate(user);\n    stableRateLastUpdated = IStableDebtToken(reserve.stableDebtTokenAddress).getUserLastUpdated(\n      user\n    );\n    usageAsCollateralEnabled = userConfig.isUsingAsCollateral(reserve.id);\n  }\n\n  function getReserveTokensAddresses(address asset)\n    external\n    view\n    returns (\n      address aTokenAddress,\n      address stableDebtTokenAddress,\n      address variableDebtTokenAddress\n    )\n  {\n    DataTypes.ReserveData memory reserve =\n      ILendingPool(ADDRESSES_PROVIDER.getLendingPool()).getReserveData(asset);\n\n    return (\n      reserve.aTokenAddress,\n      reserve.stableDebtTokenAddress,\n      reserve.variableDebtTokenAddress\n    );\n  }\n}\n"
    },
    "contracts/misc/interfaces/IAaveOracle.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\n/**\n * @title IAaveOracle interface\n * @notice Interface for the Aave oracle.\n **/\n\ninterface IAaveOracle {\n  function BASE_CURRENCY() external view returns (address); // if usd returns 0x0, if eth returns weth address\n  function BASE_CURRENCY_UNIT() external view returns (uint256);\n\n  /***********\n    @dev returns the asset price in ETH\n     */\n  function getAssetPrice(address asset) external view returns (uint256);\n  function getSourceOfAsset(address asset) external view returns (address);\n}"
    },
    "contracts/misc/interfaces/IERC20DetailedBytes.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\nimport {IERC20} from '../../dependencies/openzeppelin/contracts/IERC20.sol';\n\ninterface IERC20DetailedBytes is IERC20 {\n  function name() external view returns (bytes32);\n\n  function symbol() external view returns (bytes32);\n\n  function decimals() external view returns (uint8);\n}"
    },
    "contracts/misc/interfaces/IUiPoolDataProvider.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {ILendingPoolAddressesProvider} from '../../interfaces/ILendingPoolAddressesProvider.sol';\nimport {IAaveIncentivesController} from '../../interfaces/IAaveIncentivesController.sol';\n\ninterface IUiPoolDataProvider {\n  struct AggregatedReserveData {\n    address underlyingAsset;\n    string name;\n    string symbol;\n    uint256 decimals;\n    uint256 baseLTVasCollateral;\n    uint256 reserveLiquidationThreshold;\n    uint256 reserveLiquidationBonus;\n    uint256 reserveFactor;\n    bool usageAsCollateralEnabled;\n    bool borrowingEnabled;\n    bool stableBorrowRateEnabled;\n    bool isActive;\n    bool isFrozen;\n    // base data\n    uint128 liquidityIndex;\n    uint128 variableBorrowIndex;\n    uint128 liquidityRate;\n    uint128 variableBorrowRate;\n    uint128 stableBorrowRate;\n    uint40 lastUpdateTimestamp;\n    address aTokenAddress;\n    address stableDebtTokenAddress;\n    address variableDebtTokenAddress;\n    address interestRateStrategyAddress;\n    //\n    uint256 availableLiquidity;\n    uint256 totalPrincipalStableDebt;\n    uint256 averageStableRate;\n    uint256 stableDebtLastUpdateTimestamp;\n    uint256 totalScaledVariableDebt;\n    uint256 priceInEth;\n    uint256 variableRateSlope1;\n    uint256 variableRateSlope2;\n    uint256 stableRateSlope1;\n    uint256 stableRateSlope2;\n    // incentives\n    uint256 aEmissionPerSecond;\n    uint256 vEmissionPerSecond;\n    uint256 sEmissionPerSecond;\n    uint256 aIncentivesLastUpdateTimestamp;\n    uint256 vIncentivesLastUpdateTimestamp;\n    uint256 sIncentivesLastUpdateTimestamp;\n    uint256 aTokenIncentivesIndex;\n    uint256 vTokenIncentivesIndex;\n    uint256 sTokenIncentivesIndex;\n  }\n\n  struct UserReserveData {\n    address underlyingAsset;\n    uint256 scaledATokenBalance;\n    bool usageAsCollateralEnabledOnUser;\n    uint256 stableBorrowRate;\n    uint256 scaledVariableDebt;\n    uint256 principalStableDebt;\n    uint256 stableBorrowLastUpdateTimestamp;\n    // incentives\n    uint256 aTokenincentivesUserIndex;\n    uint256 vTokenincentivesUserIndex;\n    uint256 sTokenincentivesUserIndex;\n  }\n\n  struct IncentivesControllerData {\n    uint256 userUnclaimedRewards;\n    uint256 emissionEndTimestamp;\n  }\n\n\n  function getReservesData(ILendingPoolAddressesProvider provider, address user)\n    external\n    view\n    returns (\n      AggregatedReserveData[] memory,\n      UserReserveData[] memory,\n      uint256,\n      IncentivesControllerData memory\n    );\n}\n"
    },
    "contracts/misc/interfaces/IUiPoolDataProviderV3.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {ILendingPoolAddressesProvider} from '../../interfaces/ILendingPoolAddressesProvider.sol';\n\ninterface IUiPoolDataProviderV3 {\n  struct AggregatedReserveData {\n    address underlyingAsset;\n    string name;\n    string symbol;\n    uint256 decimals;\n    uint256 baseLTVasCollateral;\n    uint256 reserveLiquidationThreshold;\n    uint256 reserveLiquidationBonus;\n    uint256 reserveFactor;\n    bool usageAsCollateralEnabled;\n    bool borrowingEnabled;\n    bool stableBorrowRateEnabled;\n    bool isActive;\n    bool isFrozen;\n    // base data\n    uint128 liquidityIndex;\n    uint128 variableBorrowIndex;\n    uint128 liquidityRate;\n    uint128 variableBorrowRate;\n    uint128 stableBorrowRate;\n    uint40 lastUpdateTimestamp;\n    address aTokenAddress;\n    address stableDebtTokenAddress;\n    address variableDebtTokenAddress;\n    address interestRateStrategyAddress;\n    //\n    uint256 availableLiquidity;\n    uint256 totalPrincipalStableDebt;\n    uint256 averageStableRate;\n    uint256 stableDebtLastUpdateTimestamp;\n    uint256 totalScaledVariableDebt;\n    uint256 priceInMarketReferenceCurrency;\n    uint256 variableRateSlope1;\n    uint256 variableRateSlope2;\n    uint256 stableRateSlope1;\n    uint256 stableRateSlope2;\n    // v3\n    bool isPaused;\n    uint128 accruedToTreasury;\n    uint128 unbacked;\n    uint128 isolationModeTotalDebt;\n    //\n    uint256 debtCeiling;\n    uint256 debtCeilingDecimals;\n    uint8 eModeCategoryId;\n    uint256 borrowCap;\n    uint256 supplyCap; \n    // eMode\n    uint16 eModeLtv;\n    uint16 eModeLiquidationThreshold;\n    uint16 eModeLiquidationBonus;\n    address eModePriceSource;\n    string eModeLabel;\n    bool borrowableInIsolation;\n  }\n\n  struct UserReserveData {\n    address underlyingAsset;\n    uint256 scaledATokenBalance;\n    bool usageAsCollateralEnabledOnUser;\n    uint256 stableBorrowRate;\n    uint256 scaledVariableDebt;\n    uint256 principalStableDebt;\n    uint256 stableBorrowLastUpdateTimestamp;\n  }\n\n  struct BaseCurrencyInfo {\n    uint256 marketReferenceCurrencyUnit;\n    int256 marketReferenceCurrencyPriceInUsd;\n    int256 networkBaseTokenPriceInUsd;\n    uint8 networkBaseTokenPriceDecimals;\n  }\n\n  function getReservesList(ILendingPoolAddressesProvider provider)\n    external\n    view\n    returns (address[] memory);\n\n  function getReservesData(ILendingPoolAddressesProvider provider)\n    external\n    view\n    returns (\n      AggregatedReserveData[] memory,\n      BaseCurrencyInfo memory\n    );\n\n  function getUserReservesData(ILendingPoolAddressesProvider provider, address user)\n    external\n    view\n    returns (\n      UserReserveData[] memory, uint8\n    );\n}"
    },
    "contracts/misc/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\ninterface IWETH {\n  function balanceOf(address) external returns (uint);\n  function deposit() external payable;\n\n  function withdraw(uint256) external;\n\n  function approve(address guy, uint256 wad) external returns (bool);\n\n  function transferFrom(\n    address src,\n    address dst,\n    uint256 wad\n  ) external returns (bool);\n\n  function transfer(address to, uint value) external returns (bool);\n}\n"
    },
    "contracts/misc/interfaces/IWETHGateway.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\ninterface IWETHGateway {\n  function depositETH(\n    address lendingPool,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external payable;\n\n  function withdrawETH(\n    address lendingPool,\n    uint256 amount,\n    address onBehalfOf\n  ) external;\n\n  function repayETH(\n    address lendingPool,\n    uint256 amount,\n    uint256 rateMode,\n    address onBehalfOf\n  ) external payable;\n\n  function borrowETH(\n    address lendingPool,\n    uint256 amount,\n    uint256 interesRateMode,\n    uint16 referralCode\n  ) external;\n}\n"
    },
    "contracts/misc/UiPoolDataProvider.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {IERC20Detailed} from '../dependencies/openzeppelin/contracts/IERC20Detailed.sol';\nimport {ILendingPoolAddressesProvider} from '../interfaces/ILendingPoolAddressesProvider.sol';\nimport {IAaveIncentivesController} from '../interfaces/IAaveIncentivesController.sol';\nimport {IUiPoolDataProvider} from './interfaces/IUiPoolDataProvider.sol';\nimport {ILendingPool} from '../interfaces/ILendingPool.sol';\nimport {IPriceOracleGetter} from '../interfaces/IPriceOracleGetter.sol';\nimport {IAToken} from '../interfaces/IAToken.sol';\nimport {IVariableDebtToken} from '../interfaces/IVariableDebtToken.sol';\nimport {IStableDebtToken} from '../interfaces/IStableDebtToken.sol';\nimport {WadRayMath} from '../protocol/libraries/math/WadRayMath.sol';\nimport {ReserveConfiguration} from '../protocol/libraries/configuration/ReserveConfiguration.sol';\nimport {UserConfiguration} from '../protocol/libraries/configuration/UserConfiguration.sol';\nimport {DataTypes} from '../protocol/libraries/types/DataTypes.sol';\nimport {\n  DefaultReserveInterestRateStrategy\n} from '../protocol/lendingpool/DefaultReserveInterestRateStrategy.sol';\n\ncontract UiPoolDataProvider is IUiPoolDataProvider {\n  using WadRayMath for uint256;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using UserConfiguration for DataTypes.UserConfigurationMap;\n\n  address public constant MOCK_USD_ADDRESS = 0x10F7Fc1F91Ba351f9C629c5947AD69bD03C05b96;\n  IAaveIncentivesController public immutable incentivesController;\n  IPriceOracleGetter public immutable oracle;\n\n  constructor(IAaveIncentivesController _incentivesController, IPriceOracleGetter _oracle) {\n    incentivesController = _incentivesController;\n    oracle = _oracle;\n  }\n\n  function getInterestRateStrategySlopes(DefaultReserveInterestRateStrategy interestRateStrategy)\n    internal\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    return (\n      interestRateStrategy.variableRateSlope1(),\n      interestRateStrategy.variableRateSlope2(),\n      interestRateStrategy.stableRateSlope1(),\n      interestRateStrategy.stableRateSlope2()\n    );\n  }\n\n  function getReservesData(ILendingPoolAddressesProvider provider, address user)\n    external\n    view\n    override\n    returns (\n      AggregatedReserveData[] memory,\n      UserReserveData[] memory,\n      uint256,\n      IncentivesControllerData memory\n    )\n  {\n    ILendingPool lendingPool = ILendingPool(provider.getLendingPool());\n    address[] memory reserves = lendingPool.getReservesList();\n    DataTypes.UserConfigurationMap memory userConfig = lendingPool.getUserConfiguration(user);\n\n    AggregatedReserveData[] memory reservesData = new AggregatedReserveData[](reserves.length);\n    UserReserveData[] memory userReservesData =\n      new UserReserveData[](user != address(0) ? reserves.length : 0);\n\n    for (uint256 i = 0; i < reserves.length; i++) {\n      AggregatedReserveData memory reserveData = reservesData[i];\n      reserveData.underlyingAsset = reserves[i];\n\n      // reserve current state\n      DataTypes.ReserveData memory baseData =\n        lendingPool.getReserveData(reserveData.underlyingAsset);\n      reserveData.liquidityIndex = baseData.liquidityIndex;\n      reserveData.variableBorrowIndex = baseData.variableBorrowIndex;\n      reserveData.liquidityRate = baseData.currentLiquidityRate;\n      reserveData.variableBorrowRate = baseData.currentVariableBorrowRate;\n      reserveData.stableBorrowRate = baseData.currentStableBorrowRate;\n      reserveData.lastUpdateTimestamp = baseData.lastUpdateTimestamp;\n      reserveData.aTokenAddress = baseData.aTokenAddress;\n      reserveData.stableDebtTokenAddress = baseData.stableDebtTokenAddress;\n      reserveData.variableDebtTokenAddress = baseData.variableDebtTokenAddress;\n      reserveData.interestRateStrategyAddress = baseData.interestRateStrategyAddress;\n      reserveData.priceInEth = oracle.getAssetPrice(reserveData.underlyingAsset);\n\n      reserveData.availableLiquidity = IERC20Detailed(reserveData.underlyingAsset).balanceOf(\n        reserveData.aTokenAddress\n      );\n      (\n        reserveData.totalPrincipalStableDebt,\n        ,\n        reserveData.averageStableRate,\n        reserveData.stableDebtLastUpdateTimestamp\n      ) = IStableDebtToken(reserveData.stableDebtTokenAddress).getSupplyData();\n      reserveData.totalScaledVariableDebt = IVariableDebtToken(reserveData.variableDebtTokenAddress)\n        .scaledTotalSupply();\n\n      // reserve configuration\n\n      // we're getting this info from the aToken, because some of assets can be not compliant with ETC20Detailed\n      reserveData.symbol = IERC20Detailed(reserveData.aTokenAddress).symbol();\n      reserveData.name = '';\n\n      (\n        reserveData.baseLTVasCollateral,\n        reserveData.reserveLiquidationThreshold,\n        reserveData.reserveLiquidationBonus,\n        reserveData.decimals,\n        reserveData.reserveFactor\n      ) = baseData.configuration.getParamsMemory();\n      (\n        reserveData.isActive,\n        reserveData.isFrozen,\n        reserveData.borrowingEnabled,\n        reserveData.stableBorrowRateEnabled\n      ) = baseData.configuration.getFlagsMemory();\n      reserveData.usageAsCollateralEnabled = reserveData.baseLTVasCollateral != 0;\n      (\n        reserveData.variableRateSlope1,\n        reserveData.variableRateSlope2,\n        reserveData.stableRateSlope1,\n        reserveData.stableRateSlope2\n      ) = getInterestRateStrategySlopes(\n        DefaultReserveInterestRateStrategy(reserveData.interestRateStrategyAddress)\n      );\n\n      // incentives\n      if (address(0) != address(incentivesController)) {\n        (\n          reserveData.aTokenIncentivesIndex,\n          reserveData.aEmissionPerSecond,\n          reserveData.aIncentivesLastUpdateTimestamp\n        ) = incentivesController.getAssetData(reserveData.aTokenAddress);\n\n        (\n          reserveData.sTokenIncentivesIndex,\n          reserveData.sEmissionPerSecond,\n          reserveData.sIncentivesLastUpdateTimestamp\n        ) = incentivesController.getAssetData(reserveData.stableDebtTokenAddress);\n\n        (\n          reserveData.vTokenIncentivesIndex,\n          reserveData.vEmissionPerSecond,\n          reserveData.vIncentivesLastUpdateTimestamp\n        ) = incentivesController.getAssetData(reserveData.variableDebtTokenAddress);\n      }\n\n      if (user != address(0)) {\n        // incentives\n        if (address(0) != address(incentivesController)) {\n          userReservesData[i].aTokenincentivesUserIndex = incentivesController.getUserAssetData(\n            user,\n            reserveData.aTokenAddress\n          );\n          userReservesData[i].vTokenincentivesUserIndex = incentivesController.getUserAssetData(\n            user,\n            reserveData.variableDebtTokenAddress\n          );\n          userReservesData[i].sTokenincentivesUserIndex = incentivesController.getUserAssetData(\n            user,\n            reserveData.stableDebtTokenAddress\n          );\n        }\n        // user reserve data\n        userReservesData[i].underlyingAsset = reserveData.underlyingAsset;\n        userReservesData[i].scaledATokenBalance = IAToken(reserveData.aTokenAddress)\n          .scaledBalanceOf(user);\n        userReservesData[i].usageAsCollateralEnabledOnUser = userConfig.isUsingAsCollateral(i);\n\n        if (userConfig.isBorrowing(i)) {\n          userReservesData[i].scaledVariableDebt = IVariableDebtToken(\n            reserveData\n              .variableDebtTokenAddress\n          )\n            .scaledBalanceOf(user);\n          userReservesData[i].principalStableDebt = IStableDebtToken(\n            reserveData\n              .stableDebtTokenAddress\n          )\n            .principalBalanceOf(user);\n          if (userReservesData[i].principalStableDebt != 0) {\n            userReservesData[i].stableBorrowRate = IStableDebtToken(\n              reserveData\n                .stableDebtTokenAddress\n            )\n              .getUserStableRate(user);\n            userReservesData[i].stableBorrowLastUpdateTimestamp = IStableDebtToken(\n              reserveData\n                .stableDebtTokenAddress\n            )\n              .getUserLastUpdated(user);\n          }\n        }\n      }\n    }\n\n\n    IncentivesControllerData memory incentivesControllerData;\n\n    if (address(0) != address(incentivesController)) {\n      if (user != address(0)) {\n        incentivesControllerData.userUnclaimedRewards = incentivesController.getUserUnclaimedRewards(user);\n      }\n      incentivesControllerData.emissionEndTimestamp = incentivesController.DISTRIBUTION_END();\n    }\n\n    return (\n      reservesData,\n      userReservesData,\n      10 ** 8,\n      incentivesControllerData\n    );\n  }\n}\n"
    },
    "contracts/misc/UiPoolDataProviderV2V3.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {IERC20Detailed} from '../dependencies/openzeppelin/contracts/IERC20Detailed.sol';\nimport {ILendingPoolAddressesProvider} from '../interfaces/ILendingPoolAddressesProvider.sol';\nimport {IUiPoolDataProviderV3} from './interfaces/IUiPoolDataProviderV3.sol';\nimport {ILendingPool} from '../interfaces/ILendingPool.sol';\nimport {IAaveOracle} from './interfaces/IAaveOracle.sol';\nimport {IAToken} from '../interfaces/IAToken.sol';\nimport {IVariableDebtToken} from '../interfaces/IVariableDebtToken.sol';\nimport {IStableDebtToken} from '../interfaces/IStableDebtToken.sol';\nimport {WadRayMath} from '../protocol/libraries/math/WadRayMath.sol';\nimport {ReserveConfiguration} from '../protocol/libraries/configuration/ReserveConfiguration.sol';\nimport {UserConfiguration} from '../protocol/libraries/configuration/UserConfiguration.sol';\nimport {DataTypes} from '../protocol/libraries/types/DataTypes.sol';\nimport {IChainlinkAggregator} from '../interfaces/IChainlinkAggregator.sol';\nimport {DefaultReserveInterestRateStrategy} from '../protocol/lendingpool/DefaultReserveInterestRateStrategy.sol';\nimport {IERC20DetailedBytes} from './interfaces/IERC20DetailedBytes.sol';\n\ncontract UiPoolDataProviderV2V3 is IUiPoolDataProviderV3 {\n  using WadRayMath for uint256;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using UserConfiguration for DataTypes.UserConfigurationMap;\n\n  IChainlinkAggregator public immutable networkBaseTokenPriceInUsdProxyAggregator;\n  IChainlinkAggregator public immutable marketReferenceCurrencyPriceInUsdProxyAggregator;\n  uint256 public constant ETH_CURRENCY_UNIT = 1 ether;\n  address public constant MKRAddress = 0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2;\n\n  constructor(\n    IChainlinkAggregator _networkBaseTokenPriceInUsdProxyAggregator,\n    IChainlinkAggregator _marketReferenceCurrencyPriceInUsdProxyAggregator\n  ) {\n    networkBaseTokenPriceInUsdProxyAggregator = _networkBaseTokenPriceInUsdProxyAggregator;\n    marketReferenceCurrencyPriceInUsdProxyAggregator = _marketReferenceCurrencyPriceInUsdProxyAggregator;\n  }\n\n  function getInterestRateStrategySlopes(DefaultReserveInterestRateStrategy interestRateStrategy)\n    internal\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    return (\n      interestRateStrategy.variableRateSlope1(),\n      interestRateStrategy.variableRateSlope2(),\n      interestRateStrategy.stableRateSlope1(),\n      interestRateStrategy.stableRateSlope2()\n    );\n  }\n\n  function getReservesList(ILendingPoolAddressesProvider provider)\n    public\n    view\n    override\n    returns (address[] memory)\n  {\n    ILendingPool lendingPool = ILendingPool(provider.getLendingPool());\n    return lendingPool.getReservesList();\n  }\n\n  function getReservesData(ILendingPoolAddressesProvider provider)\n    public\n    view\n    override\n    returns (AggregatedReserveData[] memory, BaseCurrencyInfo memory)\n  {\n    IAaveOracle oracle = IAaveOracle(provider.getPriceOracle());\n    ILendingPool lendingPool = ILendingPool(provider.getLendingPool());\n    address[] memory reserves = lendingPool.getReservesList();\n    AggregatedReserveData[] memory reservesData = new AggregatedReserveData[](reserves.length);\n\n    for (uint256 i = 0; i < reserves.length; i++) {\n      AggregatedReserveData memory reserveData = reservesData[i];\n      reserveData.underlyingAsset = reserves[i];\n\n      // reserve current state\n      DataTypes.ReserveData memory baseData = lendingPool.getReserveData(\n        reserveData.underlyingAsset\n      );\n      reserveData.liquidityIndex = baseData.liquidityIndex;\n      reserveData.variableBorrowIndex = baseData.variableBorrowIndex;\n      reserveData.liquidityRate = baseData.currentLiquidityRate;\n      reserveData.variableBorrowRate = baseData.currentVariableBorrowRate;\n      reserveData.stableBorrowRate = baseData.currentStableBorrowRate;\n      reserveData.lastUpdateTimestamp = baseData.lastUpdateTimestamp;\n      reserveData.aTokenAddress = baseData.aTokenAddress;\n      reserveData.stableDebtTokenAddress = baseData.stableDebtTokenAddress;\n      reserveData.variableDebtTokenAddress = baseData.variableDebtTokenAddress;\n      reserveData.interestRateStrategyAddress = baseData.interestRateStrategyAddress;\n      reserveData.priceInMarketReferenceCurrency = oracle.getAssetPrice(\n        reserveData.underlyingAsset\n      );\n\n      reserveData.availableLiquidity = IERC20Detailed(reserveData.underlyingAsset).balanceOf(\n        reserveData.aTokenAddress\n      );\n      (\n        reserveData.totalPrincipalStableDebt,\n        ,\n        reserveData.averageStableRate,\n        reserveData.stableDebtLastUpdateTimestamp\n      ) = IStableDebtToken(reserveData.stableDebtTokenAddress).getSupplyData();\n      reserveData.totalScaledVariableDebt = IVariableDebtToken(reserveData.variableDebtTokenAddress)\n        .scaledTotalSupply();\n\n      if (address(reserveData.underlyingAsset) == address(MKRAddress)) {\n        bytes32 symbol = IERC20DetailedBytes(reserveData.underlyingAsset).symbol();\n        reserveData.symbol = bytes32ToString(symbol);\n      } else {\n        reserveData.symbol = IERC20Detailed(reserveData.underlyingAsset).symbol();\n      }\n\n      (\n        reserveData.baseLTVasCollateral,\n        reserveData.reserveLiquidationThreshold,\n        reserveData.reserveLiquidationBonus,\n        reserveData.decimals,\n        reserveData.reserveFactor\n      ) = baseData.configuration.getParamsMemory();\n      (\n        reserveData.isActive,\n        reserveData.isFrozen,\n        reserveData.borrowingEnabled,\n        reserveData.stableBorrowRateEnabled\n      ) = baseData.configuration.getFlagsMemory();\n      reserveData.usageAsCollateralEnabled = reserveData.baseLTVasCollateral != 0;\n      (\n        reserveData.variableRateSlope1,\n        reserveData.variableRateSlope2,\n        reserveData.stableRateSlope1,\n        reserveData.stableRateSlope2\n      ) = getInterestRateStrategySlopes(\n        DefaultReserveInterestRateStrategy(reserveData.interestRateStrategyAddress)\n      );\n    }\n\n    BaseCurrencyInfo memory baseCurrencyInfo;\n    baseCurrencyInfo.networkBaseTokenPriceInUsd = networkBaseTokenPriceInUsdProxyAggregator\n      .latestAnswer();\n    baseCurrencyInfo.networkBaseTokenPriceDecimals = networkBaseTokenPriceInUsdProxyAggregator\n      .decimals();\n\n    try oracle.BASE_CURRENCY_UNIT() returns (uint256 baseCurrencyUnit) {\n      if (ETH_CURRENCY_UNIT == baseCurrencyUnit) {\n        baseCurrencyInfo.marketReferenceCurrencyUnit = ETH_CURRENCY_UNIT;\n        baseCurrencyInfo\n        .marketReferenceCurrencyPriceInUsd = marketReferenceCurrencyPriceInUsdProxyAggregator\n        .latestAnswer();\n      } else {\n        baseCurrencyInfo.marketReferenceCurrencyUnit = baseCurrencyUnit;\n        baseCurrencyInfo.marketReferenceCurrencyPriceInUsd = int256(baseCurrencyUnit);\n      }\n    } catch (\n      bytes memory /*lowLevelData*/\n    ) {\n      baseCurrencyInfo.marketReferenceCurrencyUnit = ETH_CURRENCY_UNIT;\n      baseCurrencyInfo\n        .marketReferenceCurrencyPriceInUsd = marketReferenceCurrencyPriceInUsdProxyAggregator\n        .latestAnswer();\n    }\n\n    return (reservesData, baseCurrencyInfo);\n  }\n\n  function getUserReservesData(ILendingPoolAddressesProvider provider, address user)\n    external\n    view\n    override\n    returns (UserReserveData[] memory, uint8)\n  {\n    ILendingPool lendingPool = ILendingPool(provider.getLendingPool());\n    address[] memory reserves = lendingPool.getReservesList();\n    DataTypes.UserConfigurationMap memory userConfig = lendingPool.getUserConfiguration(user);\n\n    UserReserveData[] memory userReservesData = new UserReserveData[](\n      user != address(0) ? reserves.length : 0\n    );\n\n    for (uint256 i = 0; i < reserves.length; i++) {\n      DataTypes.ReserveData memory baseData = lendingPool.getReserveData(reserves[i]);\n\n      // user reserve data\n      userReservesData[i].underlyingAsset = reserves[i];\n      userReservesData[i].scaledATokenBalance = IAToken(baseData.aTokenAddress).scaledBalanceOf(\n        user\n      );\n      userReservesData[i].usageAsCollateralEnabledOnUser = userConfig.isUsingAsCollateral(i);\n\n      if (userConfig.isBorrowing(i)) {\n        userReservesData[i].scaledVariableDebt = IVariableDebtToken(\n          baseData.variableDebtTokenAddress\n        ).scaledBalanceOf(user);\n        userReservesData[i].principalStableDebt = IStableDebtToken(baseData.stableDebtTokenAddress)\n          .principalBalanceOf(user);\n        if (userReservesData[i].principalStableDebt != 0) {\n          userReservesData[i].stableBorrowRate = IStableDebtToken(baseData.stableDebtTokenAddress)\n            .getUserStableRate(user);\n          userReservesData[i].stableBorrowLastUpdateTimestamp = IStableDebtToken(\n            baseData.stableDebtTokenAddress\n          ).getUserLastUpdated(user);\n        }\n      }\n    }\n\n    // Return 0 to be compatible with v3 userEmodeCategoryId return\n    return (userReservesData, 0);\n  }\n\n  function bytes32ToString(bytes32 _bytes32) public pure returns (string memory) {\n    uint8 i = 0;\n    while (i < 32 && _bytes32[i] != 0) {\n      i++;\n    }\n    bytes memory bytesArray = new bytes(i);\n    for (i = 0; i < 32 && _bytes32[i] != 0; i++) {\n      bytesArray[i] = _bytes32[i];\n    }\n    return string(bytesArray);\n  }\n}"
    },
    "contracts/misc/WalletBalanceProvider.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\npragma experimental ABIEncoderV2;\n\nimport {Address} from '../dependencies/openzeppelin/contracts/Address.sol';\nimport {IERC20} from '../dependencies/openzeppelin/contracts/IERC20.sol';\n\nimport {ILendingPoolAddressesProvider} from '../interfaces/ILendingPoolAddressesProvider.sol';\nimport {ILendingPool} from '../interfaces/ILendingPool.sol';\nimport {SafeERC20} from '../dependencies/openzeppelin/contracts/SafeERC20.sol';\nimport {ReserveConfiguration} from '../protocol/libraries/configuration/ReserveConfiguration.sol';\nimport {DataTypes} from '../protocol/libraries/types/DataTypes.sol';\n\n/**\n * @title WalletBalanceProvider contract\n * @author Aave, influenced by https://github.com/wbobeirne/eth-balance-checker/blob/master/contracts/BalanceChecker.sol\n * @notice Implements a logic of getting multiple tokens balance for one user address\n * @dev NOTE: THIS CONTRACT IS NOT USED WITHIN THE AAVE PROTOCOL. It's an accessory contract used to reduce the number of calls\n * towards the blockchain from the Aave backend.\n **/\ncontract WalletBalanceProvider {\n  using Address for address payable;\n  using Address for address;\n  using SafeERC20 for IERC20;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n\n  address constant MOCK_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n  /**\n    @dev Fallback function, don't accept any ETH\n    **/\n  receive() external payable {\n    //only contracts can send ETH to the core\n    require(msg.sender.isContract(), '22');\n  }\n\n  /**\n    @dev Check the token balance of a wallet in a token contract\n\n    Returns the balance of the token for user. Avoids possible errors:\n      - return 0 on non-contract address\n    **/\n  function balanceOf(address user, address token) public view returns (uint256) {\n    if (token == MOCK_ETH_ADDRESS) {\n      return user.balance; // ETH balance\n      // check if token is actually a contract\n    } else if (token.isContract()) {\n      return IERC20(token).balanceOf(user);\n    }\n    revert('INVALID_TOKEN');\n  }\n\n  /**\n   * @notice Fetches, for a list of _users and _tokens (ETH included with mock address), the balances\n   * @param users The list of users\n   * @param tokens The list of tokens\n   * @return And array with the concatenation of, for each user, his/her balances\n   **/\n  function batchBalanceOf(address[] calldata users, address[] calldata tokens)\n    external\n    view\n    returns (uint256[] memory)\n  {\n    uint256[] memory balances = new uint256[](users.length * tokens.length);\n\n    for (uint256 i = 0; i < users.length; i++) {\n      for (uint256 j = 0; j < tokens.length; j++) {\n        balances[i * tokens.length + j] = balanceOf(users[i], tokens[j]);\n      }\n    }\n\n    return balances;\n  }\n\n  /**\n    @dev provides balances of user wallet for all reserves available on the pool\n    */\n  function getUserWalletBalances(address provider, address user)\n    external\n    view\n    returns (address[] memory, uint256[] memory)\n  {\n    ILendingPool pool = ILendingPool(ILendingPoolAddressesProvider(provider).getLendingPool());\n\n    address[] memory reserves = pool.getReservesList();\n    address[] memory reservesWithEth = new address[](reserves.length + 1);\n    for (uint256 i = 0; i < reserves.length; i++) {\n      reservesWithEth[i] = reserves[i];\n    }\n    reservesWithEth[reserves.length] = MOCK_ETH_ADDRESS;\n\n    uint256[] memory balances = new uint256[](reservesWithEth.length);\n\n    for (uint256 j = 0; j < reserves.length; j++) {\n      DataTypes.ReserveConfigurationMap memory configuration =\n        pool.getConfiguration(reservesWithEth[j]);\n\n      (bool isActive, , , ) = configuration.getFlagsMemory();\n\n      if (!isActive) {\n        balances[j] = 0;\n        continue;\n      }\n      balances[j] = balanceOf(user, reservesWithEth[j]);\n    }\n    balances[reserves.length] = balanceOf(user, MOCK_ETH_ADDRESS);\n\n    return (reservesWithEth, balances);\n  }\n}\n"
    },
    "contracts/misc/WETHGateway.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {Ownable} from '../dependencies/openzeppelin/contracts/Ownable.sol';\nimport {IERC20} from '../dependencies/openzeppelin/contracts/IERC20.sol';\nimport {IWETH} from './interfaces/IWETH.sol';\nimport {IWETHGateway} from './interfaces/IWETHGateway.sol';\nimport {ILendingPool} from '../interfaces/ILendingPool.sol';\nimport {IAToken} from '../interfaces/IAToken.sol';\nimport {ReserveConfiguration} from '../protocol/libraries/configuration/ReserveConfiguration.sol';\nimport {UserConfiguration} from '../protocol/libraries/configuration/UserConfiguration.sol';\nimport {Helpers} from '../protocol/libraries/helpers/Helpers.sol';\nimport {DataTypes} from '../protocol/libraries/types/DataTypes.sol';\n\ncontract WETHGateway is IWETHGateway, Ownable {\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using UserConfiguration for DataTypes.UserConfigurationMap;\n\n  IWETH internal immutable WETH;\n\n  /**\n   * @dev Sets the WETH address and the LendingPoolAddressesProvider address. Infinite approves lending pool.\n   * @param weth Address of the Wrapped Ether contract\n   **/\n  constructor(address weth) {\n    WETH = IWETH(weth);\n  }\n\n  function authorizeLendingPool(address lendingPool) external onlyOwner {\n    WETH.approve(lendingPool, uint256(-1));\n  }\n\n  /**\n   * @dev deposits WETH into the reserve, using native ETH. A corresponding amount of the overlying asset (aTokens)\n   * is minted.\n   * @param lendingPool address of the targeted underlying lending pool\n   * @param onBehalfOf address of the user who will receive the aTokens representing the deposit\n   * @param referralCode integrators are assigned a referral code and can potentially receive rewards.\n   **/\n  function depositETH(\n    address lendingPool,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external payable override {\n    WETH.deposit{value: msg.value}();\n    ILendingPool(lendingPool).deposit(address(WETH), msg.value, onBehalfOf, referralCode);\n  }\n\n  function depositETHWithAutoDLP(\n    address lendingPool,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external payable {\n    WETH.deposit{value: msg.value}();\n    ILendingPool(lendingPool).depositWithAutoDLP(address(WETH), msg.value, onBehalfOf, referralCode);\n  }\n\n  /**\n   * @dev withdraws the WETH _reserves of msg.sender.\n   * @param lendingPool address of the targeted underlying lending pool\n   * @param amount amount of aWETH to withdraw and receive native ETH\n   * @param to address of the user who will receive native ETH\n   */\n  function withdrawETH(\n    address lendingPool,\n    uint256 amount,\n    address to\n  ) external override {\n    IAToken aWETH = IAToken(ILendingPool(lendingPool).getReserveData(address(WETH)).aTokenAddress);\n    uint256 userBalance = aWETH.balanceOf(msg.sender);\n    uint256 amountToWithdraw = amount;\n\n    // if amount is equal to uint(-1), the user wants to redeem everything\n    if (amount == type(uint256).max) {\n      amountToWithdraw = userBalance;\n    }\n    aWETH.transferFrom(msg.sender, address(this), amountToWithdraw);\n    ILendingPool(lendingPool).withdraw(address(WETH), amountToWithdraw, address(this));\n    WETH.withdraw(amountToWithdraw);\n    _safeTransferETH(to, amountToWithdraw);\n  }\n\n  /**\n   * @dev repays a borrow on the WETH reserve, for the specified amount (or for the whole amount, if uint256(-1) is specified).\n   * @param lendingPool address of the targeted underlying lending pool\n   * @param amount the amount to repay, or uint256(-1) if the user wants to repay everything\n   * @param rateMode the rate mode to repay\n   * @param onBehalfOf the address for which msg.sender is repaying\n   */\n  function repayETH(\n    address lendingPool,\n    uint256 amount,\n    uint256 rateMode,\n    address onBehalfOf\n  ) external payable override {\n    (uint256 stableDebt, uint256 variableDebt) =\n      Helpers.getUserCurrentDebtMemory(\n        onBehalfOf,\n        ILendingPool(lendingPool).getReserveData(address(WETH))\n      );\n\n    uint256 paybackAmount =\n      DataTypes.InterestRateMode(rateMode) == DataTypes.InterestRateMode.STABLE\n        ? stableDebt\n        : variableDebt;\n\n    if (amount < paybackAmount) {\n      paybackAmount = amount;\n    }\n    require(msg.value >= paybackAmount, 'msg.value is less than repayment amount');\n    WETH.deposit{value: paybackAmount}();\n    ILendingPool(lendingPool).repay(address(WETH), msg.value, rateMode, onBehalfOf);\n\n    // refund remaining dust eth\n    if (msg.value > paybackAmount) _safeTransferETH(msg.sender, msg.value - paybackAmount);\n  }\n\n  /**\n   * @dev borrow WETH, unwraps to ETH and send both the ETH and DebtTokens to msg.sender, via `approveDelegation` and onBehalf argument in `LendingPool.borrow`.\n   * @param lendingPool address of the targeted underlying lending pool\n   * @param amount the amount of ETH to borrow\n   * @param interesRateMode the interest rate mode\n   * @param referralCode integrators are assigned a referral code and can potentially receive rewards\n   */\n  function borrowETH(\n    address lendingPool,\n    uint256 amount,\n    uint256 interesRateMode,\n    uint16 referralCode\n  ) external override {\n    ILendingPool(lendingPool).borrow(\n      address(WETH),\n      amount,\n      interesRateMode,\n      referralCode,\n      msg.sender\n    );\n    WETH.withdraw(amount);\n    _safeTransferETH(msg.sender, amount);\n  }\n\n  /**\n   * @dev transfer ETH to an address, revert if it fails.\n   * @param to recipient of the transfer\n   * @param value the amount to send\n   */\n  function _safeTransferETH(address to, uint256 value) internal {\n    (bool success, ) = to.call{value: value}(new bytes(0));\n    require(success, 'ETH_TRANSFER_FAILED');\n  }\n\n  /**\n   * @dev transfer ERC20 from the utility contract, for ERC20 recovery in case of stuck tokens due\n   * direct transfers to the contract address.\n   * @param token token to transfer\n   * @param to recipient of the transfer\n   * @param amount amount to send\n   */\n  function emergencyTokenTransfer(\n    address token,\n    address to,\n    uint256 amount\n  ) external onlyOwner {\n    IERC20(token).transfer(to, amount);\n  }\n\n  /**\n   * @dev transfer native Ether from the utility contract, for native Ether recovery in case of stuck Ether\n   * due selfdestructs or transfer ether to pre-computated contract address before deployment.\n   * @param to recipient of the transfer\n   * @param amount amount to send\n   */\n  function emergencyEtherTransfer(address to, uint256 amount) external onlyOwner {\n    _safeTransferETH(to, amount);\n  }\n\n  /**\n   * @dev Get WETH address used by WETHGateway\n   */\n  function getWETHAddress() external view returns (address) {\n    return address(WETH);\n  }\n\n  /**\n   * @dev Only WETH contract is allowed to transfer ETH here. Prevent other addresses to send Ether to this contract.\n   */\n  receive() external payable {\n    require(msg.sender == address(WETH), 'Receive not allowed');\n  }\n\n  /**\n   * @dev Revert fallback calls\n   */\n  fallback() external payable {\n    revert('Fallback not allowed');\n  }\n}\n"
    },
    "contracts/mocks/MockToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\n\nimport \"../dependencies/openzeppelin/contracts/ERC20.sol\";\n\n// this is a MOCK\ncontract MockToken is ERC20 {\n    constructor(string memory name_, string memory symbol_, uint8 decimals_) ERC20(name_, symbol_){\n        // _mint(msg.sender, 1000000000 * 10**decimals_);\n        _decimals = decimals_;\n    }\n\n    function mint(address _to, uint _amount) public {\n        _mint(_to, _amount);\n    }\n}"
    },
    "contracts/mocks/oracle/LendingRateOracle.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\nimport {ILendingRateOracle} from '../../interfaces/ILendingRateOracle.sol';\nimport {Ownable} from '../../dependencies/openzeppelin/contracts/Ownable.sol';\n\ncontract LendingRateOracle is ILendingRateOracle, Ownable {\n  mapping(address => uint256) borrowRates;\n  mapping(address => uint256) liquidityRates;\n\n  function getMarketBorrowRate(address _asset) external view override returns (uint256) {\n    return borrowRates[_asset];\n  }\n\n  function setMarketBorrowRate(address _asset, uint256 _rate) external override onlyOwner {\n    borrowRates[_asset] = _rate;\n  }\n\n  function getMarketLiquidityRate(address _asset) external view returns (uint256) {\n    return liquidityRates[_asset];\n  }\n\n  function setMarketLiquidityRate(address _asset, uint256 _rate) external onlyOwner {\n    liquidityRates[_asset] = _rate;\n  }\n}\n"
    },
    "contracts/mocks/sushi/MockLpContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"../../dependencies/openzeppelin/contracts/ERC20.sol\";\nimport \"../../dependencies/openzeppelin/contracts/SafeMath.sol\";\nimport \"../../dependencies/uniswap/contracts/UQ112x112.sol\";\n\n/**\n * @title Mock Contract for Sushi LP token\n * @notice Anyone can mint lp tokens\n * @dev In every mint, it is decreasing reserve0 and increasing reserve1 to simulate price changes\n * @author gmspacex\n */\ncontract MockLpContract is ERC20 {\n    using SafeMath for uint256;\n    using UQ112x112 for uint224;\n\n\n    uint112 private reserve0;           // uses single storage slot, accessible via getReserves\n    uint112 private reserve1;           // uses single storage slot, accessible via getReserves\n    uint32  private blockTimestampLast; // uses single storage slot, accessible via getReserves\n\n    uint public price0CumulativeLast;\n    uint public price1CumulativeLast;\n    uint public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event\n\n    address private rdntToken;\n    address public token0;\n    address public token1;\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        address _rdntToken,\n        address _weth,\n        uint112[] memory _startBalances\n    ) ERC20(name, symbol) {\n        reserve0 = _startBalances[0]; //10**decimals() * 100_000;\n        reserve1 = _startBalances[1]; //10**decimals() * 100_000;\n        rdntToken = _rdntToken;\n        token0 = _rdntToken;\n        token1 = _weth;\n    }\n\n    function mintSize() public pure returns (uint256) {\n        return 1000000;\n    }\n\n    /**\n     * @notice External function to mint lp tokens\n     * @dev Anyone can mint lp tokens\n     */\n    function mint() external {\n        _mint(msg.sender, mintSize() *10**decimals());\n        // simulate price changes\n        increasePrice();\n    }\n\n    function decreasePrice() public {\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves();\n        uint balance0 = uint256(reserve0).mul(10).div(9);\n        uint balance1 = uint256(reserve1).mul(9).div(10);\n        _update(balance0, balance1, _reserve0, _reserve1);\n    }\n\n    function increasePrice() public {\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves();\n        uint balance0 = uint256(reserve0).mul(9).div(10);\n        uint balance1 = uint256(reserve1).mul(10).div(9);\n        _update(balance0, balance1, _reserve0, _reserve1);\n    }\n\n    /**\n     * @notice External view function that returns amount of reserves\n     * @return _reserve0\n     * @return _reserve1\n     */\n    function getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n        _blockTimestampLast = blockTimestampLast;\n    }\n\n     function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {\n        require(balance0 <= uint112(-1) && balance1 <= uint112(-1), 'UniswapV2: OVERFLOW');\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\n            // * never overflows, and + overflow is desired\n            price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;\n            price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;\n        }\n        reserve0 = uint112(balance0);\n        reserve1 = uint112(balance1);\n        blockTimestampLast = blockTimestamp;\n    }\n}\n"
    },
    "contracts/oft/layerzero/interfaces/ILayerZeroEndpoint.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\nimport \"./ILayerZeroUserApplicationConfig.sol\";\n\ninterface ILayerZeroEndpoint is ILayerZeroUserApplicationConfig {\n    // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\n    // @param _dstChainId - the destination chain identifier\n    // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\n    // @param _payload - a custom bytes payload to send to the destination contract\n    // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\n    // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\n    // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\n    function send(uint16 _dstChainId, bytes calldata _destination, bytes calldata _payload, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;\n\n    // @notice used by the messaging library to publish verified payload\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source contract (as bytes) at the source chain\n    // @param _dstAddress - the address on destination chain\n    // @param _nonce - the unbound message ordering nonce\n    // @param _gasLimit - the gas limit for external contract execution\n    // @param _payload - verified payload to send to the destination contract\n    function receivePayload(uint16 _srcChainId, bytes calldata _srcAddress, address _dstAddress, uint64 _nonce, uint _gasLimit, bytes calldata _payload) external;\n\n    // @notice get the inboundNonce of a lzApp from a source chain which could be EVM or non-EVM chain\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\n\n    // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\n    // @param _srcAddress - the source chain contract address\n    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\n\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\n    // @param _dstChainId - the destination chain identifier\n    // @param _userApplication - the user app address on this EVM chain\n    // @param _payload - the custom message to send over LayerZero\n    // @param _payInZRO - if false, user app pays the protocol fee in native token\n    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\n    function estimateFees(uint16 _dstChainId, address _userApplication, bytes calldata _payload, bool _payInZRO, bytes calldata _adapterParam) external view returns (uint nativeFee, uint zroFee);\n\n    // @notice get this Endpoint's immutable source identifier\n    function getChainId() external view returns (uint16);\n\n    // @notice the interface to retry failed message on this Endpoint destination\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    // @param _payload - the payload to be retried\n    function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external;\n\n    // @notice query if any STORED payload (message blocking) at the endpoint.\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\n\n    // @notice query if the _libraryAddress is valid for sending msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getSendLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the _libraryAddress is valid for receiving msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getReceiveLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the non-reentrancy guard for send() is on\n    // @return true if the guard is on. false otherwise\n    function isSendingPayload() external view returns (bool);\n\n    // @notice query if the non-reentrancy guard for receive() is on\n    // @return true if the guard is on. false otherwise\n    function isReceivingPayload() external view returns (bool);\n\n    // @notice get the configuration of the LayerZero messaging library of the specified version\n    // @param _version - messaging library version\n    // @param _chainId - the chainId for the pending config change\n    // @param _userApplication - the contract address of the user application\n    // @param _configType - type of configuration. every messaging library has its own convention.\n    function getConfig(uint16 _version, uint16 _chainId, address _userApplication, uint _configType) external view returns (bytes memory);\n\n    // @notice get the send() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getSendVersion(address _userApplication) external view returns (uint16);\n\n    // @notice get the lzReceive() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getReceiveVersion(address _userApplication) external view returns (uint16);\n}"
    },
    "contracts/oft/layerzero/interfaces/ILayerZeroReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\ninterface ILayerZeroReceiver {\n    // @notice LayerZero endpoint will invoke this function to deliver the message on the destination\n    // @param _srcChainId - the source endpoint identifier\n    // @param _srcAddress - the source sending contract address from the source chain\n    // @param _nonce - the ordered message nonce\n    // @param _payload - the signed payload is the UA bytes has encoded to be sent\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) external;\n}"
    },
    "contracts/oft/layerzero/interfaces/ILayerZeroUserApplicationConfig.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\ninterface ILayerZeroUserApplicationConfig {\n    // @notice set the configuration of the LayerZero messaging library of the specified version\n    // @param _version - messaging library version\n    // @param _chainId - the chainId for the pending config change\n    // @param _configType - type of configuration. every messaging library has its own convention.\n    // @param _config - configuration in the bytes. can encode arbitrary content.\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external;\n\n    // @notice set the send() LayerZero messaging library version to _version\n    // @param _version - new messaging library version\n    function setSendVersion(uint16 _version) external;\n\n    // @notice set the lzReceive() LayerZero messaging library version to _version\n    // @param _version - new messaging library version\n    function setReceiveVersion(uint16 _version) external;\n\n    // @notice Only when the UA needs to resume the message flow in blocking mode and clear the stored payload\n    // @param _srcChainId - the chainId of the source chain\n    // @param _srcAddress - the contract address of the source contract at the source chain\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;\n}"
    },
    "contracts/oft/layerzero/interfaces/IOFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"./IOFTCore.sol\";\nimport \"../../../dependencies/openzeppelin/contracts/IERC20.sol\";\n\n/**\n * @dev Interface of the OFT standard\n */\ninterface IOFT is IOFTCore, IERC20 {\n\n}"
    },
    "contracts/oft/layerzero/interfaces/IOFTCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"../../../dependencies/openzeppelin/contracts/IERC20.sol\";\nimport \"../../../dependencies/openzeppelin/contracts/IERC165.sol\";\n\n/**\n * @dev Interface of the IOFT core standard\n */\ninterface IOFTCore is IERC165 {\n    /**\n     * @dev estimate send token `_tokenId` to (`_dstChainId`, `_toAddress`)\n     * _dstChainId - L0 defined chain id to send tokens too\n     * _toAddress - dynamic bytes array which contains the address to whom you are sending tokens to on the dstChain\n     * _amount - amount of the tokens to transfer\n     * _useZro - indicates to use zro to pay L0 fees\n     * _adapterParam - flexible bytes array to indicate messaging adapter services in L0\n     */\n    function estimateSendFee(uint16 _dstChainId, bytes calldata _toAddress, uint _amount, bool _useZro, bytes calldata _adapterParams) external view returns (uint nativeFee, uint zroFee);\n\n    /**\n     * @dev send `_amount` amount of token to (`_dstChainId`, `_toAddress`) from `_from`\n     * `_from` the owner of token\n     * `_dstChainId` the destination chain identifier\n     * `_toAddress` can be any size depending on the `dstChainId`.\n     * `_amount` the quantity of tokens in wei\n     * `_refundAddress` the address LayerZero refunds if too much message fee is sent\n     * `_zroPaymentAddress` set to address(0x0) if not paying in ZRO (LayerZero Token)\n     * `_adapterParams` is a flexible bytes array to indicate messaging adapter services\n     */\n    function sendFrom(address _from, uint16 _dstChainId, bytes calldata _toAddress, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;\n\n    /**\n     * @dev returns the circulating amount of tokens on current chain\n     */\n    function circulatingSupply() external view returns (uint);\n\n    /**\n     * @dev Emitted when `_amount` tokens are moved from the `_sender` to (`_dstChainId`, `_toAddress`)\n     * `_nonce` is the outbound nonce\n     */\n    event SendToChain(uint16 indexed _dstChainId, address indexed _from, bytes indexed _toAddress, uint _amount);\n\n    /**\n     * @dev Emitted when `_amount` tokens are received from `_srcChainId` into the `_toAddress` on the local chain.\n     * `_nonce` is the inbound nonce.\n     */\n    event ReceiveFromChain(uint16 indexed _srcChainId, bytes indexed _srcAddress, address indexed _toAddress, uint _amount);\n}"
    },
    "contracts/oft/layerzero/LzApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"../../dependencies/openzeppelin/contracts/SafeMath.sol\";\nimport \"../../dependencies/openzeppelin/contracts/Ownable.sol\";\nimport \"./interfaces/ILayerZeroReceiver.sol\";\nimport \"./interfaces/ILayerZeroUserApplicationConfig.sol\";\nimport \"./interfaces/ILayerZeroEndpoint.sol\";\n\n/*\n * a generic LzReceiver implementation\n */\nabstract contract LzApp is Ownable, ILayerZeroReceiver, ILayerZeroUserApplicationConfig {\n    using SafeMath for uint256;\n\n    ILayerZeroEndpoint public immutable lzEndpoint;\n    mapping(uint16 => bytes) public trustedRemoteLookup;\n    mapping(uint16 => mapping(uint => uint)) public minDstGasLookup;\n\n    event SetTrustedRemote(uint16 _srcChainId, bytes _srcAddress);\n    event SetMinDstGasLookup(uint16 _dstChainId, uint _type, uint _dstGasAmount);\n\n    constructor(address _endpoint) {\n        lzEndpoint = ILayerZeroEndpoint(_endpoint);\n    }\n\n    function lzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) public virtual override {\n        // lzReceive must be called by the endpoint for security\n        require(_msgSender() == address(lzEndpoint), \"LzApp: invalid endpoint caller\");\n\n        bytes memory trustedRemote = trustedRemoteLookup[_srcChainId];\n        // if will still block the message pathway from (srcChainId, srcAddress). should not receive message from untrusted remote.\n        require(_srcAddress.length == trustedRemote.length && keccak256(_srcAddress) == keccak256(trustedRemote), \"LzApp: invalid source sending contract\");\n\n        _blockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    // abstract function - the default behaviour of LayerZero is blocking. See: NonblockingLzApp if you dont need to enforce ordered messaging\n    function _blockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual;\n\n    function _lzSend(uint16 _dstChainId, bytes memory _payload, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams, uint256 _fee) internal virtual {\n        bytes memory trustedRemote = trustedRemoteLookup[_dstChainId];\n        require(trustedRemote.length != 0, \"LzApp: destination chain is not a trusted source\");\n        lzEndpoint.send{value: _fee}(_dstChainId, trustedRemote, _payload, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    function _checkGasLimit(uint16 _dstChainId, uint _type, bytes memory _adapterParams, uint _extraGas) internal view {\n        uint providedGasLimit = getGasLimit(_adapterParams);\n        uint minGasLimit = minDstGasLookup[_dstChainId][_type].add(_extraGas);\n        require(minGasLimit > 0, \"LzApp: minGasLimit not set\");\n        require(providedGasLimit >= minGasLimit, \"LzApp: gas limit is too low\");\n    }\n\n    function getGasLimit(bytes memory _adapterParams) internal pure returns (uint gasLimit) {\n        require(_adapterParams.length >= 34, \"LzApp: invalid adapterParams\");\n        assembly {\n            gasLimit := mload(add(_adapterParams, 34))\n        }\n    }\n\n    //---------------------------UserApplication config----------------------------------------\n    function getConfig(uint16 _version, uint16 _chainId, address, uint _configType) external view returns (bytes memory) {\n        return lzEndpoint.getConfig(_version, _chainId, address(this), _configType);\n    }\n\n    // generic config for LayerZero user Application\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external override onlyOwner {\n        lzEndpoint.setConfig(_version, _chainId, _configType, _config);\n    }\n\n    function setSendVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setSendVersion(_version);\n    }\n\n    function setReceiveVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setReceiveVersion(_version);\n    }\n\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override onlyOwner {\n        lzEndpoint.forceResumeReceive(_srcChainId, _srcAddress);\n    }\n\n    // allow owner to set it multiple times.\n    function setTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external onlyOwner {\n        trustedRemoteLookup[_srcChainId] = _srcAddress;\n        emit SetTrustedRemote(_srcChainId, _srcAddress);\n    }\n\n    function setMinDstGasLookup(uint16 _dstChainId, uint _type, uint _dstGasAmount) external onlyOwner {\n        require(_dstGasAmount > 0, \"LzApp: invalid _dstGasAmount\");\n        minDstGasLookup[_dstChainId][_type] = _dstGasAmount;\n        emit SetMinDstGasLookup(_dstChainId, _type, _dstGasAmount);\n    }\n\n    //--------------------------- VIEW FUNCTION ----------------------------------------\n    function isTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool) {\n        bytes memory trustedSource = trustedRemoteLookup[_srcChainId];\n        return keccak256(trustedSource) == keccak256(_srcAddress);\n    }\n}"
    },
    "contracts/oft/layerzero/mock/LZEndpointMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../interfaces/ILayerZeroReceiver.sol\";\nimport \"../interfaces/ILayerZeroEndpoint.sol\";\n\n/*\nmocking multi endpoint connection.\n- send() will short circuit to lzReceive() directly\n- no reentrancy guard. the real LayerZero endpoint on main net has a send and receive guard, respectively.\nif we run a ping-pong-like application, the recursive call might use all gas limit in the block.\n- not using any messaging library, hence all messaging library func, e.g. estimateFees, version, will not work\n*/\ncontract LZEndpointMock is ILayerZeroEndpoint {\n    mapping(address => address) public lzEndpointLookup;\n\n    uint16 public mockChainId;\n    address payable public mockOracle;\n    address payable public mockRelayer;\n    uint public mockBlockConfirmations;\n    uint16 public mockLibraryVersion;\n    uint public mockStaticNativeFee;\n    uint16 public mockLayerZeroVersion;\n    uint public nativeFee;\n    uint public zroFee;\n    bool nextMsgBLocked;\n\n    struct StoredPayload {\n        uint64 payloadLength;\n        address dstAddress;\n        bytes32 payloadHash;\n    }\n\n    struct QueuedPayload {\n        address dstAddress;\n        uint64 nonce;\n        bytes payload;\n    }\n\n    // inboundNonce = [srcChainId][srcAddress].\n    mapping(uint16 => mapping(bytes => uint64)) public inboundNonce;\n    // outboundNonce = [dstChainId][srcAddress].\n    mapping(uint16 => mapping(address => uint64)) public outboundNonce;\n    // storedPayload = [srcChainId][srcAddress]\n    mapping(uint16 => mapping(bytes => StoredPayload)) public storedPayload;\n    // msgToDeliver = [srcChainId][srcAddress]\n    mapping(uint16 => mapping(bytes => QueuedPayload[])) public msgsToDeliver;\n\n    event UaForceResumeReceive(uint16 chainId, bytes srcAddress);\n    event PayloadCleared(uint16 srcChainId, bytes srcAddress, uint64 nonce, address dstAddress);\n    event PayloadStored(uint16 srcChainId, bytes srcAddress, address dstAddress, uint64 nonce, bytes payload, bytes reason);\n\n    constructor(uint16 _chainId) {\n        mockStaticNativeFee = 42;\n        mockLayerZeroVersion = 1;\n        mockChainId = _chainId;\n    }\n\n    // mock helper to set the value returned by `estimateNativeFees`\n    function setEstimatedFees(uint _nativeFee, uint _zroFee) public {\n        nativeFee = _nativeFee;\n        zroFee = _zroFee;\n    }\n\n    function getChainId() external view override returns (uint16) {\n        return mockChainId;\n    }\n\n    function setDestLzEndpoint(address destAddr, address lzEndpointAddr) external {\n        lzEndpointLookup[destAddr] = lzEndpointAddr;\n    }\n\n    function send(\n        uint16 _chainId,\n        bytes calldata _destination,\n        bytes calldata _payload,\n        address payable, // _refundAddress\n        address, // _zroPaymentAddress\n        bytes memory _adapterParams\n    ) external payable override {\n        address destAddr = packedBytesToAddr(_destination);\n        address lzEndpoint = lzEndpointLookup[destAddr];\n\n        require(lzEndpoint != address(0), \"LayerZeroMock: destination LayerZero Endpoint not found\");\n\n        require(msg.value >= nativeFee * _payload.length, \"LayerZeroMock: not enough native for fees\");\n\n        uint64 nonce;\n        {\n            nonce = ++outboundNonce[_chainId][msg.sender];\n        }\n\n        // Mock the relayer paying the dstNativeAddr the amount of extra native token\n        {\n            uint extraGas;\n            uint dstNative;\n            address dstNativeAddr;\n            assembly {\n                extraGas := mload(add(_adapterParams, 34))\n                dstNative := mload(add(_adapterParams, 66))\n                dstNativeAddr := mload(add(_adapterParams, 86))\n            }\n\n            // to simulate actually sending the ether, add a transfer call and ensure the LZEndpointMock contract has an ether balance\n        }\n\n        bytes memory bytesSourceUserApplicationAddr = addrToPackedBytes(address(msg.sender)); // cast this address to bytes\n\n        // not using the extra gas parameter because this is a single tx call, not split between different chains\n        // LZEndpointMock(lzEndpoint).receivePayload(mockChainId, bytesSourceUserApplicationAddr, destAddr, nonce, extraGas, _payload);\n        LZEndpointMock(lzEndpoint).receivePayload(mockChainId, bytesSourceUserApplicationAddr, destAddr, nonce, 0, _payload);\n    }\n\n    function receivePayload(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        address _dstAddress,\n        uint64 _nonce,\n        uint, /*_gasLimit*/\n        bytes calldata _payload\n    ) external override {\n        StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\n\n        // assert and increment the nonce. no message shuffling\n        require(_nonce == ++inboundNonce[_srcChainId][_srcAddress], \"LayerZero: wrong nonce\");\n\n        // queue the following msgs inside of a stack to simulate a successful send on src, but not fully delivered on dst\n        if (sp.payloadHash != bytes32(0)) {\n            QueuedPayload[] storage msgs = msgsToDeliver[_srcChainId][_srcAddress];\n            QueuedPayload memory newMsg = QueuedPayload(_dstAddress, _nonce, _payload);\n\n            // warning, might run into gas issues trying to forward through a bunch of queued msgs\n            // shift all the msgs over so we can treat this like a fifo via array.pop()\n            if (msgs.length > 0) {\n                // extend the array\n                msgs.push(newMsg);\n\n                // shift all the indexes up for pop()\n                for (uint i = 0; i < msgs.length - 1; i++) {\n                    msgs[i + 1] = msgs[i];\n                }\n\n                // put the newMsg at the bottom of the stack\n                msgs[0] = newMsg;\n            } else {\n                msgs.push(newMsg);\n            }\n        } else if (nextMsgBLocked) {\n            storedPayload[_srcChainId][_srcAddress] = StoredPayload(uint64(_payload.length), _dstAddress, keccak256(_payload));\n            emit PayloadStored(_srcChainId, _srcAddress, _dstAddress, _nonce, _payload, bytes(\"\"));\n            // ensure the next msgs that go through are no longer blocked\n            nextMsgBLocked = false;\n        } else {\n            // we ignore the gas limit because this call is made in one tx due to being \"same chain\"\n            // ILayerZeroReceiver(_dstAddress).lzReceive{gas: _gasLimit}(_srcChainId, _srcAddress, _nonce, _payload); // invoke lzReceive\n            ILayerZeroReceiver(_dstAddress).lzReceive(_srcChainId, _srcAddress, _nonce, _payload); // invoke lzReceive\n        }\n    }\n\n    // used to simulate messages received get stored as a payload\n    function blockNextMsg() external {\n        nextMsgBLocked = true;\n    }\n\n    function getLengthOfQueue(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint) {\n        return msgsToDeliver[_srcChainId][_srcAddress].length;\n    }\n\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\n    // @param _dstChainId - the destination chain identifier\n    // @param _userApplication - the user app address on this EVM chain\n    // @param _payload - the custom message to send over LayerZero\n    // @param _payInZRO - if false, user app pays the protocol fee in native token\n    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\n    function estimateFees(uint16, address, bytes memory _payload, bool, bytes memory) external view override returns (uint _nativeFee, uint _zroFee) {\n        _nativeFee = nativeFee * _payload.length;\n        _zroFee = zroFee;\n    }\n\n    // give 20 bytes, return the decoded address\n    function packedBytesToAddr(bytes calldata _b) public pure returns (address) {\n        address addr;\n        assembly {\n            let ptr := mload(0x40)\n            calldatacopy(ptr, sub(_b.offset, 2), add(_b.length, 2))\n            addr := mload(sub(ptr, 10))\n        }\n        return addr;\n    }\n\n    // given an address, return the 20 bytes\n    function addrToPackedBytes(address _a) public pure returns (bytes memory) {\n        bytes memory data = abi.encodePacked(_a);\n        return data;\n    }\n\n    function setConfig(\n        uint16, /*_version*/\n        uint16, /*_chainId*/\n        uint, /*_configType*/\n        bytes memory /*_config*/\n    ) external override {}\n\n    function getConfig(\n        uint16, /*_version*/\n        uint16, /*_chainId*/\n        address, /*_ua*/\n        uint /*_configType*/\n    ) external pure override returns (bytes memory) {\n        return \"\";\n    }\n\n    function setSendVersion(\n        uint16 /*version*/\n    ) external override {}\n\n    function setReceiveVersion(\n        uint16 /*version*/\n    ) external override {}\n\n    function getSendVersion(\n        address /*_userApplication*/\n    ) external pure override returns (uint16) {\n        return 1;\n    }\n\n    function getReceiveVersion(\n        address /*_userApplication*/\n    ) external pure override returns (uint16) {\n        return 1;\n    }\n\n    function getInboundNonce(uint16 _chainID, bytes calldata _srcAddress) external view override returns (uint64) {\n        return inboundNonce[_chainID][_srcAddress];\n    }\n\n    function getOutboundNonce(uint16 _chainID, address _srcAddress) external view override returns (uint64) {\n        return outboundNonce[_chainID][_srcAddress];\n    }\n\n    // simulates the relayer pushing through the rest of the msgs that got delayed due to the stored payload\n    function _clearMsgQue(uint16 _srcChainId, bytes calldata _srcAddress) internal {\n        QueuedPayload[] storage msgs = msgsToDeliver[_srcChainId][_srcAddress];\n\n        // warning, might run into gas issues trying to forward through a bunch of queued msgs\n        while (msgs.length > 0) {\n            QueuedPayload memory payload = msgs[msgs.length - 1];\n            ILayerZeroReceiver(payload.dstAddress).lzReceive(_srcChainId, _srcAddress, payload.nonce, payload.payload);\n            msgs.pop();\n        }\n    }\n\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override {\n        StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\n        // revert if no messages are cached. safeguard malicious UA behaviour\n        require(sp.payloadHash != bytes32(0), \"LayerZero: no stored payload\");\n        require(sp.dstAddress == msg.sender, \"LayerZero: invalid caller\");\n\n        // empty the storedPayload\n        sp.payloadLength = 0;\n        sp.dstAddress = address(0);\n        sp.payloadHash = bytes32(0);\n\n        emit UaForceResumeReceive(_srcChainId, _srcAddress);\n\n        // resume the receiving of msgs after we force clear the \"stuck\" msg\n        _clearMsgQue(_srcChainId, _srcAddress);\n    }\n\n    function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external override {\n        StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\n        require(sp.payloadHash != bytes32(0), \"LayerZero: no stored payload\");\n        require(_payload.length == sp.payloadLength && keccak256(_payload) == sp.payloadHash, \"LayerZero: invalid payload\");\n\n        address dstAddress = sp.dstAddress;\n        // empty the storedPayload\n        sp.payloadLength = 0;\n        sp.dstAddress = address(0);\n        sp.payloadHash = bytes32(0);\n\n        uint64 nonce = inboundNonce[_srcChainId][_srcAddress];\n\n        ILayerZeroReceiver(dstAddress).lzReceive(_srcChainId, _srcAddress, nonce, _payload);\n        emit PayloadCleared(_srcChainId, _srcAddress, nonce, dstAddress);\n    }\n\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view override returns (bool) {\n        StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\n        return sp.payloadHash != bytes32(0);\n    }\n\n    function isSendingPayload() external pure override returns (bool) {\n        return false;\n    }\n\n    function isReceivingPayload() external pure override returns (bool) {\n        return false;\n    }\n\n    function getSendLibraryAddress(address) external view override returns (address) {\n        return address(this);\n    }\n\n    function getReceiveLibraryAddress(address) external view override returns (address) {\n        return address(this);\n    }\n}"
    },
    "contracts/oft/layerzero/NonblockingLzApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"./LzApp.sol\";\n\n/*\n * the default LayerZero messaging behaviour is blocking, i.e. any failed message will block the channel\n * this abstract class try-catch all fail messages and store locally for future retry. hence, non-blocking\n * NOTE: if the srcAddress is not configured properly, it will still block the message pathway from (srcChainId, srcAddress)\n */\nabstract contract NonblockingLzApp is LzApp {\n    constructor(address _endpoint) LzApp(_endpoint) {}\n\n    mapping(uint16 => mapping(bytes => mapping(uint64 => bytes32))) public failedMessages;\n\n    event MessageFailed(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes _payload);\n\n    // overriding the virtual function in LzReceiver\n    function _blockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual override {\n        // try-catch all errors/exceptions\n        try this.nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload) {\n            // do nothing\n        } catch {\n            // error / exception\n            require(failedMessages[_srcChainId][_srcAddress][_nonce] == bytes32(0));\n            failedMessages[_srcChainId][_srcAddress][_nonce] = keccak256(_payload);\n            emit MessageFailed(_srcChainId, _srcAddress, _nonce, _payload);\n        }\n    }\n\n    function nonblockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) public virtual {\n        // only internal transaction\n        require(_msgSender() == address(this), \"NonblockingLzApp: caller must be LzApp\");\n        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    //@notice override this function\n    function _nonblockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual;\n\n    function retryMessage(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) public payable virtual {\n        // assert there is message to retry\n        bytes32 payloadHash = failedMessages[_srcChainId][_srcAddress][_nonce];\n        require(payloadHash != bytes32(0), \"NonblockingLzApp: no stored message\");\n        require(keccak256(_payload) == payloadHash, \"NonblockingLzApp: invalid payload\");\n        // clear the stored message\n        failedMessages[_srcChainId][_srcAddress][_nonce] = bytes32(0);\n        // execute the message. revert if it fails again\n        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n}"
    },
    "contracts/oft/layerzero/OFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"../../dependencies/openzeppelin/contracts/ERC20.sol\";\nimport \"../../dependencies/openzeppelin/contracts/IERC165.sol\";\nimport \"./interfaces/IOFT.sol\";\nimport \"./OFTCore.sol\";\n\n// override decimal() function is needed\ncontract OFT is OFTCore, ERC20, IOFT {\n    constructor(string memory _name, string memory _symbol, address _lzEndpoint) ERC20(_name, _symbol) OFTCore(_lzEndpoint) {}\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(OFTCore, IERC165) returns (bool) {\n        return interfaceId == type(IOFT).interfaceId || interfaceId == type(IERC20).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function circulatingSupply() public view virtual override returns (uint) {\n        return totalSupply();\n    }\n\n    function _debitFrom(address _from, uint16, bytes memory, uint _amount) internal virtual override {\n        address spender = _msgSender();\n        if (_from != spender) _spendAllowance(_from, spender, _amount);\n        _burn(_from, _amount);\n    }\n\n    function _creditTo(uint16, address _toAddress, uint _amount) internal virtual override {\n        _mint(_toAddress, _amount);\n    }\n}"
    },
    "contracts/oft/layerzero/OFTCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"./NonblockingLzApp.sol\";\nimport \"./interfaces/IOFTCore.sol\";\nimport \"../../dependencies/openzeppelin/contracts/ERC165.sol\";\n\nabstract contract OFTCore is NonblockingLzApp, ERC165, IOFTCore {\n    uint public constant NO_EXTRA_GAS = 0;\n    uint public constant FUNCTION_TYPE_SEND = 1;\n    bool public useCustomAdapterParams;\n\n    event SetUseCustomAdapterParams(bool _useCustomAdapterParams);\n\n    constructor(address _lzEndpoint) NonblockingLzApp(_lzEndpoint) {}\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IOFTCore).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function estimateSendFee(uint16 _dstChainId, bytes memory _toAddress, uint _amount, bool _useZro, bytes memory _adapterParams) public view virtual override returns (uint nativeFee, uint zroFee) {\n        // mock the payload for send()\n        bytes memory payload = abi.encode(_toAddress, _amount);\n        return lzEndpoint.estimateFees(_dstChainId, address(this), payload, _useZro, _adapterParams);\n    }\n\n    function sendFrom(address _from, uint16 _dstChainId, bytes memory _toAddress, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams) public payable virtual override {\n        _send(_from, _dstChainId, _toAddress, _amount, _refundAddress, _zroPaymentAddress, _adapterParams, msg.value);\n    }\n\n    function _nonblockingLzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64, /*_nonce*/\n        bytes memory _payload\n    ) internal virtual override {\n        // decode and load the toAddress\n        (bytes memory toAddressBytes, uint amount) = abi.decode(_payload, (bytes, uint));\n        address toAddress;\n        assembly {\n            toAddress := mload(add(toAddressBytes, 20))\n        }\n\n        _creditTo(_srcChainId, toAddress, amount);\n\n        emit ReceiveFromChain(_srcChainId, _srcAddress, toAddress, amount);\n    }\n\n    function _send(address _from, uint16 _dstChainId, bytes memory _toAddress, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams, uint256 _fee) internal virtual {\n        _debitFrom(_from, _dstChainId, _toAddress, _amount);\n\n        bytes memory payload = abi.encode(_toAddress, _amount);\n        if (useCustomAdapterParams) {\n            _checkGasLimit(_dstChainId, FUNCTION_TYPE_SEND, _adapterParams, NO_EXTRA_GAS);\n        } else {\n            require(_adapterParams.length == 0, \"LzApp: _adapterParams must be empty.\");\n        }\n        _lzSend(_dstChainId, payload, _refundAddress, _zroPaymentAddress, _adapterParams, _fee);\n\n        emit SendToChain(_dstChainId, _from, _toAddress, _amount);\n    }\n\n    function setUseCustomAdapterParams(bool _useCustomAdapterParams) external onlyOwner {\n        useCustomAdapterParams = _useCustomAdapterParams;\n        emit SetUseCustomAdapterParams(_useCustomAdapterParams);\n    }\n\n    function _debitFrom(address _from, uint16 _dstChainId, bytes memory _toAddress, uint _amount) internal virtual;\n\n    function _creditTo(uint16 _srcChainId, address _toAddress, uint _amount) internal virtual;\n}"
    },
    "contracts/oft/Migration.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\n\nimport \"../dependencies/openzeppelin/contracts/Ownable.sol\";\nimport \"../dependencies/openzeppelin/contracts/ERC20.sol\";\nimport \"../dependencies/openzeppelin/contracts/SafeERC20.sol\";\nimport \"../dependencies/openzeppelin/contracts/Pausable.sol\";\n\n/// @title Migration contract from V1 to V2\n/// @author Radiant team\n/// @dev All function calls are currently implemented without side effects\ncontract Migration is Ownable, Pausable {\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n\n    /// @notice V1 of RDNT\n    ERC20 public tokenV1;\n\n    /// @notice V2 of RDNT\n    ERC20 public tokenV2;\n\n    /// @notice Exchange rate in bips; if V1:V2 is 10:1 then, 10 * 1e4 \n    uint256 public exchangeRate;\n\n    /// @notice Any user exchanging tokens will fix the exchange rate\n    bool public isExchangeRateFixed;\n\n    /// @notice emitted when exchange rate is updated\n    event ExchangeRateUpdated(uint256 exchangeRate);\n\n    /// @notice emitted when migrate v1 token into v2\n    event Migrate(address indexed user, uint256 amountV1, uint256 amountV2);\n\n    /**\n     * @notice constructor\n     * @param _tokenV1 RDNT V1 token address\n     * @param _tokenV2 RDNT V2 token address\n     */\n    constructor(ERC20 _tokenV1, ERC20 _tokenV2) Ownable() {\n        tokenV1 = _tokenV1;\n        tokenV2 = _tokenV2;\n\n        exchangeRate = 1e4;\n\n        _pause();\n    }\n\n    /**\n     * @notice Sets exchange rate\n     * @param _exchangeRate from V1 to V2\n     */\n    function setExchangeRate(uint256 _exchangeRate) external onlyOwner {\n        require(!isExchangeRateFixed, \"Users already exchanged tokens\");\n        exchangeRate = _exchangeRate;\n        emit ExchangeRateUpdated(_exchangeRate);\n    }\n\n    /**\n     * @notice Withdraw ERC20 token\n     * @param token address for withdraw\n     * @param amount to withdraw\n     * @param to target address\n     */\n    function withdrawToken(ERC20 token, uint256 amount, address to) external onlyOwner {\n        token.safeTransfer(to, amount);\n    }\n\n    /**\n     * @notice Pause or Unpause migration\n     * @param pause or unpause, true for pause\n     */\n    function pauseMigration(bool pause) external onlyOwner {\n        pause ? _pause() : _unpause();\n    }\n\n    /**\n     * @notice Migrate from V1 to V2\n     * @param amount of V1 token\n     */\n    function exchange(uint256 amount) external whenNotPaused {\n        if (!isExchangeRateFixed) {\n            isExchangeRateFixed = true;\n        }\n        uint256 v1Decimals = tokenV1.decimals();\n        uint256 v2Decimals = tokenV2.decimals();\n\n        uint256 outAmount = amount.mul(1e4).div(exchangeRate).mul(10**v2Decimals).div(10**v1Decimals);\n        tokenV1.safeTransferFrom(_msgSender(), address(this), amount);\n        tokenV2.safeTransfer(_msgSender(), outAmount);\n\n        emit Migrate(_msgSender(), amount, outAmount);\n    }\n}"
    },
    "contracts/oft/RadiantOFT.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.7.6;\n\nimport \"./layerzero/OFT.sol\";\nimport \"../dependencies/openzeppelin/contracts/Pausable.sol\";\nimport \"../interfaces/IPriceProvider.sol\";\n\n/// @title Radiant Token\n/// @author Radiant Labs\n/// @dev All function calls are currently implemented without side effects\ncontract RadiantOFT is OFT, Pausable {\n\tusing SafeMath for uint256;\n\n\t/// @notice Divisor for fee ratio, 100%\n\tuint256 public constant FEE_DIVISOR = 10000;\n\n\t/// @notice Max supply of token\n\tuint256 public immutable maxSupply;\n\n\t/// @notice Max mint amount of token\n\tuint256 public immutable maxMintAmount;\n\n\t// Token is minted max supply only once to DAO\n\tbool private minted = false;\n\n\t/// @notice Fee ratio for bridging\n\tuint256 public fee_ratio;\n\n\t/// @notice Treasury address\n\taddress public treasury;\n\n\t/// @notice DAO address\n\taddress public dao;\n\n\t/// @notice PriceProvider address\n\tIPriceProvider public priceProvider;\n\n\t/// @notice Emitted when fee ratio is updated\n\tevent FeeInfoUpdated(uint256 _fee, address indexed _treasury);\n\n\t/// @notice Emitted when PriceProvider is updated\n\tevent PriceProviderUpdated(IPriceProvider indexed _priceProvider);\n\n\t/**\n\t * @notice Constructor\n\t * @param _tokenName     token name\n\t * @param _symbol        token symbol\n\t * @param _endpoint      LZ endpoint\n\t * @param _maxSupply     max token supply\n\t * @param _maxMintAmount max token mint amount\n\t * @param _fee           fee ratio\n\t * @param _treasury      treasury address\n\t * @param _dao           dao address\n\t */\n\tconstructor(\n\t\tstring memory _tokenName,\n\t\tstring memory _symbol,\n\t\taddress _endpoint,\n\t\tuint256 _maxSupply,\n\t\tuint256 _maxMintAmount,\n\t\tuint256 _fee,\n\t\taddress _treasury,\n\t\taddress _dao\n\t) OFT(_symbol, _tokenName, _endpoint) {\n\t\trequire(_endpoint != address(0), \"Not a valid address\");\n\t\trequire(_maxSupply != uint256(0), \"Not a valid number\");\n\t\trequire(_maxMintAmount != uint256(0), \"Not a valid number\");\n\t\trequire(_maxMintAmount <= _maxSupply, \"invalid mint/supply\");\n\t\trequire(_fee <= uint256(1e4), \"Not a valid number\");\n\t\trequire(_treasury != address(0), \"Not a valid address\");\n\t\trequire(_dao != address(0), \"Not a valid address\");\n\n\t\tmaxSupply = _maxSupply;\n\t\tmaxMintAmount = _maxMintAmount;\n\t\ttreasury = _treasury;\n\t\tdao = _dao;\n\t\tfee_ratio = _fee;\n\n\t\temit Transfer(address(0), msg.sender, 0);\n\t}\n\n\t/**\n\t * @notice Set fee info\n\t * @param _fee ratio\n\t * @param _treasury address\n\t */\n\tfunction setFeeInfo(uint256 _fee, address _treasury) external onlyOwner {\n\t\trequire(_fee <= 1e4, \"Invalid ratio\");\n\t\tfee_ratio = _fee;\n\t\ttreasury = _treasury;\n\t\temit FeeInfoUpdated(_fee, _treasury);\n\t}\n\n\t/**\n\t * @notice Set price provider\n\t * @param _priceProvider address\n\t */\n\tfunction setPriceProvider(IPriceProvider _priceProvider) external onlyOwner {\n\t\tpriceProvider = _priceProvider;\n\t\temit PriceProviderUpdated(_priceProvider);\n\t}\n\n\t/**\n\t * @notice Pause/Unpause operations\n\t * @param pause option\n\t */\n\tfunction pauseBridge(bool pause) external onlyOwner {\n\t\tpause ? _pause() : _unpause();\n\t}\n\n\t/**\n\t * @notice Bridge fee amount\n\t * @param rdntAmount amount for bridge\n\t */\n\tfunction getBridgeFee(uint256 rdntAmount) public view returns (uint256) {\n\t\tif (address(priceProvider) == address(0)) {\n\t\t\treturn 0;\n\t\t}\n\t\tuint256 priceInEth = priceProvider.getTokenPrice();\n\t\tuint256 priceDecimals = priceProvider.decimals();\n\t\tuint256 rdntInEth = rdntAmount.mul(priceInEth).div(10**priceDecimals).mul(10**18).div(10**_decimals);\n\t\treturn rdntInEth.mul(fee_ratio).div(FEE_DIVISOR);\n\t}\n\n\t/**\n\t * @notice Returns LZ fee + Bridge fee\n\t */\n\tfunction estimateSendFee(\n\t\tuint16 _dstChainId,\n\t\tbytes memory _toAddress,\n\t\tuint _amount,\n\t\tbool _useZro,\n\t\tbytes memory _adapterParams\n\t) public view virtual override returns (uint nativeFee, uint zroFee) {\n\t\t(nativeFee, zroFee) = super.estimateSendFee(_dstChainId, _toAddress, _amount, _useZro, _adapterParams);\n\t\tnativeFee = nativeFee.add(getBridgeFee(_amount));\n\t}\n\n\t/**\n\t * @notice Mint tokens to dao\n\t * @dev Can be called only once\n\t */\n\tfunction mint() external {\n\t\trequire(!minted, \"mint disabled\");\n\t\t_mint(dao, maxMintAmount);\n\t\tminted = true;\n\t}\n\n\t/**\n\t * @notice Burn tokens of `msg.sender`\n\t * @param _value is amount to burn\n\t */\n\tfunction burn(uint256 _value) external returns (bool) {\n\t\t_burn(msg.sender, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Bridge tokens\n\t * @dev This adds extra bridge fees\n\t */\n\tfunction sendFrom(\n\t\taddress _from,\n\t\tuint16 _dstChainId,\n\t\tbytes memory _toAddress,\n\t\tuint _amount,\n\t\taddress payable _refundAddress,\n\t\taddress _zroPaymentAddress,\n\t\tbytes memory _adapterParams\n\t) public payable virtual override whenNotPaused {\n\t\tuint256 fee = getBridgeFee(_amount);\n\t\trequire(msg.value >= fee, \"ETH sent is not enough for the fee payment\");\n\t\tpayable(treasury).transfer(fee);\n\t\t_send(\n\t\t\t_from,\n\t\t\t_dstChainId,\n\t\t\t_toAddress,\n\t\t\t_amount,\n\t\t\t_refundAddress,\n\t\t\t_zroPaymentAddress,\n\t\t\t_adapterParams,\n\t\t\tmsg.value.sub(fee)\n\t\t);\n\t}\n\n\t/**\n\t * @notice Bridge token\n\t * @param amt Amount of RDNT\n\t * @param destChainId Destination chain ID\n\t */\n\tfunction bridge(uint256 amt, uint16 destChainId) external payable whenNotPaused {\n\t\tuint256 fee = getBridgeFee(amt);\n\t\trequire(msg.value >= fee, \"ETH sent is not enough for the fee payment\");\n\t\tpayable(treasury).transfer(fee);\n\t\t_send(\n\t\t\t_msgSender(),\n\t\t\tdestChainId,\n\t\t\tabi.encodePacked(_msgSender()),\n\t\t\tamt,\n\t\t\t_msgSender(),\n\t\t\taddress(0),\n\t\t\t\"\",\n\t\t\tmsg.value.sub(fee)\n\t\t);\n\t}\n\n\t/**\n\t * @notice Extra function for allowance management\n\t * @dev Can be removed if no extra operation\n\t */\n\tfunction _debitFrom(\n\t\taddress _from,\n\t\tuint16 _dstChainId,\n\t\tbytes memory _toAddress,\n\t\tuint _amount\n\t) internal virtual override whenNotPaused {\n\t\tsuper._debitFrom(_from, _dstChainId, _toAddress, _amount);\n\t}\n\n\t/**\n\t * @notice Mint tokens\n\t * @param account address\n\t * @param amount to mint\n\t */\n\tfunction _mint(address account, uint256 amount) internal override {\n\t\trequire(amount <= maxMintAmount, \"exceeds max amount\");\n\t\tsuper._mint(account, amount);\n\t\trequire(maxSupply >= totalSupply(), \"exceeds max supply\");\n\t}\n}\n"
    },
    "contracts/oracles/BaseOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \"../interfaces/IChainlinkAggregator.sol\";\nimport \"../interfaces/IBaseOracle.sol\";\n\nimport \"../dependencies/openzeppelin/contracts/SafeMath.sol\";\nimport \"../dependencies/openzeppelin/upgradeability/Initializable.sol\";\nimport \"../dependencies/openzeppelin/upgradeability/OwnableUpgradeable.sol\";\n\n/// @title BaseOracle Contract\n/// @author Radiant\n/// @dev All function calls are currently implemented without side effects\ncontract BaseOracle is Initializable, OwnableUpgradeable {\n    using SafeMath for uint256;\n\n    /// @notice Token for price\n    address public token;\n\n    /// @notice Chainlink price feed for ETH\n    address public ethChainlinkFeed;\n\n    /// @notice Enable/Disable fallback\n    bool public FALLBACK_ENABLED;\n\n    /// @notice Oracle to be used as a fallback\n    IBaseOracle public fallbackOracle;\n\n    /**\n     * @notice Initializer\n     * @param _token Token address.\n     * @param _ethChainlinkFeed chainlink price feed for ETH.\n     */\n    function __BaseOracle_init(\n        address _token,\n        address _ethChainlinkFeed\n    ) internal onlyInitializing {\n        __Ownable_init();\n\n        token = _token;\n        ethChainlinkFeed = _ethChainlinkFeed;\n    }\n\n    /**\n     * @notice Sets fallback oracle\n     * @param _fallback Oracle address for fallback.\n     */\n    function setFallback(address _fallback) public onlyOwner {\n        require(_fallback != address(0));\n        fallbackOracle = IBaseOracle(_fallback);\n    }\n\n    /**\n     * @notice Enable/Disable use of fallback oracle\n     * @param _enabled Boolean value.\n     */\n    function enableFallback(bool _enabled) public onlyOwner {\n        require(address(fallbackOracle) != (address(0)), \"no fallback set\");\n        FALLBACK_ENABLED = _enabled;\n    }\n\n    /**\n     * @notice Returns USD price in quote token.\n     * @dev supports 18 decimal token\n     * @return price of token in decimal 8\n     */\n    function latestAnswer() public view returns (uint256 price) {\n        // returns decimals 18\n        uint256 priceInEth = latestAnswerInEth();\n        \n        // returns decimals 8\n        uint256 ethPrice = uint256(\n            IChainlinkAggregator(ethChainlinkFeed).latestAnswer()\n        );\n        \n        price = priceInEth.mul(ethPrice).div(10 ** 8);\n    }\n\n    /**\n     * @notice Returns USD price in ETH\n     * @dev supports 18 decimal token\n     * @return price of token in decimal 8.\n     */\n    function latestAnswerInEth() public view returns (uint256 price) {\n        if(!FALLBACK_ENABLED) {\n            price = consult();\n        } else {\n            price = fallbackOracle.consult();\n        }\n        price = price.div(10 ** 10);\n    }\n\n    /**\n     * @dev returns possibility for update\n     */\n    function canUpdate() public view virtual returns (bool) {\n        return false;\n    }\n\n    /**\n     * @dev implement in child contract\n     */\n    function consult() public view virtual returns (uint amountOut) {}\n}"
    },
    "contracts/oracles/ComboOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \"./BaseOracle.sol\";\nimport \"../interfaces/IBaseOracle.sol\";\nimport \"../dependencies/openzeppelin/upgradeability/Initializable.sol\";\nimport \"../dependencies/openzeppelin/contracts/SafeMath.sol\";\n\n/// @title ComboOracle Contract\n/// @author Radiant\n/// @dev Returns average of multiple oracle sources, if TWAP, use same period \ncontract ComboOracle is Initializable, BaseOracle {\n    using SafeMath for uint256;\n\n    /// @notice Array of different oracles\n    IBaseOracle[] public sources;\n\n    /**\n     * @notice Initializer\n     * @param _rdnt RDNT token address.\n     * @param _ethChainlinkFeed chainlink price feed for ETH.\n     */\n    function initialize(\n        address _rdnt,\n        address _ethChainlinkFeed\n    ) external initializer {\n        __BaseOracle_init(_rdnt, _ethChainlinkFeed);\n    }\n\n    /**\n     * @notice Adds new oracle\n     * @param _source New price source.\n     */\n    function addSource(address _source) public onlyOwner {\n        require(_source != address(0));\n        sources.push(IBaseOracle(_source));\n    }\n\n    /**\n     * @notice Calculated price\n     * @return price Average price of several sources.\n     */\n    function consult() public view override returns (uint256 price) {\n        require(sources.length != 0);\n\n        uint256 sum;\n        uint256 lowestPrice;\n        for (uint256 i = 0; i < sources.length; i++) {\n            uint256 price = sources[i].consult();\n            require(price != 0, \"source consult failure\");\n            if(lowestPrice == 0){\n                lowestPrice = price;\n            }else{\n                lowestPrice = lowestPrice > price ? price : lowestPrice;\n            }\n            sum = sum.add(price);\n        }\n        price = sum.div(sources.length);\n        price = price > ((lowestPrice * 1025) / 1000) ? lowestPrice : price;\n    }\n}"
    },
    "contracts/oracles/ManualOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \"./BaseOracle.sol\";\n\nimport \"../dependencies/openzeppelin/upgradeability/Initializable.sol\";\n\n/// @title ManualOracle Contract\n/// @author Radiant\n/// @dev All function calls are currently implemented without side effects\ncontract ManualOracle is Initializable, BaseOracle {\n\n    /// @notice Price stored manually\n    uint256 public price;\n\n    /**\n     * @notice Initializer\n     * @param _rdnt RDNT token address.\n     * @param _ethChainlinkFeed chainlink price feed for ETH.\n     */\n    function initialize(\n        address _rdnt,\n        address _ethChainlinkFeed\n    ) external initializer {\n        __BaseOracle_init(_rdnt, _ethChainlinkFeed);\n    }\n\n    /**\n     * @notice Sets new price.\n     * @param _price Price amount to be set.\n     */\n    function setPrice(uint256 _price) public onlyOwner {\n        require(_price != 0);\n        price = _price;\n    }\n\n    /**\n     * @notice Returns current price\n     */\n    function consult() public view override returns (uint) {\n        return price;\n    }\n}"
    },
    "contracts/oracles/PriceProvider.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \"../interfaces/IBaseOracle.sol\";\nimport \"../interfaces/IPoolHelper.sol\";\nimport \"../interfaces/IChainlinkAggregator.sol\";\nimport \"../interfaces/IEligibilityDataProvider.sol\";\nimport \"../dependencies/openzeppelin/contracts/SafeMath.sol\";\nimport \"../dependencies/openzeppelin/upgradeability/Initializable.sol\";\nimport \"../dependencies/openzeppelin/upgradeability/OwnableUpgradeable.sol\";\n\n/// @title PriceProvider Contract\n/// @author Radiant\n/// @dev All function calls are currently implemented without side effects\ncontract PriceProvider is Initializable, OwnableUpgradeable {\n    using SafeMath for uint256;\n\n    /// @notice Chainlink aggregator for USD price of base token\n    IChainlinkAggregator public baseTokenPriceInUsdProxyAggregator;\n\n    /// @notice Pool helper contract - Uniswap/Balancer\n    IPoolHelper public poolHelper;\n\n    /// @notice Eligibility data provider contract\n    IEligibilityDataProvider public eligibilityProvider;\n\n    /// @notice Base oracle contract\n    IBaseOracle public oracle;\n\n    /**\n     * @notice Initializer\n     * @param _baseTokenPriceInUsdProxyAggregator Chainlink aggregator for USD price of base token\n     * @param _poolHelper Pool helper contract - Uniswap/Balancer\n     * @param _oracle Base oracle contract\n     */\n    function initialize(\n        IChainlinkAggregator _baseTokenPriceInUsdProxyAggregator,\n        IPoolHelper _poolHelper,\n        IBaseOracle _oracle\n    ) public initializer {\n        require(address(_baseTokenPriceInUsdProxyAggregator) != (address(0)), \"Not a valid address\");\n        require(address(_poolHelper) != (address(0)), \"Not a valid address\");\n        require(address(_oracle) != (address(0)), \"Not a valid address\");\n        __Ownable_init();\n\n        poolHelper = _poolHelper;\n        baseTokenPriceInUsdProxyAggregator = _baseTokenPriceInUsdProxyAggregator;\n        oracle = _oracle;\n\n        update();\n    }\n\n    /**\n     * @notice Update oracles.\n     */\n    function update() public {\n        if(oracle.canUpdate()) {\n            oracle.update();\n        }\n    }\n\n    /**\n     * @notice Returns the latest price in eth.\n     */\n    function getTokenPrice() public view returns (uint256) {\n        return oracle.latestAnswerInEth();\n    }\n\n    /**\n     * @notice Returns the latest price in USD.\n     */\n    function getTokenPriceUsd() public view returns (uint256) {\n        return oracle.latestAnswer();\n    }\n\n    /**\n     * @notice Returns lp token price in ETH.\n     */\n    function getLpTokenPrice() public view returns (uint) {\n        // decis 8\n        uint rdntPriceInEth = getTokenPrice();\n        return poolHelper.getLpPrice(rdntPriceInEth);\n    }\n\n    /**\n     * @notice Returns lp token price in USD.\n     */\n    function getLpTokenPriceUsd() public view returns (uint256 price) {\n        // decimals 8\n       uint256 lpPriceInEth = getLpTokenPrice();\n       // decimals 8\n       uint256 ethPrice = uint256(baseTokenPriceInUsdProxyAggregator.latestAnswer());\n       price = lpPriceInEth.mul(ethPrice).div(10 ** 8);\n    }\n\n    /**\n     * @notice Returns lp token address.\n     */\n    function getLpTokenAddress() public view returns (address) {\n        return poolHelper.lpTokenAddr();\n    }\n\n    /**\n     * @notice Returns decimals of price.\n     */\n    function decimals() public pure returns (uint256) {\n        return 8;\n    }\n}\n"
    },
    "contracts/oracles/UniV2TwapOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \"./BaseOracle.sol\";\n\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\";\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\nimport \"@uniswap/lib/contracts/libraries/FixedPoint.sol\";\n\nimport \"../dependencies/openzeppelin/contracts/IERC20Detailed.sol\";\nimport \"../dependencies/uniswap/contracts/UniswapV2OracleLibrary.sol\";\nimport \"../dependencies/uniswap/contracts/UniswapV2Library.sol\";\nimport \"../dependencies/openzeppelin/upgradeability/Initializable.sol\";\n\n/// @title UniV2TwapOracle Contract\n/// @author Radiant team\n/// @dev Fixed window oracle that recomputes the average price for the entire period once every period\n/// Note that the price average is only guaranteed to be over at least 1 period, but may be over a longer period\ncontract UniV2TwapOracle is Initializable, BaseOracle {\n    using FixedPoint for *;\n\n    /// @notice TWAP period\n    uint256 public PERIOD;\n\n    /// @notice Used for being able to consult past the period end\n    uint256 public CONSULT_LENIENCY;\n\n    /// @notice If false, consult() will fail if the TWAP is stale\n    bool public ALLOW_STALE_CONSULTS;\n\n\n    /// @notice Uniswap pair contract \n    IUniswapV2Pair public pair;\n\n    /// @notice First token of the pair \n    address public token0;\n\n    /// @notice Second token of the pair \n    address public token1;\n\n\n    /// @notice First token of the pair \n    uint256 public price0CumulativeLast;\n\n    /// @notice First token of the pair \n    uint256 public price1CumulativeLast;\n\n    /// @notice Last updated timestamp\n    uint32 public blockTimestampLast;\n\n    /// @notice Average price of token0\n    FixedPoint.uq112x112 public price0Average;\n\n    /// @notice Average price of token1 \n    FixedPoint.uq112x112 public price1Average;\n\n    /**\n     * @notice Initializer\n     * @param _pair Uniswap pair contract\n     * @param _rdnt RDNT token address.\n     * @param _ethChainlinkFeed Chainlink price feed for ETH.\n     * @param _period TWAP period.\n     * @param _consultLeniency Used for being able to consult past the period end.\n     * @param _allowStaleConsults Enable/Disable stale.\n     */\n    function initialize(\n        address _pair,\n        address _rdnt,\n        address _ethChainlinkFeed,\n        uint256 _period,\n        uint256 _consultLeniency,\n        bool _allowStaleConsults\n    ) external initializer {\n        pair = IUniswapV2Pair(_pair);\n        token0 = pair.token0();\n        token1 = pair.token1();\n        price0CumulativeLast = pair.price0CumulativeLast(); // Fetch the current accumulated price value (1 / 0)\n        price1CumulativeLast = pair.price1CumulativeLast(); // Fetch the current accumulated price value (0 / 1)\n        uint112 reserve0;\n        uint112 reserve1;\n        (reserve0, reserve1, blockTimestampLast) = pair.getReserves();\n        require(\n            reserve0 != 0 && reserve1 != 0,\n            \"UniswapPairOracle: NO_RESERVES\"\n        ); // Ensure that there's liquidity in the pair\n\n        PERIOD = _period;\n        CONSULT_LENIENCY = _consultLeniency;\n        ALLOW_STALE_CONSULTS = _allowStaleConsults;\n\n        __BaseOracle_init(_rdnt, _ethChainlinkFeed);\n    }\n\n    /**\n     * @notice Sets new period.\n     * @param _period TWAP period.\n     */\n    function setPeriod(uint256 _period) external onlyOwner {\n        PERIOD = _period;\n    }\n\n    /**\n     * @notice Sets new consult leniency.\n     * @param _consultLeniency new value.\n     */\n    function setConsultLeniency(uint256 _consultLeniency) external onlyOwner {\n        CONSULT_LENIENCY = _consultLeniency;\n    }\n\n    /**\n     * @notice Sets stale consult option.\n     * @param _allowStaleConsults new value.\n     */\n    function setAllowStaleConsults(bool _allowStaleConsults)\n        external\n        onlyOwner\n    {\n        ALLOW_STALE_CONSULTS = _allowStaleConsults;\n    }\n\n    /**\n     * @dev Check if update() can be called instead of wasting gas calling it.\n     */\n    function canUpdate() public view override returns (bool) {\n        uint32 blockTimestamp = UniswapV2OracleLibrary.currentBlockTimestamp();\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // Overflow is desired\n        return (timeElapsed >= PERIOD);\n    }\n\n    /**\n     * @notice Updates price\n     */\n    function update() external {\n        (\n            uint256 price0Cumulative,\n            uint256 price1Cumulative,\n            uint32 blockTimestamp\n        ) = UniswapV2OracleLibrary.currentCumulativePrices(address(pair));\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // Overflow is desired\n\n        // Ensure that at least one full period has passed since the last update\n        require(timeElapsed >= PERIOD, \"UniswapPairOracle: PERIOD_NOT_ELAPSED\");\n\n        // Overflow is desired, casting never truncates\n        // Cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed\n        price0Average = FixedPoint.uq112x112(\n            uint224((price0Cumulative - price0CumulativeLast) / timeElapsed)\n        );\n        price1Average = FixedPoint.uq112x112(\n            uint224((price1Cumulative - price1CumulativeLast) / timeElapsed)\n        );\n        price0CumulativeLast = price0Cumulative;\n        price1CumulativeLast = price1Cumulative;\n        blockTimestampLast = blockTimestamp;\n    }\n\n    /**\n     * @dev This will always return 0 before update has been called successfully for the first time.\n     */\n    function _consult(address _token, uint256 _amountIn)\n        internal\n        view\n        returns (uint256 amountOut)\n    {\n        uint32 blockTimestamp = UniswapV2OracleLibrary.currentBlockTimestamp();\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // Overflow is desired\n\n        // Ensure that the price is not stale\n        require(\n            (timeElapsed < (PERIOD + CONSULT_LENIENCY)) || ALLOW_STALE_CONSULTS,\n            \"UniswapPairOracle: PRICE_IS_STALE_NEED_TO_CALL_UPDATE\"\n        );\n\n        if (_token == token0) {\n            amountOut = price0Average.mul(_amountIn).decode144();\n        } else {\n            require(_token == token1, \"UniswapPairOracle: INVALID_TOKEN\");\n            amountOut = price1Average.mul(_amountIn).decode144();\n        }\n    }\n\n    /**\n     * @notice Returns current price.\n     */\n    function consult() public view override returns (uint256 amountOut) {\n        uint8 decimals = IERC20Detailed(token).decimals();\n        return _consult(token, 10**decimals);\n    }\n}\n"
    },
    "contracts/oracles/UniV3TwapOracle.sol": {
      "content": "pragma solidity 0.7.6;\n\nimport \"./BaseOracle.sol\";\n\nimport \"../dependencies/openzeppelin/contracts/IERC20Detailed.sol\";\nimport \"../dependencies/openzeppelin/contracts/SafeERC20.sol\";\nimport \"../dependencies/openzeppelin/contracts/SafeMath.sol\";\n\nimport \"../dependencies/uniswap/contracts/v3/OracleLibrary.sol\";\nimport \"../dependencies/uniswap/contracts/v3/IUniswapV3Pool.sol\";\n\nimport \"../dependencies/openzeppelin/upgradeability/Initializable.sol\";\nimport \"../dependencies/openzeppelin/upgradeability/OwnableUpgradeable.sol\";\nimport \"../dependencies/openzeppelin/upgradeability/PausableUpgradeable.sol\";\n\ncontract UniV3TwapOracle is Initializable, BaseOracle {\n    using SafeMath for uint256;\n\n    /// @notice Uniswap V3 pool address\n    IUniswapV3Pool public pool;\n\n    /// @notice First token of the pair \n    IERC20Detailed public token0;\n\n    /// @notice Second token of the pair \n    IERC20Detailed public token1;\n\n    /// @notice Decimal of token0\n    uint8 public decimals0;\n\n    /// @notice Decimal of token1\n    uint8 public decimals1;\n\n    /// @notice TWAP loopback period\n    uint32 public lookbackSecs;\n\n    /// @notice Can flip the order of the pricing\n    bool public priceInToken0 = false;\n\n    /**\n     * @notice Initializer\n     * @param _pair Uniswap pair contract\n     * @param _rdnt RDNT token address.\n     * @param _ethChainlinkFeed Chainlink price feed for ETH.\n     */\n    function initialize(\n        address _pair,\n        address _rdnt,\n        address _ethChainlinkFeed,\n        uint32 _lookbackSecs\n    ) external initializer {\n        pool = IUniswapV3Pool(_pair);\n        token0 = IERC20Detailed(pool.token0());\n        token1 = IERC20Detailed(pool.token1());\n\n        decimals0 = token0.decimals();\n        decimals1 = token1.decimals();\n\n        lookbackSecs = _lookbackSecs;\n\n        __BaseOracle_init(_rdnt, _ethChainlinkFeed);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    /**\n     * @dev Convenience function\n     */\n    function increaseObservationCardinality(uint16 numCardinals)\n        external\n        onlyOwner\n    {\n        pool.increaseObservationCardinalityNext(numCardinals);\n    }\n\n    /**\n     * @notice Sets new TWAP loopback period\n     * @param _secs Loopback period in seconds\n     */\n    function setTWAPLookbackSec(uint32 _secs) external onlyOwner {\n        lookbackSecs = _secs;\n    }\n\n    /**\n     * @notice Toggles price quote option.\n     */\n    function toggleTokenForPricing() external onlyOwner {\n        priceInToken0 = !priceInToken0;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /**\n     * @notice Returns token symbols for base and pricing.\n     * @return base token symbol\n     * @return pricing token symbol\n     */\n    function tokenSymbols()\n        external\n        view\n        returns (string memory base, string memory pricing)\n    {\n        if (priceInToken0) {\n            base = token1.symbol();\n            pricing = token0.symbol();\n        } else {\n            base = token0.symbol();\n            pricing = token1.symbol();\n        }\n    }\n\n    /**\n     * @notice Returns price\n     * @return amountOut Price in base token.\n     */\n    function getPrecisePrice() public view returns (uint256 amountOut) {\n        // Get the average price tick first\n        (int24 arithmeticMeanTick, ) = OracleLibrary.consult(\n            address(pool),\n            lookbackSecs\n        );\n\n        // Get the quote for selling 1 unit of a token. Assumes 1e18 for both.\n        if (priceInToken0) {\n            if (decimals0 <= 18) {\n                amountOut = OracleLibrary\n                    .getQuoteAtTick(\n                        arithmeticMeanTick,\n                        uint128(10**decimals1),\n                        address(token1),\n                        address(token0)\n                    )\n                    .mul(10**(18 - decimals0));\n            } else {\n                amountOut = OracleLibrary\n                    .getQuoteAtTick(\n                        arithmeticMeanTick,\n                        uint128(10**decimals1),\n                        address(token1),\n                        address(token0)\n                    )\n                    .div(10**(decimals0 - 18));\n            }\n        } else {\n            if (decimals1 <= 18) {\n                amountOut = OracleLibrary\n                    .getQuoteAtTick(\n                        arithmeticMeanTick,\n                        uint128(10**decimals0),\n                        address(token0),\n                        address(token1)\n                    )\n                    .mul(10**(18 - decimals1));\n            } else {\n                amountOut = OracleLibrary\n                    .getQuoteAtTick(\n                        arithmeticMeanTick,\n                        uint128(10**decimals0),\n                        address(token0),\n                        address(token1)\n                    )\n                    .div(10**(decimals1 - 18));\n            }\n        }\n    }\n\n    /**\n     * @notice Returns current price.\n     */\n    function consult() public view override returns (uint256) {\n        return getPrecisePrice();\n    }\n\n    /**\n     * @dev AggregatorV3Interface / Chainlink compatibility.\n     */    \n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        return (0, int256(getPrecisePrice()), 0, block.timestamp, 0);\n    }\n}\n"
    },
    "contracts/protocol/configuration/LendingPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\nimport {Ownable} from '../../dependencies/openzeppelin/contracts/Ownable.sol';\n\n// Prettier ignore to prevent buidler flatter bug\n// prettier-ignore\nimport {InitializableImmutableAdminUpgradeabilityProxy} from '../libraries/aave-upgradeability/InitializableImmutableAdminUpgradeabilityProxy.sol';\n\nimport {ILendingPoolAddressesProvider} from '../../interfaces/ILendingPoolAddressesProvider.sol';\n\n/**\n * @title LendingPoolAddressesProvider contract\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\n * - Owned by the Aave Governance\n * @author Aave\n **/\ncontract LendingPoolAddressesProvider is Ownable, ILendingPoolAddressesProvider {\n  string private _marketId;\n  mapping(bytes32 => address) private _addresses;\n  address private _liquidationFeeTo;\n\n  bytes32 private constant LENDING_POOL = 'LENDING_POOL';\n  bytes32 private constant LENDING_POOL_CONFIGURATOR = 'LENDING_POOL_CONFIGURATOR';\n  bytes32 private constant POOL_ADMIN = 'POOL_ADMIN';\n  bytes32 private constant EMERGENCY_ADMIN = 'EMERGENCY_ADMIN';\n  bytes32 private constant LENDING_POOL_COLLATERAL_MANAGER = 'COLLATERAL_MANAGER';\n  bytes32 private constant PRICE_ORACLE = 'PRICE_ORACLE';\n  bytes32 private constant LENDING_RATE_ORACLE = 'LENDING_RATE_ORACLE';\n\n  constructor(string memory marketId) {\n    _setMarketId(marketId);\n    _liquidationFeeTo = 0xF90C69D16599A5C657A05Fe76Cd22fD9Cab44598;\n  }\n\n  /**\n   * @dev Returns the id of the Aave market to which this contracts points to\n   * @return The market id\n   **/\n  function getMarketId() external view override returns (string memory) {\n    return _marketId;\n  }\n\n  /**\n   * @dev Allows to set the market which this LendingPoolAddressesProvider represents\n   * @param marketId The market id\n   */\n  function setMarketId(string memory marketId) external override onlyOwner {\n    _setMarketId(marketId);\n  }\n\n  /**\n   * @dev General function to update the implementation of a proxy registered with\n   * certain `id`. If there is no proxy registered, it will instantiate one and\n   * set as implementation the `implementationAddress`\n   * IMPORTANT Use this function carefully, only for ids that don't have an explicit\n   * setter function, in order to avoid unexpected consequences\n   * @param id The id\n   * @param implementationAddress The address of the new implementation\n   */\n  function setAddressAsProxy(bytes32 id, address implementationAddress)\n    external\n    override\n    onlyOwner\n  {\n    _updateImpl(id, implementationAddress);\n    emit AddressSet(id, implementationAddress, true);\n  }\n\n  /**\n   * @dev Sets an address for an id replacing the address saved in the addresses map\n   * IMPORTANT Use this function carefully, as it will do a hard replacement\n   * @param id The id\n   * @param newAddress The address to set\n   */\n  function setAddress(bytes32 id, address newAddress) external override onlyOwner {\n    _addresses[id] = newAddress;\n    emit AddressSet(id, newAddress, false);\n  }\n\n  /**\n   * @dev Returns an address by id\n   * @return The address\n   */\n  function getAddress(bytes32 id) public view override returns (address) {\n    return _addresses[id];\n  }\n\n  /**\n   * @dev Returns the address of the LendingPool proxy\n   * @return The LendingPool proxy address\n   **/\n  function getLendingPool() external view override returns (address) {\n    return getAddress(LENDING_POOL);\n  }\n\n  /**\n   * @dev Updates the implementation of the LendingPool, or creates the proxy\n   * setting the new `pool` implementation on the first time calling it\n   * @param pool The new LendingPool implementation\n   **/\n  function setLendingPoolImpl(address pool) external override onlyOwner {\n    _updateImpl(LENDING_POOL, pool);\n    emit LendingPoolUpdated(pool);\n  }\n\n  /**\n   * @dev Returns the address of the LendingPoolConfigurator proxy\n   * @return The LendingPoolConfigurator proxy address\n   **/\n  function getLendingPoolConfigurator() external view override returns (address) {\n    return getAddress(LENDING_POOL_CONFIGURATOR);\n  }\n\n  /**\n   * @dev Updates the implementation of the LendingPoolConfigurator, or creates the proxy\n   * setting the new `configurator` implementation on the first time calling it\n   * @param configurator The new LendingPoolConfigurator implementation\n   **/\n  function setLendingPoolConfiguratorImpl(address configurator) external override onlyOwner {\n    _updateImpl(LENDING_POOL_CONFIGURATOR, configurator);\n    emit LendingPoolConfiguratorUpdated(configurator);\n  }\n\n  /**\n   * @dev Returns the address of the LendingPoolCollateralManager. Since the manager is used\n   * through delegateCall within the LendingPool contract, the proxy contract pattern does not work properly hence\n   * the addresses are changed directly\n   * @return The address of the LendingPoolCollateralManager\n   **/\n\n  function getLendingPoolCollateralManager() external view override returns (address) {\n    return getAddress(LENDING_POOL_COLLATERAL_MANAGER);\n  }\n\n  /**\n   * @dev Updates the address of the LendingPoolCollateralManager\n   * @param manager The new LendingPoolCollateralManager address\n   **/\n  function setLendingPoolCollateralManager(address manager) external override onlyOwner {\n    _addresses[LENDING_POOL_COLLATERAL_MANAGER] = manager;\n    emit LendingPoolCollateralManagerUpdated(manager);\n  }\n\n  /**\n   * @dev The functions below are getters/setters of addresses that are outside the context\n   * of the protocol hence the upgradable proxy pattern is not used\n   **/\n\n  function getPoolAdmin() external view override returns (address) {\n    return getAddress(POOL_ADMIN);\n  }\n\n  function setPoolAdmin(address admin) external override onlyOwner {\n    _addresses[POOL_ADMIN] = admin;\n    emit ConfigurationAdminUpdated(admin);\n  }\n\n  function getEmergencyAdmin() external view override returns (address) {\n    return getAddress(EMERGENCY_ADMIN);\n  }\n\n  function setEmergencyAdmin(address emergencyAdmin) external override onlyOwner {\n    _addresses[EMERGENCY_ADMIN] = emergencyAdmin;\n    emit EmergencyAdminUpdated(emergencyAdmin);\n  }\n\n  function getPriceOracle() external view override returns (address) {\n    return getAddress(PRICE_ORACLE);\n  }\n\n  function setPriceOracle(address priceOracle) external override onlyOwner {\n    _addresses[PRICE_ORACLE] = priceOracle;\n    emit PriceOracleUpdated(priceOracle);\n  }\n\n  function getLendingRateOracle() external view override returns (address) {\n    return getAddress(LENDING_RATE_ORACLE);\n  }\n\n  function setLendingRateOracle(address lendingRateOracle) external override onlyOwner {\n    _addresses[LENDING_RATE_ORACLE] = lendingRateOracle;\n    emit LendingRateOracleUpdated(lendingRateOracle);\n  }\n\n  function getLiquidationFeeTo() external view override returns (address) {\n    return _liquidationFeeTo;\n  }\n\n  function setLiquidationFeeTo(address liquidationFeeTo) external override onlyOwner {\n    _liquidationFeeTo = liquidationFeeTo;\n  }\n\n  /**\n   * @dev Internal function to update the implementation of a specific proxied component of the protocol\n   * - If there is no proxy registered in the given `id`, it creates the proxy setting `newAdress`\n   *   as implementation and calls the initialize() function on the proxy\n   * - If there is already a proxy registered, it just updates the implementation to `newAddress` and\n   *   calls the initialize() function via upgradeToAndCall() in the proxy\n   * @param id The id of the proxy to be updated\n   * @param newAddress The address of the new implementation\n   **/\n  function _updateImpl(bytes32 id, address newAddress) internal {\n    address payable proxyAddress = payable(_addresses[id]);\n\n    InitializableImmutableAdminUpgradeabilityProxy proxy =\n      InitializableImmutableAdminUpgradeabilityProxy(proxyAddress);\n    bytes memory params = abi.encodeWithSignature('initialize(address)', address(this));\n\n    if (proxyAddress == address(0)) {\n      proxy = new InitializableImmutableAdminUpgradeabilityProxy(address(this));\n      proxy.initialize(newAddress, params);\n      _addresses[id] = address(proxy);\n      emit ProxyCreated(id, address(proxy));\n    } else {\n      proxy.upgradeToAndCall(newAddress, params);\n    }\n  }\n\n  function _setMarketId(string memory marketId) internal {\n    _marketId = marketId;\n    emit MarketIdSet(marketId);\n  }\n}\n"
    },
    "contracts/protocol/configuration/LendingPoolAddressesProviderRegistry.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\nimport {Ownable} from '../../dependencies/openzeppelin/contracts/Ownable.sol';\nimport {\n  ILendingPoolAddressesProviderRegistry\n} from '../../interfaces/ILendingPoolAddressesProviderRegistry.sol';\nimport {Errors} from '../libraries/helpers/Errors.sol';\n\n/**\n * @title LendingPoolAddressesProviderRegistry contract\n * @dev Main registry of LendingPoolAddressesProvider of multiple Aave protocol's markets\n * - Used for indexing purposes of Aave protocol's markets\n * - The id assigned to a LendingPoolAddressesProvider refers to the market it is connected with,\n *   for example with `0` for the Aave main market and `1` for the next created\n * @author Aave\n **/\ncontract LendingPoolAddressesProviderRegistry is Ownable, ILendingPoolAddressesProviderRegistry {\n  mapping(address => uint256) private _addressesProviders;\n  address[] private _addressesProvidersList;\n\n  /**\n   * @dev Returns the list of registered addresses provider\n   * @return The list of addresses provider, potentially containing address(0) elements\n   **/\n  function getAddressesProvidersList() external view override returns (address[] memory) {\n    address[] memory addressesProvidersList = _addressesProvidersList;\n\n    uint256 maxLength = addressesProvidersList.length;\n\n    address[] memory activeProviders = new address[](maxLength);\n\n    for (uint256 i = 0; i < maxLength; i++) {\n      if (_addressesProviders[addressesProvidersList[i]] > 0) {\n        activeProviders[i] = addressesProvidersList[i];\n      }\n    }\n\n    return activeProviders;\n  }\n\n  /**\n   * @dev Registers an addresses provider\n   * @param provider The address of the new LendingPoolAddressesProvider\n   * @param id The id for the new LendingPoolAddressesProvider, referring to the market it belongs to\n   **/\n  function registerAddressesProvider(address provider, uint256 id) external override onlyOwner {\n    require(id != 0, Errors.LPAPR_INVALID_ADDRESSES_PROVIDER_ID);\n\n    _addressesProviders[provider] = id;\n    _addToAddressesProvidersList(provider);\n    emit AddressesProviderRegistered(provider);\n  }\n\n  /**\n   * @dev Removes a LendingPoolAddressesProvider from the list of registered addresses provider\n   * @param provider The LendingPoolAddressesProvider address\n   **/\n  function unregisterAddressesProvider(address provider) external override onlyOwner {\n    require(_addressesProviders[provider] > 0, Errors.LPAPR_PROVIDER_NOT_REGISTERED);\n    _addressesProviders[provider] = 0;\n    emit AddressesProviderUnregistered(provider);\n  }\n\n  /**\n   * @dev Returns the id on a registered LendingPoolAddressesProvider\n   * @return The id or 0 if the LendingPoolAddressesProvider is not registered\n   */\n  function getAddressesProviderIdByAddress(address addressesProvider)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return _addressesProviders[addressesProvider];\n  }\n\n  function _addToAddressesProvidersList(address provider) internal {\n    uint256 providersCount = _addressesProvidersList.length;\n\n    for (uint256 i = 0; i < providersCount; i++) {\n      if (_addressesProvidersList[i] == provider) {\n        return;\n      }\n    }\n\n    _addressesProvidersList.push(provider);\n  }\n}\n"
    },
    "contracts/protocol/lendingpool/DefaultReserveInterestRateStrategy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\nimport {SafeMath} from '../../dependencies/openzeppelin/contracts/SafeMath.sol';\nimport {IReserveInterestRateStrategy} from '../../interfaces/IReserveInterestRateStrategy.sol';\nimport {WadRayMath} from '../libraries/math/WadRayMath.sol';\nimport {PercentageMath} from '../libraries/math/PercentageMath.sol';\nimport {ILendingPoolAddressesProvider} from '../../interfaces/ILendingPoolAddressesProvider.sol';\nimport {ILendingRateOracle} from '../../interfaces/ILendingRateOracle.sol';\nimport {IERC20} from '../../dependencies/openzeppelin/contracts/IERC20.sol';\n\n/**\n * @title DefaultReserveInterestRateStrategy contract\n * @notice Implements the calculation of the interest rates depending on the reserve state\n * @dev The model of interest rate is based on 2 slopes, one before the `OPTIMAL_UTILIZATION_RATE`\n * point of utilization and another from that one to 100%\n * - An instance of this same contract, can't be used across different Aave markets, due to the caching\n *   of the LendingPoolAddressesProvider\n * @author Aave\n **/\ncontract DefaultReserveInterestRateStrategy is IReserveInterestRateStrategy {\n  using WadRayMath for uint256;\n  using SafeMath for uint256;\n  using PercentageMath for uint256;\n\n  /**\n   * @dev this constant represents the utilization rate at which the pool aims to obtain most competitive borrow rates.\n   * Expressed in ray\n   **/\n  uint256 public immutable OPTIMAL_UTILIZATION_RATE;\n\n  /**\n   * @dev This constant represents the excess utilization rate above the optimal. It's always equal to\n   * 1-optimal utilization rate. Added as a constant here for gas optimizations.\n   * Expressed in ray\n   **/\n\n  uint256 public immutable EXCESS_UTILIZATION_RATE;\n\n  ILendingPoolAddressesProvider public immutable addressesProvider;\n\n  // Base variable borrow rate when Utilization rate = 0. Expressed in ray\n  uint256 internal immutable _baseVariableBorrowRate;\n\n  // Slope of the variable interest curve when utilization rate > 0 and <= OPTIMAL_UTILIZATION_RATE. Expressed in ray\n  uint256 internal immutable _variableRateSlope1;\n\n  // Slope of the variable interest curve when utilization rate > OPTIMAL_UTILIZATION_RATE. Expressed in ray\n  uint256 internal immutable _variableRateSlope2;\n\n  // Slope of the stable interest curve when utilization rate > 0 and <= OPTIMAL_UTILIZATION_RATE. Expressed in ray\n  uint256 internal immutable _stableRateSlope1;\n\n  // Slope of the stable interest curve when utilization rate > OPTIMAL_UTILIZATION_RATE. Expressed in ray\n  uint256 internal immutable _stableRateSlope2;\n\n  constructor(\n    ILendingPoolAddressesProvider provider,\n    uint256 optimalUtilizationRate_,\n    uint256 baseVariableBorrowRate_,\n    uint256 variableRateSlope1_,\n    uint256 variableRateSlope2_,\n    uint256 stableRateSlope1_,\n    uint256 stableRateSlope2_\n  ) {\n    OPTIMAL_UTILIZATION_RATE = optimalUtilizationRate_;\n    EXCESS_UTILIZATION_RATE = WadRayMath.ray().sub(optimalUtilizationRate_);\n    addressesProvider = provider;\n    _baseVariableBorrowRate = baseVariableBorrowRate_;\n    _variableRateSlope1 = variableRateSlope1_;\n    _variableRateSlope2 = variableRateSlope2_;\n    _stableRateSlope1 = stableRateSlope1_;\n    _stableRateSlope2 = stableRateSlope2_;\n  }\n\n  function variableRateSlope1() external view returns (uint256) {\n    return _variableRateSlope1;\n  }\n\n  function variableRateSlope2() external view returns (uint256) {\n    return _variableRateSlope2;\n  }\n\n  function stableRateSlope1() external view returns (uint256) {\n    return _stableRateSlope1;\n  }\n\n  function stableRateSlope2() external view returns (uint256) {\n    return _stableRateSlope2;\n  }\n\n  function baseVariableBorrowRate() external view override returns (uint256) {\n    return _baseVariableBorrowRate;\n  }\n\n  function getMaxVariableBorrowRate() external view override returns (uint256) {\n    return _baseVariableBorrowRate.add(_variableRateSlope1).add(_variableRateSlope2);\n  }\n\n  /**\n   * @dev Calculates the interest rates depending on the reserve's state and configurations\n   * @param reserve The address of the reserve\n   * @param liquidityAdded The liquidity added during the operation\n   * @param liquidityTaken The liquidity taken during the operation\n   * @param totalStableDebt The total borrowed from the reserve a stable rate\n   * @param totalVariableDebt The total borrowed from the reserve at a variable rate\n   * @param averageStableBorrowRate The weighted average of all the stable rate loans\n   * @param reserveFactor The reserve portion of the interest that goes to the treasury of the market\n   * @return The liquidity rate, the stable borrow rate and the variable borrow rate\n   **/\n  function calculateInterestRates(\n    address reserve,\n    address aToken,\n    uint256 liquidityAdded,\n    uint256 liquidityTaken,\n    uint256 totalStableDebt,\n    uint256 totalVariableDebt,\n    uint256 averageStableBorrowRate,\n    uint256 reserveFactor\n  )\n    external\n    view\n    override\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    uint256 availableLiquidity = IERC20(reserve).balanceOf(aToken);\n    //avoid stack too deep\n    availableLiquidity = availableLiquidity.add(liquidityAdded).sub(liquidityTaken);\n\n    return\n      calculateInterestRates(\n        reserve,\n        availableLiquidity,\n        totalStableDebt,\n        totalVariableDebt,\n        averageStableBorrowRate,\n        reserveFactor\n      );\n  }\n\n  struct CalcInterestRatesLocalVars {\n    uint256 totalDebt;\n    uint256 currentVariableBorrowRate;\n    uint256 currentStableBorrowRate;\n    uint256 currentLiquidityRate;\n    uint256 utilizationRate;\n  }\n\n  /**\n   * @dev Calculates the interest rates depending on the reserve's state and configurations.\n   * NOTE This function is kept for compatibility with the previous DefaultInterestRateStrategy interface.\n   * New protocol implementation uses the new calculateInterestRates() interface\n   * @param reserve The address of the reserve\n   * @param availableLiquidity The liquidity available in the corresponding aToken\n   * @param totalStableDebt The total borrowed from the reserve a stable rate\n   * @param totalVariableDebt The total borrowed from the reserve at a variable rate\n   * @param averageStableBorrowRate The weighted average of all the stable rate loans\n   * @param reserveFactor The reserve portion of the interest that goes to the treasury of the market\n   * @return The liquidity rate, the stable borrow rate and the variable borrow rate\n   **/\n  function calculateInterestRates(\n    address reserve,\n    uint256 availableLiquidity,\n    uint256 totalStableDebt,\n    uint256 totalVariableDebt,\n    uint256 averageStableBorrowRate,\n    uint256 reserveFactor\n  )\n    public\n    view\n    override\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    CalcInterestRatesLocalVars memory vars;\n\n    vars.totalDebt = totalStableDebt.add(totalVariableDebt);\n    vars.currentVariableBorrowRate = 0;\n    vars.currentStableBorrowRate = 0;\n    vars.currentLiquidityRate = 0;\n\n    vars.utilizationRate = vars.totalDebt == 0\n      ? 0\n      : vars.totalDebt.rayDiv(availableLiquidity.add(vars.totalDebt));\n\n    vars.currentStableBorrowRate = ILendingRateOracle(addressesProvider.getLendingRateOracle())\n      .getMarketBorrowRate(reserve);\n\n    if (vars.utilizationRate > OPTIMAL_UTILIZATION_RATE) {\n      uint256 excessUtilizationRateRatio =\n        vars.utilizationRate.sub(OPTIMAL_UTILIZATION_RATE).rayDiv(EXCESS_UTILIZATION_RATE);\n\n      vars.currentStableBorrowRate = vars.currentStableBorrowRate.add(_stableRateSlope1).add(\n        _stableRateSlope2.rayMul(excessUtilizationRateRatio)\n      );\n\n      vars.currentVariableBorrowRate = _baseVariableBorrowRate.add(_variableRateSlope1).add(\n        _variableRateSlope2.rayMul(excessUtilizationRateRatio)\n      );\n    } else {\n      vars.currentStableBorrowRate = vars.currentStableBorrowRate.add(\n        _stableRateSlope1.rayMul(vars.utilizationRate.rayDiv(OPTIMAL_UTILIZATION_RATE))\n      );\n      vars.currentVariableBorrowRate = _baseVariableBorrowRate.add(\n        vars.utilizationRate.rayMul(_variableRateSlope1).rayDiv(OPTIMAL_UTILIZATION_RATE)\n      );\n    }\n\n    vars.currentLiquidityRate = _getOverallBorrowRate(\n      totalStableDebt,\n      totalVariableDebt,\n      vars\n        .currentVariableBorrowRate,\n      averageStableBorrowRate\n    )\n      .rayMul(vars.utilizationRate)\n      .percentMul(PercentageMath.PERCENTAGE_FACTOR.sub(reserveFactor));\n\n    return (\n      vars.currentLiquidityRate,\n      vars.currentStableBorrowRate,\n      vars.currentVariableBorrowRate\n    );\n  }\n\n  /**\n   * @dev Calculates the overall borrow rate as the weighted average between the total variable debt and total stable debt\n   * @param totalStableDebt The total borrowed from the reserve a stable rate\n   * @param totalVariableDebt The total borrowed from the reserve at a variable rate\n   * @param currentVariableBorrowRate The current variable borrow rate of the reserve\n   * @param currentAverageStableBorrowRate The current weighted average of all the stable rate loans\n   * @return The weighted averaged borrow rate\n   **/\n  function _getOverallBorrowRate(\n    uint256 totalStableDebt,\n    uint256 totalVariableDebt,\n    uint256 currentVariableBorrowRate,\n    uint256 currentAverageStableBorrowRate\n  ) internal pure returns (uint256) {\n    uint256 totalDebt = totalStableDebt.add(totalVariableDebt);\n\n    if (totalDebt == 0) return 0;\n\n    uint256 weightedVariableRate = totalVariableDebt.wadToRay().rayMul(currentVariableBorrowRate);\n\n    uint256 weightedStableRate = totalStableDebt.wadToRay().rayMul(currentAverageStableBorrowRate);\n\n    uint256 overallBorrowRate =\n      weightedVariableRate.add(weightedStableRate).rayDiv(totalDebt.wadToRay());\n\n    return overallBorrowRate;\n  }\n}\n"
    },
    "contracts/protocol/lendingpool/LendingPool.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from '../../dependencies/openzeppelin/contracts/SafeMath.sol';\nimport {IERC20} from '../../dependencies/openzeppelin/contracts/IERC20.sol';\nimport {SafeERC20} from '../../dependencies/openzeppelin/contracts/SafeERC20.sol';\nimport {Address} from '../../dependencies/openzeppelin/contracts/Address.sol';\nimport {ILendingPoolAddressesProvider} from '../../interfaces/ILendingPoolAddressesProvider.sol';\nimport {IAToken} from '../../interfaces/IAToken.sol';\nimport {IVariableDebtToken} from '../../interfaces/IVariableDebtToken.sol';\nimport {IFlashLoanReceiver} from '../../flashloan/interfaces/IFlashLoanReceiver.sol';\nimport {IPriceOracleGetter} from '../../interfaces/IPriceOracleGetter.sol';\nimport {IStableDebtToken} from '../../interfaces/IStableDebtToken.sol';\nimport {ILendingPool} from '../../interfaces/ILendingPool.sol';\nimport {ILeverager} from '../../interfaces/ILeverager.sol';\nimport {VersionedInitializable} from '../libraries/aave-upgradeability/VersionedInitializable.sol';\nimport {Helpers} from '../libraries/helpers/Helpers.sol';\nimport {Errors} from '../libraries/helpers/Errors.sol';\nimport {WadRayMath} from '../libraries/math/WadRayMath.sol';\nimport {PercentageMath} from '../libraries/math/PercentageMath.sol';\nimport {ReserveLogic} from '../libraries/logic/ReserveLogic.sol';\nimport {GenericLogic} from '../libraries/logic/GenericLogic.sol';\nimport {ValidationLogic} from '../libraries/logic/ValidationLogic.sol';\nimport {ReserveConfiguration} from '../libraries/configuration/ReserveConfiguration.sol';\nimport {UserConfiguration} from '../libraries/configuration/UserConfiguration.sol';\nimport {DataTypes} from '../libraries/types/DataTypes.sol';\nimport {LendingPoolStorage} from './LendingPoolStorage.sol';\n\n/**\n * @title LendingPool contract\n * @dev Main point of interaction with an Aave protocol's market\n * - Users can:\n *   # Deposit\n *   # Withdraw\n *   # Borrow\n *   # Repay\n *   # Swap their loans between variable and stable rate\n *   # Enable/disable their deposits as collateral rebalance stable rate borrow positions\n *   # Liquidate positions\n *   # Execute Flash Loans\n * - To be covered by a proxy contract, owned by the LendingPoolAddressesProvider of the specific market\n * - All admin functions are callable by the LendingPoolConfigurator contract defined also in the\n *   LendingPoolAddressesProvider\n * @author Aave\n **/\ncontract LendingPool is VersionedInitializable, ILendingPool, LendingPoolStorage {\n  using SafeMath for uint256;\n  using WadRayMath for uint256;\n  using PercentageMath for uint256;\n  using SafeERC20 for IERC20;\n  using ReserveLogic for DataTypes.ReserveData;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using UserConfiguration for DataTypes.UserConfigurationMap;\n\n  uint256 public constant LENDINGPOOL_REVISION = 0x2;\n\n  ILeverager public leverager;\n\n  modifier whenNotPaused() {\n    _whenNotPaused();\n    _;\n  }\n\n  modifier onlyLendingPoolConfigurator() {\n    _onlyLendingPoolConfigurator();\n    _;\n  }\n\n  function _whenNotPaused() internal view {\n    require(!_paused, Errors.LP_IS_PAUSED);\n  }\n\n  function _onlyLendingPoolConfigurator() internal view {\n    require(\n      _addressesProvider.getLendingPoolConfigurator() == msg.sender,\n      Errors.LP_CALLER_NOT_LENDING_POOL_CONFIGURATOR\n    );\n  }\n\n  function getRevision() internal pure override returns (uint256) {\n    return LENDINGPOOL_REVISION;\n  }\n\n  /**\n   * @dev Function is invoked by the proxy contract when the LendingPool contract is added to the\n   * LendingPoolAddressesProvider of the market.\n   * - Caching the address of the LendingPoolAddressesProvider in order to reduce gas consumption\n   *   on subsequent operations\n   * @param provider The address of the LendingPoolAddressesProvider\n   **/\n  function initialize(ILendingPoolAddressesProvider provider) public initializer {\n    _addressesProvider = provider;\n    _maxStableRateBorrowSizePercent = 2500;\n    _flashLoanPremiumTotal = 9;\n    _maxNumberOfReserves = 128;\n  }\n\n  /**\n   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\n   * @param asset The address of the underlying asset to deposit\n   * @param amount The amount to be deposited\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function deposit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) public override whenNotPaused {\n    DataTypes.ReserveData storage reserve = _reserves[asset];\n\n    ValidationLogic.validateDeposit(reserve, amount);\n\n    address aToken = reserve.aTokenAddress;\n\n    reserve.updateState();\n    reserve.updateInterestRates(asset, aToken, amount, 0);\n\n    IERC20(asset).safeTransferFrom(msg.sender, aToken, amount);\n\n    if (IAToken(aToken).balanceOf(onBehalfOf) == 0) {\n      _usersConfig[onBehalfOf].setUsingAsCollateral(reserve.id, true);\n      emit ReserveUsedAsCollateralEnabled(asset, onBehalfOf);\n    }\n\n    IAToken(aToken).mint(onBehalfOf, amount, reserve.liquidityIndex);\n\n    emit Deposit(asset, msg.sender, onBehalfOf, amount, referralCode);\n  }\n\n  function depositWithAutoDLP(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override whenNotPaused {\n    require(tx.origin == onBehalfOf);\n    deposit(asset, amount, onBehalfOf, referralCode);\n    leverager.zapWETHWithBorrow(leverager.wethToZap(onBehalfOf), onBehalfOf);\n  }\n\n  /**\n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n   * @param to Address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   **/\n  function withdraw(\n    address asset,\n    uint256 amount,\n    address to\n  ) external override whenNotPaused returns (uint256) {\n    DataTypes.ReserveData storage reserve = _reserves[asset];\n\n    address aToken = reserve.aTokenAddress;\n\n    uint256 userBalance = IAToken(aToken).balanceOf(msg.sender);\n\n    uint256 amountToWithdraw = amount;\n\n    if (amount == type(uint256).max) {\n      amountToWithdraw = userBalance;\n    }\n\n    ValidationLogic.validateWithdraw(\n      asset,\n      amountToWithdraw,\n      userBalance,\n      _reserves,\n      _usersConfig[msg.sender],\n      _reservesList,\n      _reservesCount,\n      _addressesProvider.getPriceOracle()\n    );\n\n    reserve.updateState();\n\n    reserve.updateInterestRates(asset, aToken, 0, amountToWithdraw);\n\n    if (amountToWithdraw == userBalance) {\n      _usersConfig[msg.sender].setUsingAsCollateral(reserve.id, false);\n      emit ReserveUsedAsCollateralDisabled(asset, msg.sender);\n    }\n\n    IAToken(aToken).burn(msg.sender, to, amountToWithdraw, reserve.liquidityIndex);\n\n    emit Withdraw(asset, msg.sender, to, amountToWithdraw);\n\n    return amountToWithdraw;\n  }\n\n  /**\n   * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n   * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\n   * corresponding debt token (StableDebtToken or VariableDebtToken)\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n   * if he has been given credit delegation allowance\n   **/\n  function borrow(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    uint16 referralCode,\n    address onBehalfOf\n  ) external override whenNotPaused {\n    DataTypes.ReserveData storage reserve = _reserves[asset];\n\n    _executeBorrow(\n      ExecuteBorrowParams(\n        asset,\n        msg.sender,\n        onBehalfOf,\n        amount,\n        interestRateMode,\n        reserve.aTokenAddress,\n        referralCode,\n        true\n      )\n    );\n  }\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @return The final amount repaid\n   **/\n  function repay(\n    address asset,\n    uint256 amount,\n    uint256 rateMode,\n    address onBehalfOf\n  ) external override whenNotPaused returns (uint256) {\n    DataTypes.ReserveData storage reserve = _reserves[asset];\n\n    (uint256 stableDebt, uint256 variableDebt) = Helpers.getUserCurrentDebt(onBehalfOf, reserve);\n\n    DataTypes.InterestRateMode interestRateMode = DataTypes.InterestRateMode(rateMode);\n\n    ValidationLogic.validateRepay(\n      reserve,\n      amount,\n      interestRateMode,\n      onBehalfOf,\n      stableDebt,\n      variableDebt\n    );\n\n    uint256 paybackAmount =\n      interestRateMode == DataTypes.InterestRateMode.STABLE ? stableDebt : variableDebt;\n\n    if (amount < paybackAmount) {\n      paybackAmount = amount;\n    }\n\n    reserve.updateState();\n\n    if (interestRateMode == DataTypes.InterestRateMode.STABLE) {\n      IStableDebtToken(reserve.stableDebtTokenAddress).burn(onBehalfOf, paybackAmount);\n    } else {\n      IVariableDebtToken(reserve.variableDebtTokenAddress).burn(\n        onBehalfOf,\n        paybackAmount,\n        reserve.variableBorrowIndex\n      );\n    }\n\n    address aToken = reserve.aTokenAddress;\n    reserve.updateInterestRates(asset, aToken, paybackAmount, 0);\n\n    if (stableDebt.add(variableDebt).sub(paybackAmount) == 0) {\n      _usersConfig[onBehalfOf].setBorrowing(reserve.id, false);\n    }\n\n    IERC20(asset).safeTransferFrom(msg.sender, aToken, paybackAmount);\n\n    IAToken(aToken).handleRepayment(msg.sender, paybackAmount);\n\n    emit Repay(asset, onBehalfOf, msg.sender, paybackAmount);\n\n    return paybackAmount;\n  }\n\n  /**\n   * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa\n   * @param asset The address of the underlying asset borrowed\n   * @param rateMode The rate mode that the user wants to swap to\n   **/\n  function swapBorrowRateMode(address asset, uint256 rateMode) external override whenNotPaused {\n    DataTypes.ReserveData storage reserve = _reserves[asset];\n\n    (uint256 stableDebt, uint256 variableDebt) = Helpers.getUserCurrentDebt(msg.sender, reserve);\n\n    DataTypes.InterestRateMode interestRateMode = DataTypes.InterestRateMode(rateMode);\n\n    ValidationLogic.validateSwapRateMode(\n      reserve,\n      _usersConfig[msg.sender],\n      stableDebt,\n      variableDebt,\n      interestRateMode\n    );\n\n    reserve.updateState();\n\n    if (interestRateMode == DataTypes.InterestRateMode.STABLE) {\n      IStableDebtToken(reserve.stableDebtTokenAddress).burn(msg.sender, stableDebt);\n      IVariableDebtToken(reserve.variableDebtTokenAddress).mint(\n        msg.sender,\n        msg.sender,\n        stableDebt,\n        reserve.variableBorrowIndex\n      );\n    } else {\n      IVariableDebtToken(reserve.variableDebtTokenAddress).burn(\n        msg.sender,\n        variableDebt,\n        reserve.variableBorrowIndex\n      );\n      IStableDebtToken(reserve.stableDebtTokenAddress).mint(\n        msg.sender,\n        msg.sender,\n        variableDebt,\n        reserve.currentStableBorrowRate\n      );\n    }\n\n    reserve.updateInterestRates(asset, reserve.aTokenAddress, 0, 0);\n\n    emit Swap(asset, msg.sender, rateMode);\n  }\n\n  /**\n   * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n   * - Users can be rebalanced if the following conditions are satisfied:\n   *     1. Usage ratio is above 95%\n   *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been\n   *        borrowed at a stable rate and depositors are not earning enough\n   * @param asset The address of the underlying asset borrowed\n   * @param user The address of the user to be rebalanced\n   **/\n  function rebalanceStableBorrowRate(address asset, address user) external override whenNotPaused {\n    DataTypes.ReserveData storage reserve = _reserves[asset];\n\n    IERC20 stableDebtToken = IERC20(reserve.stableDebtTokenAddress);\n    IERC20 variableDebtToken = IERC20(reserve.variableDebtTokenAddress);\n    address aTokenAddress = reserve.aTokenAddress;\n\n    uint256 stableDebt = IERC20(stableDebtToken).balanceOf(user);\n\n    ValidationLogic.validateRebalanceStableBorrowRate(\n      reserve,\n      asset,\n      stableDebtToken,\n      variableDebtToken,\n      aTokenAddress\n    );\n\n    reserve.updateState();\n\n    IStableDebtToken(address(stableDebtToken)).burn(user, stableDebt);\n    IStableDebtToken(address(stableDebtToken)).mint(\n      user,\n      user,\n      stableDebt,\n      reserve.currentStableBorrowRate\n    );\n\n    reserve.updateInterestRates(asset, aTokenAddress, 0, 0);\n\n    emit RebalanceStableBorrowRate(asset, user);\n  }\n\n  /**\n   * @dev Allows depositors to enable/disable a specific deposited asset as collateral\n   * @param asset The address of the underlying asset deposited\n   * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\n   **/\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral)\n    external\n    override\n    whenNotPaused\n  {\n    DataTypes.ReserveData storage reserve = _reserves[asset];\n\n    ValidationLogic.validateSetUseReserveAsCollateral(\n      reserve,\n      asset,\n      useAsCollateral,\n      _reserves,\n      _usersConfig[msg.sender],\n      _reservesList,\n      _reservesCount,\n      _addressesProvider.getPriceOracle()\n    );\n\n    _usersConfig[msg.sender].setUsingAsCollateral(reserve.id, useAsCollateral);\n\n    if (useAsCollateral) {\n      emit ReserveUsedAsCollateralEnabled(asset, msg.sender);\n    } else {\n      emit ReserveUsedAsCollateralDisabled(asset, msg.sender);\n    }\n  }\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   **/\n  function liquidationCall(\n    address collateralAsset,\n    address debtAsset,\n    address user,\n    uint256 debtToCover,\n    bool receiveAToken\n  ) external override whenNotPaused {\n    address collateralManager = _addressesProvider.getLendingPoolCollateralManager();\n    address liquidationFeeTo = _addressesProvider.getLiquidationFeeTo();\n    if (liquidationFeeTo == address(0)) {\n      liquidationFeeTo = msg.sender;\n    }\n\n    //solium-disable-next-line\n    (bool success, bytes memory result) =\n      collateralManager.delegatecall(\n        abi.encodeWithSignature(\n          'liquidationCall(address,address,address,uint256,bool,address)',\n          collateralAsset,\n          debtAsset,\n          user,\n          debtToCover,\n          receiveAToken,\n          liquidationFeeTo\n        )\n      );\n\n    require(success, Errors.LP_LIQUIDATION_CALL_FAILED);\n\n    (uint256 returnCode, string memory returnMessage) = abi.decode(result, (uint256, string));\n\n    require(returnCode == 0, string(abi.encodePacked(returnMessage)));\n  }\n\n  struct FlashLoanLocalVars {\n    IFlashLoanReceiver receiver;\n    address oracle;\n    uint256 i;\n    address currentAsset;\n    address currentATokenAddress;\n    uint256 currentAmount;\n    uint256 currentPremium;\n    uint256 currentAmountPlusPremium;\n    address debtToken;\n  }\n\n  /**\n   * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.\n   * For further details please visit https://developers.aave.com\n   * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface\n   * @param assets The addresses of the assets being flash-borrowed\n   * @param amounts The amounts amounts being flash-borrowed\n   * @param modes Types of the debt to open if the flash loan is not returned:\n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n   *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function flashLoan(\n    address receiverAddress,\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata modes,\n    address onBehalfOf,\n    bytes calldata params,\n    uint16 referralCode\n  ) external override whenNotPaused {\n    FlashLoanLocalVars memory vars;\n\n    ValidationLogic.validateFlashloan(assets, amounts);\n\n    address[] memory aTokenAddresses = new address[](assets.length);\n    uint256[] memory premiums = new uint256[](assets.length);\n\n    vars.receiver = IFlashLoanReceiver(receiverAddress);\n\n    for (vars.i = 0; vars.i < assets.length; vars.i++) {\n      aTokenAddresses[vars.i] = _reserves[assets[vars.i]].aTokenAddress;\n\n      premiums[vars.i] = amounts[vars.i].mul(_flashLoanPremiumTotal).div(10000);\n\n      IAToken(aTokenAddresses[vars.i]).transferUnderlyingTo(receiverAddress, amounts[vars.i]);\n    }\n\n    require(\n      vars.receiver.executeOperation(assets, amounts, premiums, msg.sender, params),\n      Errors.LP_INVALID_FLASH_LOAN_EXECUTOR_RETURN\n    );\n\n    for (vars.i = 0; vars.i < assets.length; vars.i++) {\n      vars.currentAsset = assets[vars.i];\n      vars.currentAmount = amounts[vars.i];\n      vars.currentPremium = premiums[vars.i];\n      vars.currentATokenAddress = aTokenAddresses[vars.i];\n      vars.currentAmountPlusPremium = vars.currentAmount.add(vars.currentPremium);\n\n      if (DataTypes.InterestRateMode(modes[vars.i]) == DataTypes.InterestRateMode.NONE) {\n        _reserves[vars.currentAsset].updateState();\n        _reserves[vars.currentAsset].cumulateToLiquidityIndex(\n          IERC20(vars.currentATokenAddress).totalSupply(),\n          vars.currentPremium\n        );\n        _reserves[vars.currentAsset].updateInterestRates(\n          vars.currentAsset,\n          vars.currentATokenAddress,\n          vars.currentAmountPlusPremium,\n          0\n        );\n\n        IERC20(vars.currentAsset).safeTransferFrom(\n          receiverAddress,\n          vars.currentATokenAddress,\n          vars.currentAmountPlusPremium\n        );\n      } else {\n        // If the user chose to not return the funds, the system checks if there is enough collateral and\n        // eventually opens a debt position\n        _executeBorrow(\n          ExecuteBorrowParams(\n            vars.currentAsset,\n            msg.sender,\n            onBehalfOf,\n            vars.currentAmount,\n            modes[vars.i],\n            vars.currentATokenAddress,\n            referralCode,\n            false\n          )\n        );\n      }\n      emit FlashLoan(\n        receiverAddress,\n        msg.sender,\n        vars.currentAsset,\n        vars.currentAmount,\n        vars.currentPremium,\n        referralCode\n      );\n    }\n  }\n\n  /**\n   * @dev Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state of the reserve\n   **/\n  function getReserveData(address asset)\n    external\n    view\n    override\n    returns (DataTypes.ReserveData memory)\n  {\n    return _reserves[asset];\n  }\n\n  /**\n   * @dev Returns the user account data across all the reserves\n   * @param user The address of the user\n   * @return totalCollateralETH the total collateral in ETH of the user\n   * @return totalDebtETH the total debt in ETH of the user\n   * @return availableBorrowsETH the borrowing power left of the user\n   * @return currentLiquidationThreshold the liquidation threshold of the user\n   * @return ltv the loan to value of the user\n   * @return healthFactor the current health factor of the user\n   **/\n  function getUserAccountData(address user)\n    external\n    view\n    override\n    returns (\n      uint256 totalCollateralETH,\n      uint256 totalDebtETH,\n      uint256 availableBorrowsETH,\n      uint256 currentLiquidationThreshold,\n      uint256 ltv,\n      uint256 healthFactor\n    )\n  {\n    (\n      totalCollateralETH,\n      totalDebtETH,\n      ltv,\n      currentLiquidationThreshold,\n      healthFactor\n    ) = GenericLogic.calculateUserAccountData(\n      user,\n      _reserves,\n      _usersConfig[user],\n      _reservesList,\n      _reservesCount,\n      _addressesProvider.getPriceOracle()\n    );\n\n    availableBorrowsETH = GenericLogic.calculateAvailableBorrowsETH(\n      totalCollateralETH,\n      totalDebtETH,\n      ltv\n    );\n  }\n\n  /**\n   * @dev Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   **/\n  function getConfiguration(address asset)\n    external\n    view\n    override\n    returns (DataTypes.ReserveConfigurationMap memory)\n  {\n    return _reserves[asset].configuration;\n  }\n\n  /**\n   * @dev Returns the configuration of the user across all the reserves\n   * @param user The user address\n   * @return The configuration of the user\n   **/\n  function getUserConfiguration(address user)\n    external\n    view\n    override\n    returns (DataTypes.UserConfigurationMap memory)\n  {\n    return _usersConfig[user];\n  }\n\n  /**\n   * @dev Returns the normalized income per unit of asset\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset)\n    external\n    view\n    virtual\n    override\n    returns (uint256)\n  {\n    return _reserves[asset].getNormalizedIncome();\n  }\n\n  /**\n   * @dev Returns the normalized variable debt per unit of asset\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return _reserves[asset].getNormalizedDebt();\n  }\n\n  /**\n   * @dev Returns if the LendingPool is paused\n   */\n  function paused() external view override returns (bool) {\n    return _paused;\n  }\n\n  /**\n   * @dev Returns the list of the initialized reserves\n   **/\n  function getReservesList() external view override returns (address[] memory) {\n    address[] memory _activeReserves = new address[](_reservesCount);\n\n    for (uint256 i = 0; i < _reservesCount; i++) {\n      _activeReserves[i] = _reservesList[i];\n    }\n    return _activeReserves;\n  }\n\n  /**\n   * @dev Returns the cached LendingPoolAddressesProvider connected to this contract\n   **/\n  function getAddressesProvider() external view override returns (ILendingPoolAddressesProvider) {\n    return _addressesProvider;\n  }\n\n  /**\n   * @dev Returns the percentage of available liquidity that can be borrowed at once at stable rate\n   */\n  function MAX_STABLE_RATE_BORROW_SIZE_PERCENT() public view returns (uint256) {\n    return _maxStableRateBorrowSizePercent;\n  }\n\n  /**\n   * @dev Returns the fee on flash loans \n   */\n  function FLASHLOAN_PREMIUM_TOTAL() public view returns (uint256) {\n    return _flashLoanPremiumTotal;\n  }\n\n  /**\n   * @dev Returns the maximum number of reserves supported to be listed in this LendingPool\n   */\n  function MAX_NUMBER_RESERVES() public view returns (uint256) {\n    return _maxNumberOfReserves;\n  }\n\n  /**\n   * @dev Validates and finalizes an aToken transfer\n   * - Only callable by the overlying aToken of the `asset`\n   * @param asset The address of the underlying asset of the aToken\n   * @param from The user from which the aTokens are transferred\n   * @param to The user receiving the aTokens\n   * @param amount The amount being transferred/withdrawn\n   * @param balanceFromBefore The aToken balance of the `from` user before the transfer\n   * @param balanceToBefore The aToken balance of the `to` user before the transfer\n   */\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address to,\n    uint256 amount,\n    uint256 balanceFromBefore,\n    uint256 balanceToBefore\n  ) external override whenNotPaused {\n    require(msg.sender == _reserves[asset].aTokenAddress, Errors.LP_CALLER_MUST_BE_AN_ATOKEN);\n\n    ValidationLogic.validateTransfer(\n      from,\n      _reserves,\n      _usersConfig[from],\n      _reservesList,\n      _reservesCount,\n      _addressesProvider.getPriceOracle()\n    );\n\n    uint256 reserveId = _reserves[asset].id;\n\n    if (from != to) {\n      if (balanceFromBefore.sub(amount) == 0) {\n        DataTypes.UserConfigurationMap storage fromConfig = _usersConfig[from];\n        fromConfig.setUsingAsCollateral(reserveId, false);\n        emit ReserveUsedAsCollateralDisabled(asset, from);\n      }\n\n      if (balanceToBefore == 0 && amount != 0) {\n        DataTypes.UserConfigurationMap storage toConfig = _usersConfig[to];\n        toConfig.setUsingAsCollateral(reserveId, true);\n        emit ReserveUsedAsCollateralEnabled(asset, to);\n      }\n    }\n  }\n\n  /**\n   * @dev Initializes a reserve, activating it, assigning an aToken and debt tokens and an\n   * interest rate strategy\n   * - Only callable by the LendingPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param aTokenAddress The address of the aToken that will be assigned to the reserve\n   * @param stableDebtAddress The address of the StableDebtToken that will be assigned to the reserve\n   * @param aTokenAddress The address of the VariableDebtToken that will be assigned to the reserve\n   * @param interestRateStrategyAddress The address of the interest rate strategy contract\n   **/\n  function initReserve(\n    address asset,\n    address aTokenAddress,\n    address stableDebtAddress,\n    address variableDebtAddress,\n    address interestRateStrategyAddress\n  ) external override onlyLendingPoolConfigurator {\n    require(Address.isContract(asset), Errors.LP_NOT_CONTRACT);\n    _reserves[asset].init(\n      aTokenAddress,\n      stableDebtAddress,\n      variableDebtAddress,\n      interestRateStrategyAddress\n    );\n    _addReserveToList(asset);\n  }\n\n  /**\n   * @dev Updates the address of the interest rate strategy contract\n   * - Only callable by the LendingPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param rateStrategyAddress The address of the interest rate strategy contract\n   **/\n  function setReserveInterestRateStrategyAddress(address asset, address rateStrategyAddress)\n    external\n    override\n    onlyLendingPoolConfigurator\n  {\n    _reserves[asset].interestRateStrategyAddress = rateStrategyAddress;\n  }\n\n  /**\n   * @dev Sets the configuration bitmap of the reserve as a whole\n   * - Only callable by the LendingPoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param configuration The new configuration bitmap\n   **/\n  function setConfiguration(address asset, uint256 configuration)\n    external\n    override\n    onlyLendingPoolConfigurator\n  {\n    _reserves[asset].configuration.data = configuration;\n  }\n\n  /**\n   * @dev Set the _pause state of a reserve\n   * - Only callable by the LendingPoolConfigurator contract\n   * @param val `true` to pause the reserve, `false` to un-pause it\n   */\n  function setPause(bool val) external override onlyLendingPoolConfigurator {\n    _paused = val;\n    if (_paused) {\n      emit Paused();\n    } else {\n      emit Unpaused();\n    }\n  }\n\n  struct ExecuteBorrowParams {\n    address asset;\n    address user;\n    address onBehalfOf;\n    uint256 amount;\n    uint256 interestRateMode;\n    address aTokenAddress;\n    uint16 referralCode;\n    bool releaseUnderlying;\n  }\n\n  function _executeBorrow(ExecuteBorrowParams memory vars) internal {\n    DataTypes.ReserveData storage reserve = _reserves[vars.asset];\n    DataTypes.UserConfigurationMap storage userConfig = _usersConfig[vars.onBehalfOf];\n\n    address oracle = _addressesProvider.getPriceOracle();\n\n    uint256 amountInETH =\n      IPriceOracleGetter(oracle).getAssetPrice(vars.asset).mul(vars.amount).div(\n        10**reserve.configuration.getDecimals()\n      );\n\n    ValidationLogic.validateBorrow(\n      vars.asset,\n      reserve,\n      vars.onBehalfOf,\n      vars.amount,\n      amountInETH,\n      vars.interestRateMode,\n      _maxStableRateBorrowSizePercent,\n      _reserves,\n      userConfig,\n      _reservesList,\n      _reservesCount,\n      oracle\n    );\n\n    reserve.updateState();\n\n    uint256 currentStableRate = 0;\n\n    bool isFirstBorrowing = false;\n    if (DataTypes.InterestRateMode(vars.interestRateMode) == DataTypes.InterestRateMode.STABLE) {\n      currentStableRate = reserve.currentStableBorrowRate;\n\n      isFirstBorrowing = IStableDebtToken(reserve.stableDebtTokenAddress).mint(\n        vars.user,\n        vars.onBehalfOf,\n        vars.amount,\n        currentStableRate\n      );\n    } else {\n      isFirstBorrowing = IVariableDebtToken(reserve.variableDebtTokenAddress).mint(\n        vars.user,\n        vars.onBehalfOf,\n        vars.amount,\n        reserve.variableBorrowIndex\n      );\n    }\n\n    if (isFirstBorrowing) {\n      userConfig.setBorrowing(reserve.id, true);\n    }\n\n    reserve.updateInterestRates(\n      vars.asset,\n      vars.aTokenAddress,\n      0,\n      vars.releaseUnderlying ? vars.amount : 0\n    );\n\n    if (vars.releaseUnderlying) {\n      IAToken(vars.aTokenAddress).transferUnderlyingTo(vars.user, vars.amount);\n    }\n\n    emit Borrow(\n      vars.asset,\n      vars.user,\n      vars.onBehalfOf,\n      vars.amount,\n      vars.interestRateMode,\n      DataTypes.InterestRateMode(vars.interestRateMode) == DataTypes.InterestRateMode.STABLE\n        ? currentStableRate\n        : reserve.currentVariableBorrowRate,\n      vars.referralCode\n    );\n  }\n\n  function _addReserveToList(address asset) internal {\n    uint256 reservesCount = _reservesCount;\n\n    require(reservesCount < _maxNumberOfReserves, Errors.LP_NO_MORE_RESERVES_ALLOWED);\n\n    bool reserveAlreadyAdded = _reserves[asset].id != 0 || _reservesList[0] == asset;\n\n    if (!reserveAlreadyAdded) {\n      _reserves[asset].id = uint8(reservesCount);\n      _reservesList[reservesCount] = asset;\n\n      _reservesCount = reservesCount + 1;\n    }\n  }\n\n  function setLeverager (ILeverager _leverager) external {\n    require(address(leverager) == address(0), \"Leverager Already Set\");\n    leverager = _leverager;\n  }\n}\n"
    },
    "contracts/protocol/lendingpool/LendingPoolCollateralManager.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\nimport {SafeMath} from '../../dependencies/openzeppelin/contracts//SafeMath.sol';\nimport {IERC20} from '../../dependencies/openzeppelin/contracts//IERC20.sol';\nimport {IAToken} from '../../interfaces/IAToken.sol';\nimport {IStableDebtToken} from '../../interfaces/IStableDebtToken.sol';\nimport {IVariableDebtToken} from '../../interfaces/IVariableDebtToken.sol';\nimport {IPriceOracleGetter} from '../../interfaces/IPriceOracleGetter.sol';\nimport {ILendingPoolCollateralManager} from '../../interfaces/ILendingPoolCollateralManager.sol';\nimport {VersionedInitializable} from '../libraries/aave-upgradeability/VersionedInitializable.sol';\nimport {GenericLogic} from '../libraries/logic/GenericLogic.sol';\nimport {Helpers} from '../libraries/helpers/Helpers.sol';\nimport {WadRayMath} from '../libraries/math/WadRayMath.sol';\nimport {PercentageMath} from '../libraries/math/PercentageMath.sol';\nimport {SafeERC20} from '../../dependencies/openzeppelin/contracts/SafeERC20.sol';\nimport {Errors} from '../libraries/helpers/Errors.sol';\nimport {ValidationLogic} from '../libraries/logic/ValidationLogic.sol';\nimport {DataTypes} from '../libraries/types/DataTypes.sol';\nimport {LendingPoolStorage} from './LendingPoolStorage.sol';\nimport {UserConfiguration} from '../libraries/configuration/UserConfiguration.sol';\nimport {ReserveConfiguration} from '../libraries/configuration/ReserveConfiguration.sol';\nimport {ReserveLogic} from '../libraries/logic/ReserveLogic.sol';\n\n/**\n * @title LendingPoolCollateralManager contract\n * @author Aave\n * @dev Implements actions involving management of collateral in the protocol, the main one being the liquidations\n * IMPORTANT This contract will run always via DELEGATECALL, through the LendingPool, so the chain of inheritance\n * is the same as the LendingPool, to have compatible storage layouts\n **/\ncontract LendingPoolCollateralManager is\n  ILendingPoolCollateralManager,\n  VersionedInitializable,\n  LendingPoolStorage\n{\n  using SafeERC20 for IERC20;\n  using SafeMath for uint256;\n  using WadRayMath for uint256;\n  using PercentageMath for uint256;\n  using ReserveLogic for DataTypes.ReserveData;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using UserConfiguration for DataTypes.UserConfigurationMap;\n\n  uint256 internal constant LIQUIDATION_CLOSE_FACTOR_PERCENT = 5000;\n\n  struct LiquidationCallLocalVars {\n    uint256 userCollateralBalance;\n    uint256 userStableDebt;\n    uint256 userVariableDebt;\n    uint256 maxLiquidatableDebt;\n    uint256 actualDebtToLiquidate;\n    uint256 liquidationRatio;\n    uint256 maxAmountCollateralToLiquidate;\n    uint256 userStableRate;\n    uint256 maxCollateralToLiquidate;\n    uint256 liquidationFee;\n    uint256 debtAmountNeeded;\n    uint256 healthFactor;\n    uint256 liquidatorPreviousATokenBalance;\n    IAToken collateralAtoken;\n    bool isCollateralEnabled;\n    DataTypes.InterestRateMode borrowRateMode;\n    uint256 errorCode;\n    string errorMsg;\n  }\n\n  /**\n   * @dev As thIS contract extends the VersionedInitializable contract to match the state\n   * of the LendingPool contract, the getRevision() function is needed, but the value is not\n   * important, as the initialize() function will never be called here\n   */\n  function getRevision() internal pure override returns (uint256) {\n    return 0;\n  }\n\n  /**\n   * @dev Function to liquidate a position if its Health Factor drops below 1\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   **/\n  function liquidationCall(\n    address collateralAsset,\n    address debtAsset,\n    address user,\n    uint256 debtToCover,\n    bool receiveAToken,\n    address liquidationFeeTo\n  ) external override returns (uint256, string memory) {\n    DataTypes.ReserveData storage collateralReserve = _reserves[collateralAsset];\n    DataTypes.ReserveData storage debtReserve = _reserves[debtAsset];\n    DataTypes.UserConfigurationMap storage userConfig = _usersConfig[user];\n\n    LiquidationCallLocalVars memory vars;\n\n    (, , , , vars.healthFactor) = GenericLogic.calculateUserAccountData(\n      user,\n      _reserves,\n      userConfig,\n      _reservesList,\n      _reservesCount,\n      _addressesProvider.getPriceOracle()\n    );\n\n    (vars.userStableDebt, vars.userVariableDebt) = Helpers.getUserCurrentDebt(user, debtReserve);\n\n    (vars.errorCode, vars.errorMsg) = ValidationLogic.validateLiquidationCall(\n      collateralReserve,\n      debtReserve,\n      userConfig,\n      vars.healthFactor,\n      vars.userStableDebt,\n      vars.userVariableDebt\n    );\n\n    if (Errors.CollateralManagerErrors(vars.errorCode) != Errors.CollateralManagerErrors.NO_ERROR) {\n      return (vars.errorCode, vars.errorMsg);\n    }\n\n    vars.collateralAtoken = IAToken(collateralReserve.aTokenAddress);\n\n    vars.userCollateralBalance = vars.collateralAtoken.balanceOf(user);\n\n    vars.maxLiquidatableDebt = vars.userStableDebt.add(vars.userVariableDebt).percentMul(\n      LIQUIDATION_CLOSE_FACTOR_PERCENT\n    );\n\n    vars.actualDebtToLiquidate = debtToCover > vars.maxLiquidatableDebt\n      ? vars.maxLiquidatableDebt\n      : debtToCover;\n\n    (\n      vars.maxCollateralToLiquidate,\n      vars.liquidationFee,\n      vars.debtAmountNeeded\n    ) = _calculateAvailableCollateralToLiquidate(\n      collateralReserve,\n      debtReserve,\n      collateralAsset,\n      debtAsset,\n      vars.actualDebtToLiquidate,\n      vars.userCollateralBalance\n    );\n\n    // If debtAmountNeeded < actualDebtToLiquidate, there isn't enough\n    // collateral to cover the actual amount that is being liquidated, hence we liquidate\n    // a smaller amount\n\n    if (vars.debtAmountNeeded < vars.actualDebtToLiquidate) {\n      vars.actualDebtToLiquidate = vars.debtAmountNeeded;\n    }\n\n    // If the liquidator reclaims the underlying asset, we make sure there is enough available liquidity in the\n    // collateral reserve\n    if (!receiveAToken) {\n      uint256 currentAvailableCollateral =\n        IERC20(collateralAsset).balanceOf(address(vars.collateralAtoken));\n      if (currentAvailableCollateral < vars.maxCollateralToLiquidate) {\n        return (\n          uint256(Errors.CollateralManagerErrors.NOT_ENOUGH_LIQUIDITY),\n          Errors.LPCM_NOT_ENOUGH_LIQUIDITY_TO_LIQUIDATE\n        );\n      }\n    }\n\n    debtReserve.updateState();\n\n    if (vars.userVariableDebt >= vars.actualDebtToLiquidate) {\n      IVariableDebtToken(debtReserve.variableDebtTokenAddress).burn(\n        user,\n        vars.actualDebtToLiquidate,\n        debtReserve.variableBorrowIndex\n      );\n    } else {\n      // If the user doesn't have variable debt, no need to try to burn variable debt tokens\n      if (vars.userVariableDebt > 0) {\n        IVariableDebtToken(debtReserve.variableDebtTokenAddress).burn(\n          user,\n          vars.userVariableDebt,\n          debtReserve.variableBorrowIndex\n        );\n      }\n      IStableDebtToken(debtReserve.stableDebtTokenAddress).burn(\n        user,\n        vars.actualDebtToLiquidate.sub(vars.userVariableDebt)\n      );\n    }\n\n    debtReserve.updateInterestRates(\n      debtAsset,\n      debtReserve.aTokenAddress,\n      vars.actualDebtToLiquidate,\n      0\n    );\n\n    if (receiveAToken) {\n      vars.liquidatorPreviousATokenBalance = IERC20(vars.collateralAtoken).balanceOf(msg.sender);\n      vars.collateralAtoken.transferOnLiquidation(user, msg.sender, vars.maxCollateralToLiquidate.sub(vars.liquidationFee));\n      vars.collateralAtoken.transferOnLiquidation(user, liquidationFeeTo, vars.liquidationFee);\n\n      if (vars.liquidatorPreviousATokenBalance == 0) {\n        DataTypes.UserConfigurationMap storage liquidatorConfig = _usersConfig[msg.sender];\n        liquidatorConfig.setUsingAsCollateral(collateralReserve.id, true);\n        emit ReserveUsedAsCollateralEnabled(collateralAsset, msg.sender);\n      }\n    } else {\n      collateralReserve.updateState();\n      collateralReserve.updateInterestRates(\n        collateralAsset,\n        address(vars.collateralAtoken),\n        0,\n        vars.maxCollateralToLiquidate\n      );\n\n      // Burn the equivalent amount of aToken, sending the underlying to the liquidator\n      vars.collateralAtoken.burn(\n        user,\n        msg.sender,\n        vars.maxCollateralToLiquidate.sub(vars.liquidationFee),\n        collateralReserve.liquidityIndex\n      );\n      vars.collateralAtoken.burn(\n        user,\n        liquidationFeeTo,\n        vars.liquidationFee,\n        collateralReserve.liquidityIndex\n      );\n    }\n\n    // If the collateral being liquidated is equal to the user balance,\n    // we set the currency as not being used as collateral anymore\n    if (vars.maxCollateralToLiquidate == vars.userCollateralBalance) {\n      userConfig.setUsingAsCollateral(collateralReserve.id, false);\n      emit ReserveUsedAsCollateralDisabled(collateralAsset, user);\n    }\n\n    // Transfers the debt asset being repaid to the aToken, where the liquidity is kept\n    IERC20(debtAsset).safeTransferFrom(\n      msg.sender,\n      debtReserve.aTokenAddress,\n      vars.actualDebtToLiquidate\n    );\n\n    emit LiquidationCall(\n      collateralAsset,\n      debtAsset,\n      user,\n      vars.actualDebtToLiquidate,\n      vars.maxCollateralToLiquidate,\n      msg.sender,\n      receiveAToken,\n      liquidationFeeTo\n    );\n\n    return (uint256(Errors.CollateralManagerErrors.NO_ERROR), Errors.LPCM_NO_ERRORS);\n  }\n\n  struct AvailableCollateralToLiquidateLocalVars {\n    uint256 userCompoundedBorrowBalance;\n    uint256 liquidationBonus;\n    uint256 collateralPrice;\n    uint256 debtAssetPrice;\n    uint256 maxAmountCollateralToLiquidate;\n    uint256 debtAssetDecimals;\n    uint256 collateralDecimals;\n  }\n\n  /**\n   * @dev Calculates how much of a specific collateral can be liquidated, given\n   * a certain amount of debt asset.\n   * - This function needs to be called after all the checks to validate the liquidation have been performed,\n   *   otherwise it might fail.\n   * @param collateralReserve The data of the collateral reserve\n   * @param debtReserve The data of the debt reserve\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param userCollateralBalance The collateral balance for the specific `collateralAsset` of the user being liquidated\n   * @return collateralAmount: The maximum amount that is possible to liquidate given all the liquidation constraints\n   *                           (user balance, close factor)\n   *         debtAmountNeeded: The amount to repay with the liquidation\n   **/\n  function _calculateAvailableCollateralToLiquidate(\n    DataTypes.ReserveData storage collateralReserve,\n    DataTypes.ReserveData storage debtReserve,\n    address collateralAsset,\n    address debtAsset,\n    uint256 debtToCover,\n    uint256 userCollateralBalance\n  ) internal view returns (uint256, uint256, uint256) {\n    uint256 collateralAmount = 0;\n    uint256 debtAmountNeeded = 0;\n    IPriceOracleGetter oracle = IPriceOracleGetter(_addressesProvider.getPriceOracle());\n\n    AvailableCollateralToLiquidateLocalVars memory vars;\n\n    vars.collateralPrice = oracle.getAssetPrice(collateralAsset);\n    vars.debtAssetPrice = oracle.getAssetPrice(debtAsset);\n\n    (, , vars.liquidationBonus, vars.collateralDecimals, ) = collateralReserve\n      .configuration\n      .getParams();\n    vars.debtAssetDecimals = debtReserve.configuration.getDecimals();\n\n    // This is the maximum possible amount of the selected collateral that can be liquidated, given the\n    // max amount of liquidatable debt\n    vars.maxAmountCollateralToLiquidate = vars\n      .debtAssetPrice\n      .mul(debtToCover)\n      .mul(10**vars.collateralDecimals)\n      .percentMul(vars.liquidationBonus)\n      .div(vars.collateralPrice.mul(10**vars.debtAssetDecimals));\n\n    if (vars.maxAmountCollateralToLiquidate > userCollateralBalance) {\n      collateralAmount = userCollateralBalance;\n      debtAmountNeeded = vars\n        .collateralPrice\n        .mul(collateralAmount)\n        .mul(10**vars.debtAssetDecimals)\n        .div(vars.debtAssetPrice.mul(10**vars.collateralDecimals))\n        .percentDiv(vars.liquidationBonus);\n    } else {\n      collateralAmount = vars.maxAmountCollateralToLiquidate;\n      debtAmountNeeded = debtToCover;\n    }\n    uint256 bonusCollateral = collateralAmount.sub(vars\n      .debtAssetPrice\n      .mul(debtAmountNeeded)\n      .mul(10**vars.collateralDecimals)\n      .div(vars.collateralPrice.mul(10**vars.debtAssetDecimals))\n    );\n    return (collateralAmount, bonusCollateral.div(2), debtAmountNeeded);\n  }\n}\n"
    },
    "contracts/protocol/lendingpool/LendingPoolConfigurator.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from '../../dependencies/openzeppelin/contracts/SafeMath.sol';\nimport {VersionedInitializable} from '../libraries/aave-upgradeability/VersionedInitializable.sol';\nimport {\n  InitializableImmutableAdminUpgradeabilityProxy\n} from '../libraries/aave-upgradeability/InitializableImmutableAdminUpgradeabilityProxy.sol';\nimport {ReserveConfiguration} from '../libraries/configuration/ReserveConfiguration.sol';\nimport {ILendingPoolAddressesProvider} from '../../interfaces/ILendingPoolAddressesProvider.sol';\nimport {ILendingPool} from '../../interfaces/ILendingPool.sol';\nimport {IERC20Detailed} from '../../dependencies/openzeppelin/contracts/IERC20Detailed.sol';\nimport {Errors} from '../libraries/helpers/Errors.sol';\nimport {PercentageMath} from '../libraries/math/PercentageMath.sol';\nimport {DataTypes} from '../libraries/types/DataTypes.sol';\nimport {IInitializableDebtToken} from '../../interfaces/IInitializableDebtToken.sol';\nimport {IInitializableAToken} from '../../interfaces/IInitializableAToken.sol';\nimport {IChefIncentivesController} from '../../interfaces/IChefIncentivesController.sol';\nimport {ILendingPoolConfigurator} from '../../interfaces/ILendingPoolConfigurator.sol';\nimport {IMultiFeeDistribution} from '../../interfaces/IMultiFeeDistribution.sol';\n\n/**\n * @title LendingPoolConfigurator contract\n * @author Aave\n * @dev Implements the configuration methods for the Aave protocol\n **/\n\ncontract LendingPoolConfigurator is VersionedInitializable, ILendingPoolConfigurator {\n  using SafeMath for uint256;\n  using PercentageMath for uint256;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n\n  ILendingPoolAddressesProvider internal addressesProvider;\n  ILendingPool internal pool;\n\n  modifier onlyPoolAdmin {\n    require(addressesProvider.getPoolAdmin() == msg.sender, Errors.CALLER_NOT_POOL_ADMIN);\n    _;\n  }\n\n  modifier onlyEmergencyAdmin {\n    require(\n      addressesProvider.getEmergencyAdmin() == msg.sender,\n      Errors.LPC_CALLER_NOT_EMERGENCY_ADMIN\n    );\n    _;\n  }\n\n  uint256 internal constant CONFIGURATOR_REVISION = 0x1;\n\n  function getRevision() internal pure override returns (uint256) {\n    return CONFIGURATOR_REVISION;\n  }\n\n  function initialize(ILendingPoolAddressesProvider provider) public initializer {\n    addressesProvider = provider;\n    pool = ILendingPool(addressesProvider.getLendingPool());\n  }\n\n  /**\n   * @dev Initializes reserves in batch\n   **/\n  function batchInitReserve(InitReserveInput[] calldata input) external onlyPoolAdmin {\n    ILendingPool cachedPool = pool;\n    for (uint256 i = 0; i < input.length; i++) {\n      _initReserve(cachedPool, input[i]);\n    }\n  }\n\n  function _initReserve(ILendingPool _pool, InitReserveInput calldata input) internal {\n    IChefIncentivesController incentivesController = IChefIncentivesController(input.incentivesController);\n    address aTokenProxyAddress =\n      _initTokenWithProxy(\n        input.aTokenImpl,\n        abi.encodeWithSelector(\n          IInitializableAToken.initialize.selector,\n          _pool,\n          input.treasury,\n          input.underlyingAsset,\n          incentivesController,\n          input.underlyingAssetDecimals,\n          input.aTokenName,\n          input.aTokenSymbol,\n          input.params\n        )\n      );\n    incentivesController.addPool(aTokenProxyAddress, input.allocPoint);\n    IMultiFeeDistribution(input.treasury).addReward(aTokenProxyAddress);\n\n    address stableDebtTokenProxyAddress =\n      _initTokenWithProxy(\n        input.stableDebtTokenImpl,\n        abi.encodeWithSelector(\n          IInitializableDebtToken.initialize.selector,\n          _pool,\n          input.underlyingAsset,\n          IChefIncentivesController(input.incentivesController),\n          input.underlyingAssetDecimals,\n          input.stableDebtTokenName,\n          input.stableDebtTokenSymbol,\n          input.params\n        )\n      );\n    // stableDebt is not added to incentives controller\n    // GEIST does not support stable lending\n\n    address variableDebtTokenProxyAddress =\n      _initTokenWithProxy(\n        input.variableDebtTokenImpl,\n        abi.encodeWithSelector(\n          IInitializableDebtToken.initialize.selector,\n          _pool,\n          input.underlyingAsset,\n          IChefIncentivesController(input.incentivesController),\n          input.underlyingAssetDecimals,\n          input.variableDebtTokenName,\n          input.variableDebtTokenSymbol,\n          input.params\n        )\n      );\n    incentivesController.addPool(variableDebtTokenProxyAddress, input.allocPoint);\n\n    _pool.initReserve(\n      input.underlyingAsset,\n      aTokenProxyAddress,\n      stableDebtTokenProxyAddress,\n      variableDebtTokenProxyAddress,\n      input.interestRateStrategyAddress\n    );\n\n    DataTypes.ReserveConfigurationMap memory currentConfig =\n      _pool.getConfiguration(input.underlyingAsset);\n\n    currentConfig.setDecimals(input.underlyingAssetDecimals);\n\n    currentConfig.setActive(true);\n    currentConfig.setFrozen(false);\n\n    pool.setConfiguration(input.underlyingAsset, currentConfig.data);\n\n    emit ReserveInitialized(\n      input.underlyingAsset,\n      aTokenProxyAddress,\n      stableDebtTokenProxyAddress,\n      variableDebtTokenProxyAddress,\n      input.interestRateStrategyAddress\n    );\n  }\n\n  /**\n   * @dev Updates the aToken implementation for the reserve\n   **/\n  function updateAToken(UpdateATokenInput calldata input) external onlyPoolAdmin {\n    ILendingPool cachedPool = pool;\n\n    DataTypes.ReserveData memory reserveData = cachedPool.getReserveData(input.asset);\n\n    (, , , uint256 decimals, ) = cachedPool.getConfiguration(input.asset).getParamsMemory();\n\n    bytes memory encodedCall = abi.encodeWithSelector(\n        IInitializableAToken.initialize.selector,\n        cachedPool,\n        input.treasury,\n        input.asset,\n        input.incentivesController,\n        decimals,\n        input.name,\n        input.symbol,\n        input.params\n      );\n\n    _upgradeTokenImplementation(\n      reserveData.aTokenAddress,\n      input.implementation,\n      encodedCall\n    );\n\n    emit ATokenUpgraded(input.asset, reserveData.aTokenAddress, input.implementation);\n  }\n\n  /**\n   * @dev Updates the stable debt token implementation for the reserve\n   **/\n  function updateStableDebtToken(UpdateDebtTokenInput calldata input) external onlyPoolAdmin {\n    ILendingPool cachedPool = pool;\n\n    DataTypes.ReserveData memory reserveData = cachedPool.getReserveData(input.asset);\n\n    (, , , uint256 decimals, ) = cachedPool.getConfiguration(input.asset).getParamsMemory();\n\n    bytes memory encodedCall = abi.encodeWithSelector(\n        IInitializableDebtToken.initialize.selector,\n        cachedPool,\n        input.asset,\n        input.incentivesController,\n        decimals,\n        input.name,\n        input.symbol,\n        input.params\n      );\n\n    _upgradeTokenImplementation(\n      reserveData.stableDebtTokenAddress,\n      input.implementation,\n      encodedCall\n    );\n\n    emit StableDebtTokenUpgraded(\n      input.asset,\n      reserveData.stableDebtTokenAddress,\n      input.implementation\n    );\n  }\n\n  /**\n   * @dev Updates the variable debt token implementation for the asset\n   **/\n  function updateVariableDebtToken(UpdateDebtTokenInput calldata input)\n    external\n    onlyPoolAdmin\n  {\n    ILendingPool cachedPool = pool;\n\n    DataTypes.ReserveData memory reserveData = cachedPool.getReserveData(input.asset);\n\n    (, , , uint256 decimals, ) = cachedPool.getConfiguration(input.asset).getParamsMemory();\n\n    bytes memory encodedCall = abi.encodeWithSelector(\n        IInitializableDebtToken.initialize.selector,\n        cachedPool,\n        input.asset,\n        input.incentivesController,\n        decimals,\n        input.name,\n        input.symbol,\n        input.params\n      );\n\n    _upgradeTokenImplementation(\n      reserveData.variableDebtTokenAddress,\n      input.implementation,\n      encodedCall\n    );\n\n    emit VariableDebtTokenUpgraded(\n      input.asset,\n      reserveData.variableDebtTokenAddress,\n      input.implementation\n    );\n  }\n\n  /**\n   * @dev Enables borrowing on a reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @param stableBorrowRateEnabled True if stable borrow rate needs to be enabled by default on this reserve\n   **/\n  function enableBorrowingOnReserve(address asset, bool stableBorrowRateEnabled)\n    external\n    onlyPoolAdmin\n  {\n    DataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset);\n\n    currentConfig.setBorrowingEnabled(true);\n    currentConfig.setStableRateBorrowingEnabled(stableBorrowRateEnabled);\n\n    pool.setConfiguration(asset, currentConfig.data);\n\n    emit BorrowingEnabledOnReserve(asset, stableBorrowRateEnabled);\n  }\n\n  /**\n   * @dev Disables borrowing on a reserve\n   * @param asset The address of the underlying asset of the reserve\n   **/\n  function disableBorrowingOnReserve(address asset) external onlyPoolAdmin {\n    DataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset);\n\n    currentConfig.setBorrowingEnabled(false);\n\n    pool.setConfiguration(asset, currentConfig.data);\n    emit BorrowingDisabledOnReserve(asset);\n  }\n\n  /**\n   * @dev Configures the reserve collateralization parameters\n   * all the values are expressed in percentages with two decimals of precision. A valid value is 10000, which means 100.00%\n   * @param asset The address of the underlying asset of the reserve\n   * @param ltv The loan to value of the asset when used as collateral\n   * @param liquidationThreshold The threshold at which loans using this asset as collateral will be considered undercollateralized\n   * @param liquidationBonus The bonus liquidators receive to liquidate this asset. The values is always above 100%. A value of 105%\n   * means the liquidator will receive a 5% bonus\n   **/\n  function configureReserveAsCollateral(\n    address asset,\n    uint256 ltv,\n    uint256 liquidationThreshold,\n    uint256 liquidationBonus\n  ) external onlyPoolAdmin {\n    DataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset);\n\n    //validation of the parameters: the LTV can\n    //only be lower or equal than the liquidation threshold\n    //(otherwise a loan against the asset would cause instantaneous liquidation)\n    require(ltv <= liquidationThreshold, Errors.LPC_INVALID_CONFIGURATION);\n\n    if (liquidationThreshold != 0) {\n      //liquidation bonus must be bigger than 100.00%, otherwise the liquidator would receive less\n      //collateral than needed to cover the debt\n      require(\n        liquidationBonus > PercentageMath.PERCENTAGE_FACTOR,\n        Errors.LPC_INVALID_CONFIGURATION\n      );\n\n      //if threshold * bonus is less than PERCENTAGE_FACTOR, it's guaranteed that at the moment\n      //a loan is taken there is enough collateral available to cover the liquidation bonus\n      require(\n        liquidationThreshold.percentMul(liquidationBonus) <= PercentageMath.PERCENTAGE_FACTOR,\n        Errors.LPC_INVALID_CONFIGURATION\n      );\n    } else {\n      require(liquidationBonus == 0, Errors.LPC_INVALID_CONFIGURATION);\n      //if the liquidation threshold is being set to 0,\n      // the reserve is being disabled as collateral. To do so,\n      //we need to ensure no liquidity is deposited\n      _checkNoLiquidity(asset);\n    }\n\n    currentConfig.setLtv(ltv);\n    currentConfig.setLiquidationThreshold(liquidationThreshold);\n    currentConfig.setLiquidationBonus(liquidationBonus);\n\n    pool.setConfiguration(asset, currentConfig.data);\n\n    emit CollateralConfigurationChanged(asset, ltv, liquidationThreshold, liquidationBonus);\n  }\n\n  /**\n   * @dev Enable stable rate borrowing on a reserve\n   * @param asset The address of the underlying asset of the reserve\n   **/\n  function enableReserveStableRate(address asset) external onlyPoolAdmin {\n    DataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset);\n\n    currentConfig.setStableRateBorrowingEnabled(true);\n\n    pool.setConfiguration(asset, currentConfig.data);\n\n    emit StableRateEnabledOnReserve(asset);\n  }\n\n  /**\n   * @dev Disable stable rate borrowing on a reserve\n   * @param asset The address of the underlying asset of the reserve\n   **/\n  function disableReserveStableRate(address asset) external onlyPoolAdmin {\n    DataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset);\n\n    currentConfig.setStableRateBorrowingEnabled(false);\n\n    pool.setConfiguration(asset, currentConfig.data);\n\n    emit StableRateDisabledOnReserve(asset);\n  }\n\n  /**\n   * @dev Activates a reserve\n   * @param asset The address of the underlying asset of the reserve\n   **/\n  function activateReserve(address asset) external onlyPoolAdmin {\n    DataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset);\n\n    currentConfig.setActive(true);\n\n    pool.setConfiguration(asset, currentConfig.data);\n\n    emit ReserveActivated(asset);\n  }\n\n  /**\n   * @dev Deactivates a reserve\n   * @param asset The address of the underlying asset of the reserve\n   **/\n  function deactivateReserve(address asset) external onlyPoolAdmin {\n    _checkNoLiquidity(asset);\n\n    DataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset);\n\n    currentConfig.setActive(false);\n\n    pool.setConfiguration(asset, currentConfig.data);\n\n    emit ReserveDeactivated(asset);\n  }\n\n  /**\n   * @dev Freezes a reserve. A frozen reserve doesn't allow any new deposit, borrow or rate swap\n   *  but allows repayments, liquidations, rate rebalances and withdrawals\n   * @param asset The address of the underlying asset of the reserve\n   **/\n  function freezeReserve(address asset) external onlyPoolAdmin {\n    DataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset);\n\n    currentConfig.setFrozen(true);\n\n    pool.setConfiguration(asset, currentConfig.data);\n\n    emit ReserveFrozen(asset);\n  }\n\n  /**\n   * @dev Unfreezes a reserve\n   * @param asset The address of the underlying asset of the reserve\n   **/\n  function unfreezeReserve(address asset) external onlyPoolAdmin {\n    DataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset);\n\n    currentConfig.setFrozen(false);\n\n    pool.setConfiguration(asset, currentConfig.data);\n\n    emit ReserveUnfrozen(asset);\n  }\n\n  /**\n   * @dev Updates the reserve factor of a reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @param reserveFactor The new reserve factor of the reserve\n   **/\n  function setReserveFactor(address asset, uint256 reserveFactor) external onlyPoolAdmin {\n    DataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset);\n\n    currentConfig.setReserveFactor(reserveFactor);\n\n    pool.setConfiguration(asset, currentConfig.data);\n\n    emit ReserveFactorChanged(asset, reserveFactor);\n  }\n\n  /**\n   * @dev Sets the interest rate strategy of a reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @param rateStrategyAddress The new address of the interest strategy contract\n   **/\n  function setReserveInterestRateStrategyAddress(address asset, address rateStrategyAddress)\n    external\n    onlyPoolAdmin\n  {\n    pool.setReserveInterestRateStrategyAddress(asset, rateStrategyAddress);\n    emit ReserveInterestRateStrategyChanged(asset, rateStrategyAddress);\n  }\n\n  /**\n   * @dev pauses or unpauses all the actions of the protocol, including aToken transfers\n   * @param val true if protocol needs to be paused, false otherwise\n   **/\n  function setPoolPause(bool val) external onlyEmergencyAdmin {\n    pool.setPause(val);\n  }\n\n  function _initTokenWithProxy(address implementation, bytes memory initParams)\n    internal\n    returns (address)\n  {\n    InitializableImmutableAdminUpgradeabilityProxy proxy =\n      new InitializableImmutableAdminUpgradeabilityProxy(address(this));\n\n    proxy.initialize(implementation, initParams);\n\n    return address(proxy);\n  }\n\n  function _upgradeTokenImplementation(\n    address proxyAddress,\n    address implementation,\n    bytes memory initParams\n  ) internal {\n    InitializableImmutableAdminUpgradeabilityProxy proxy =\n      InitializableImmutableAdminUpgradeabilityProxy(payable(proxyAddress));\n\n    proxy.upgradeToAndCall(implementation, initParams);\n  }\n\n  function _checkNoLiquidity(address asset) internal view {\n    DataTypes.ReserveData memory reserveData = pool.getReserveData(asset);\n\n    uint256 availableLiquidity = IERC20Detailed(asset).balanceOf(reserveData.aTokenAddress);\n\n    require(\n      availableLiquidity == 0 && reserveData.currentLiquidityRate == 0,\n      Errors.LPC_RESERVE_LIQUIDITY_NOT_0\n    );\n  }\n}\n"
    },
    "contracts/protocol/lendingpool/LendingPoolStorage.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\nimport {UserConfiguration} from '../libraries/configuration/UserConfiguration.sol';\nimport {ReserveConfiguration} from '../libraries/configuration/ReserveConfiguration.sol';\nimport {ReserveLogic} from '../libraries/logic/ReserveLogic.sol';\nimport {ILendingPoolAddressesProvider} from '../../interfaces/ILendingPoolAddressesProvider.sol';\nimport {DataTypes} from '../libraries/types/DataTypes.sol';\n\ncontract LendingPoolStorage {\n  using ReserveLogic for DataTypes.ReserveData;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using UserConfiguration for DataTypes.UserConfigurationMap;\n\n  ILendingPoolAddressesProvider internal _addressesProvider;\n\n  mapping(address => DataTypes.ReserveData) internal _reserves;\n  mapping(address => DataTypes.UserConfigurationMap) internal _usersConfig;\n\n  // the list of the available reserves, structured as a mapping for gas savings reasons\n  mapping(uint256 => address) internal _reservesList;\n\n  uint256 internal _reservesCount;\n\n  bool internal _paused;\n\n  uint256 internal _maxStableRateBorrowSizePercent;\n\n  uint256 internal _flashLoanPremiumTotal;\n\n  uint256 internal _maxNumberOfReserves;\n}\n"
    },
    "contracts/protocol/libraries/aave-upgradeability/BaseImmutableAdminUpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\nimport '../../../dependencies/openzeppelin/upgradeability/BaseUpgradeabilityProxy.sol';\n\n/**\n * @title BaseImmutableAdminUpgradeabilityProxy\n * @author Aave, inspired by the OpenZeppelin upgradeability proxy pattern\n * @dev This contract combines an upgradeability proxy with an authorization\n * mechanism for administrative tasks. The admin role is stored in an immutable, which\n * helps saving transactions costs\n * All external functions in this contract must be guarded by the\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\n * feature proposal that would enable this to be done automatically.\n */\ncontract BaseImmutableAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {\n  address immutable ADMIN;\n\n  constructor(address _admin) {\n    ADMIN = _admin;\n  }\n\n  modifier ifAdmin() {\n    if (msg.sender == ADMIN) {\n      _;\n    } else {\n      _fallback();\n    }\n  }\n\n  /**\n   * @return _address The address of the proxy admin.\n   */\n  function admin() external ifAdmin returns (address _address) {\n    return ADMIN;\n  }\n\n  /**\n   * @return _address The address of the implementation.\n   */\n  function implementation() external ifAdmin returns (address _address) {\n    return _implementation();\n  }\n\n  /**\n   * @dev Upgrade the backing implementation of the proxy.\n   * Only the admin can call this function.\n   * @param newImplementation Address of the new implementation.\n   */\n  function upgradeTo(address newImplementation) external ifAdmin {\n    _upgradeTo(newImplementation);\n  }\n\n  /**\n   * @dev Upgrade the backing implementation of the proxy and call a function\n   * on the new implementation.\n   * This is useful to initialize the proxied contract.\n   * @param newImplementation Address of the new implementation.\n   * @param data Data to send as msg.data in the low level call.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   */\n  function upgradeToAndCall(address newImplementation, bytes calldata data)\n    external\n    payable\n    ifAdmin\n  {\n    _upgradeTo(newImplementation);\n    (bool success, ) = newImplementation.delegatecall(data);\n    require(success);\n  }\n\n  /**\n   * @dev Only fall back when the sender is not the admin.\n   */\n  function _willFallback() internal virtual override {\n    require(msg.sender != ADMIN, 'Cannot call fallback function from the proxy admin');\n    super._willFallback();\n  }\n}\n"
    },
    "contracts/protocol/libraries/aave-upgradeability/InitializableImmutableAdminUpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\nimport './BaseImmutableAdminUpgradeabilityProxy.sol';\nimport '../../../dependencies/openzeppelin/upgradeability/InitializableUpgradeabilityProxy.sol';\n\n/**\n * @title InitializableAdminUpgradeabilityProxy\n * @dev Extends BaseAdminUpgradeabilityProxy with an initializer function\n */\ncontract InitializableImmutableAdminUpgradeabilityProxy is\n  BaseImmutableAdminUpgradeabilityProxy,\n  InitializableUpgradeabilityProxy\n{\n  constructor(address admin) BaseImmutableAdminUpgradeabilityProxy(admin) {}\n\n  /**\n   * @dev Only fall back when the sender is not the admin.\n   */\n  function _willFallback() internal override(BaseImmutableAdminUpgradeabilityProxy, Proxy) {\n    BaseImmutableAdminUpgradeabilityProxy._willFallback();\n  }\n}\n"
    },
    "contracts/protocol/libraries/aave-upgradeability/VersionedInitializable.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\n/**\n * @title VersionedInitializable\n *\n * @dev Helper contract to implement initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n *\n * @author Aave, inspired by the OpenZeppelin Initializable contract\n */\nabstract contract VersionedInitializable {\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  uint256 private lastInitializedRevision = 0;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    uint256 revision = getRevision();\n    require(\n      initializing || isConstructor() || revision > lastInitializedRevision,\n      'Contract instance has already been initialized'\n    );\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      lastInitializedRevision = revision;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /**\n   * @dev returns the revision number of the contract\n   * Needs to be defined in the inherited class as a constant.\n   **/\n  function getRevision() internal pure virtual returns (uint256);\n\n  /**\n   * @dev Returns true if and only if the function is running in the constructor\n   **/\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    uint256 cs;\n    //solium-disable-next-line\n    assembly {\n      cs := extcodesize(address())\n    }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n"
    },
    "contracts/protocol/libraries/configuration/ReserveConfiguration.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\nimport {Errors} from '../helpers/Errors.sol';\nimport {DataTypes} from '../types/DataTypes.sol';\n\n/**\n * @title ReserveConfiguration library\n * @author Aave\n * @notice Implements the bitmap logic to handle the reserve configuration\n */\nlibrary ReserveConfiguration {\n  uint256 constant LTV_MASK =                   0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000; // prettier-ignore\n  uint256 constant LIQUIDATION_THRESHOLD_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFF; // prettier-ignore\n  uint256 constant LIQUIDATION_BONUS_MASK =     0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFF; // prettier-ignore\n  uint256 constant DECIMALS_MASK =              0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFF; // prettier-ignore\n  uint256 constant ACTIVE_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 constant FROZEN_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 constant BORROWING_MASK =             0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 constant STABLE_BORROWING_MASK =      0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFFFFF; // prettier-ignore\n  uint256 constant RESERVE_FACTOR_MASK =        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFF; // prettier-ignore\n\n  /// @dev For the LTV, the start bit is 0 (up to 15), hence no bitshifting is needed\n  uint256 constant LIQUIDATION_THRESHOLD_START_BIT_POSITION = 16;\n  uint256 constant LIQUIDATION_BONUS_START_BIT_POSITION = 32;\n  uint256 constant RESERVE_DECIMALS_START_BIT_POSITION = 48;\n  uint256 constant IS_ACTIVE_START_BIT_POSITION = 56;\n  uint256 constant IS_FROZEN_START_BIT_POSITION = 57;\n  uint256 constant BORROWING_ENABLED_START_BIT_POSITION = 58;\n  uint256 constant STABLE_BORROWING_ENABLED_START_BIT_POSITION = 59;\n  uint256 constant RESERVE_FACTOR_START_BIT_POSITION = 64;\n\n  uint256 constant MAX_VALID_LTV = 65535;\n  uint256 constant MAX_VALID_LIQUIDATION_THRESHOLD = 65535;\n  uint256 constant MAX_VALID_LIQUIDATION_BONUS = 65535;\n  uint256 constant MAX_VALID_DECIMALS = 255;\n  uint256 constant MAX_VALID_RESERVE_FACTOR = 65535;\n\n  /**\n   * @dev Sets the Loan to Value of the reserve\n   * @param self The reserve configuration\n   * @param ltv the new ltv\n   **/\n  function setLtv(DataTypes.ReserveConfigurationMap memory self, uint256 ltv) internal pure {\n    require(ltv <= MAX_VALID_LTV, Errors.RC_INVALID_LTV);\n\n    self.data = (self.data & LTV_MASK) | ltv;\n  }\n\n  /**\n   * @dev Gets the Loan to Value of the reserve\n   * @param self The reserve configuration\n   * @return The loan to value\n   **/\n  function getLtv(DataTypes.ReserveConfigurationMap storage self) internal view returns (uint256) {\n    return self.data & ~LTV_MASK;\n  }\n\n  /**\n   * @dev Sets the liquidation threshold of the reserve\n   * @param self The reserve configuration\n   * @param threshold The new liquidation threshold\n   **/\n  function setLiquidationThreshold(DataTypes.ReserveConfigurationMap memory self, uint256 threshold)\n    internal\n    pure\n  {\n    require(threshold <= MAX_VALID_LIQUIDATION_THRESHOLD, Errors.RC_INVALID_LIQ_THRESHOLD);\n\n    self.data =\n      (self.data & LIQUIDATION_THRESHOLD_MASK) |\n      (threshold << LIQUIDATION_THRESHOLD_START_BIT_POSITION);\n  }\n\n  /**\n   * @dev Gets the liquidation threshold of the reserve\n   * @param self The reserve configuration\n   * @return The liquidation threshold\n   **/\n  function getLiquidationThreshold(DataTypes.ReserveConfigurationMap storage self)\n    internal\n    view\n    returns (uint256)\n  {\n    return (self.data & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION;\n  }\n\n  /**\n   * @dev Sets the liquidation bonus of the reserve\n   * @param self The reserve configuration\n   * @param bonus The new liquidation bonus\n   **/\n  function setLiquidationBonus(DataTypes.ReserveConfigurationMap memory self, uint256 bonus)\n    internal\n    pure\n  {\n    require(bonus <= MAX_VALID_LIQUIDATION_BONUS, Errors.RC_INVALID_LIQ_BONUS);\n\n    self.data =\n      (self.data & LIQUIDATION_BONUS_MASK) |\n      (bonus << LIQUIDATION_BONUS_START_BIT_POSITION);\n  }\n\n  /**\n   * @dev Gets the liquidation bonus of the reserve\n   * @param self The reserve configuration\n   * @return The liquidation bonus\n   **/\n  function getLiquidationBonus(DataTypes.ReserveConfigurationMap storage self)\n    internal\n    view\n    returns (uint256)\n  {\n    return (self.data & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION;\n  }\n\n  /**\n   * @dev Sets the decimals of the underlying asset of the reserve\n   * @param self The reserve configuration\n   * @param decimals The decimals\n   **/\n  function setDecimals(DataTypes.ReserveConfigurationMap memory self, uint256 decimals)\n    internal\n    pure\n  {\n    require(decimals <= MAX_VALID_DECIMALS, Errors.RC_INVALID_DECIMALS);\n\n    self.data = (self.data & DECIMALS_MASK) | (decimals << RESERVE_DECIMALS_START_BIT_POSITION);\n  }\n\n  /**\n   * @dev Gets the decimals of the underlying asset of the reserve\n   * @param self The reserve configuration\n   * @return The decimals of the asset\n   **/\n  function getDecimals(DataTypes.ReserveConfigurationMap storage self)\n    internal\n    view\n    returns (uint256)\n  {\n    return (self.data & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION;\n  }\n\n  /**\n   * @dev Sets the active state of the reserve\n   * @param self The reserve configuration\n   * @param active The active state\n   **/\n  function setActive(DataTypes.ReserveConfigurationMap memory self, bool active) internal pure {\n    self.data =\n      (self.data & ACTIVE_MASK) |\n      (uint256(active ? 1 : 0) << IS_ACTIVE_START_BIT_POSITION);\n  }\n\n  /**\n   * @dev Gets the active state of the reserve\n   * @param self The reserve configuration\n   * @return The active state\n   **/\n  function getActive(DataTypes.ReserveConfigurationMap storage self) internal view returns (bool) {\n    return (self.data & ~ACTIVE_MASK) != 0;\n  }\n\n  /**\n   * @dev Sets the frozen state of the reserve\n   * @param self The reserve configuration\n   * @param frozen The frozen state\n   **/\n  function setFrozen(DataTypes.ReserveConfigurationMap memory self, bool frozen) internal pure {\n    self.data =\n      (self.data & FROZEN_MASK) |\n      (uint256(frozen ? 1 : 0) << IS_FROZEN_START_BIT_POSITION);\n  }\n\n  /**\n   * @dev Gets the frozen state of the reserve\n   * @param self The reserve configuration\n   * @return The frozen state\n   **/\n  function getFrozen(DataTypes.ReserveConfigurationMap storage self) internal view returns (bool) {\n    return (self.data & ~FROZEN_MASK) != 0;\n  }\n\n  /**\n   * @dev Enables or disables borrowing on the reserve\n   * @param self The reserve configuration\n   * @param enabled True if the borrowing needs to be enabled, false otherwise\n   **/\n  function setBorrowingEnabled(DataTypes.ReserveConfigurationMap memory self, bool enabled)\n    internal\n    pure\n  {\n    self.data =\n      (self.data & BORROWING_MASK) |\n      (uint256(enabled ? 1 : 0) << BORROWING_ENABLED_START_BIT_POSITION);\n  }\n\n  /**\n   * @dev Gets the borrowing state of the reserve\n   * @param self The reserve configuration\n   * @return The borrowing state\n   **/\n  function getBorrowingEnabled(DataTypes.ReserveConfigurationMap storage self)\n    internal\n    view\n    returns (bool)\n  {\n    return (self.data & ~BORROWING_MASK) != 0;\n  }\n\n  /**\n   * @dev Enables or disables stable rate borrowing on the reserve\n   * @param self The reserve configuration\n   * @param enabled True if the stable rate borrowing needs to be enabled, false otherwise\n   **/\n  function setStableRateBorrowingEnabled(\n    DataTypes.ReserveConfigurationMap memory self,\n    bool enabled\n  ) internal pure {\n    self.data =\n      (self.data & STABLE_BORROWING_MASK) |\n      (uint256(enabled ? 1 : 0) << STABLE_BORROWING_ENABLED_START_BIT_POSITION);\n  }\n\n  /**\n   * @dev Gets the stable rate borrowing state of the reserve\n   * @param self The reserve configuration\n   * @return The stable rate borrowing state\n   **/\n  function getStableRateBorrowingEnabled(DataTypes.ReserveConfigurationMap storage self)\n    internal\n    view\n    returns (bool)\n  {\n    return (self.data & ~STABLE_BORROWING_MASK) != 0;\n  }\n\n  /**\n   * @dev Sets the reserve factor of the reserve\n   * @param self The reserve configuration\n   * @param reserveFactor The reserve factor\n   **/\n  function setReserveFactor(DataTypes.ReserveConfigurationMap memory self, uint256 reserveFactor)\n    internal\n    pure\n  {\n    require(reserveFactor <= MAX_VALID_RESERVE_FACTOR, Errors.RC_INVALID_RESERVE_FACTOR);\n\n    self.data =\n      (self.data & RESERVE_FACTOR_MASK) |\n      (reserveFactor << RESERVE_FACTOR_START_BIT_POSITION);\n  }\n\n  /**\n   * @dev Gets the reserve factor of the reserve\n   * @param self The reserve configuration\n   * @return The reserve factor\n   **/\n  function getReserveFactor(DataTypes.ReserveConfigurationMap storage self)\n    internal\n    view\n    returns (uint256)\n  {\n    return (self.data & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION;\n  }\n\n  /**\n   * @dev Gets the configuration flags of the reserve\n   * @param self The reserve configuration\n   * @return The state flags representing active, frozen, borrowing enabled, stableRateBorrowing enabled\n   **/\n  function getFlags(DataTypes.ReserveConfigurationMap storage self)\n    internal\n    view\n    returns (\n      bool,\n      bool,\n      bool,\n      bool\n    )\n  {\n    uint256 dataLocal = self.data;\n\n    return (\n      (dataLocal & ~ACTIVE_MASK) != 0,\n      (dataLocal & ~FROZEN_MASK) != 0,\n      (dataLocal & ~BORROWING_MASK) != 0,\n      (dataLocal & ~STABLE_BORROWING_MASK) != 0\n    );\n  }\n\n  /**\n   * @dev Gets the configuration paramters of the reserve\n   * @param self The reserve configuration\n   * @return The state params representing ltv, liquidation threshold, liquidation bonus, the reserve decimals\n   **/\n  function getParams(DataTypes.ReserveConfigurationMap storage self)\n    internal\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    uint256 dataLocal = self.data;\n\n    return (\n      dataLocal & ~LTV_MASK,\n      (dataLocal & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION,\n      (dataLocal & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION,\n      (dataLocal & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION,\n      (dataLocal & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION\n    );\n  }\n\n  /**\n   * @dev Gets the configuration paramters of the reserve from a memory object\n   * @param self The reserve configuration\n   * @return The state params representing ltv, liquidation threshold, liquidation bonus, the reserve decimals\n   **/\n  function getParamsMemory(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (\n      uint256,\n      uint256,\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    return (\n      self.data & ~LTV_MASK,\n      (self.data & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION,\n      (self.data & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION,\n      (self.data & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION,\n      (self.data & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION\n    );\n  }\n\n  /**\n   * @dev Gets the configuration flags of the reserve from a memory object\n   * @param self The reserve configuration\n   * @return The state flags representing active, frozen, borrowing enabled, stableRateBorrowing enabled\n   **/\n  function getFlagsMemory(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (\n      bool,\n      bool,\n      bool,\n      bool\n    )\n  {\n    return (\n      (self.data & ~ACTIVE_MASK) != 0,\n      (self.data & ~FROZEN_MASK) != 0,\n      (self.data & ~BORROWING_MASK) != 0,\n      (self.data & ~STABLE_BORROWING_MASK) != 0\n    );\n  }\n}\n"
    },
    "contracts/protocol/libraries/configuration/UserConfiguration.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\nimport {Errors} from '../helpers/Errors.sol';\nimport {DataTypes} from '../types/DataTypes.sol';\n\n/**\n * @title UserConfiguration library\n * @author Aave\n * @notice Implements the bitmap logic to handle the user configuration\n */\nlibrary UserConfiguration {\n  uint256 internal constant BORROWING_MASK =\n    0x5555555555555555555555555555555555555555555555555555555555555555;\n\n  /**\n   * @dev Sets if the user is borrowing the reserve identified by reserveIndex\n   * @param self The configuration object\n   * @param reserveIndex The index of the reserve in the bitmap\n   * @param borrowing True if the user is borrowing the reserve, false otherwise\n   **/\n  function setBorrowing(\n    DataTypes.UserConfigurationMap storage self,\n    uint256 reserveIndex,\n    bool borrowing\n  ) internal {\n    require(reserveIndex < 128, Errors.UL_INVALID_INDEX);\n    self.data =\n      (self.data & ~(1 << (reserveIndex * 2))) |\n      (uint256(borrowing ? 1 : 0) << (reserveIndex * 2));\n  }\n\n  /**\n   * @dev Sets if the user is using as collateral the reserve identified by reserveIndex\n   * @param self The configuration object\n   * @param reserveIndex The index of the reserve in the bitmap\n   * @param usingAsCollateral True if the user is usin the reserve as collateral, false otherwise\n   **/\n  function setUsingAsCollateral(\n    DataTypes.UserConfigurationMap storage self,\n    uint256 reserveIndex,\n    bool usingAsCollateral\n  ) internal {\n    require(reserveIndex < 128, Errors.UL_INVALID_INDEX);\n    self.data =\n      (self.data & ~(1 << (reserveIndex * 2 + 1))) |\n      (uint256(usingAsCollateral ? 1 : 0) << (reserveIndex * 2 + 1));\n  }\n\n  /**\n   * @dev Used to validate if a user has been using the reserve for borrowing or as collateral\n   * @param self The configuration object\n   * @param reserveIndex The index of the reserve in the bitmap\n   * @return True if the user has been using a reserve for borrowing or as collateral, false otherwise\n   **/\n  function isUsingAsCollateralOrBorrowing(\n    DataTypes.UserConfigurationMap memory self,\n    uint256 reserveIndex\n  ) internal pure returns (bool) {\n    require(reserveIndex < 128, Errors.UL_INVALID_INDEX);\n    return (self.data >> (reserveIndex * 2)) & 3 != 0;\n  }\n\n  /**\n   * @dev Used to validate if a user has been using the reserve for borrowing\n   * @param self The configuration object\n   * @param reserveIndex The index of the reserve in the bitmap\n   * @return True if the user has been using a reserve for borrowing, false otherwise\n   **/\n  function isBorrowing(DataTypes.UserConfigurationMap memory self, uint256 reserveIndex)\n    internal\n    pure\n    returns (bool)\n  {\n    require(reserveIndex < 128, Errors.UL_INVALID_INDEX);\n    return (self.data >> (reserveIndex * 2)) & 1 != 0;\n  }\n\n  /**\n   * @dev Used to validate if a user has been using the reserve as collateral\n   * @param self The configuration object\n   * @param reserveIndex The index of the reserve in the bitmap\n   * @return True if the user has been using a reserve as collateral, false otherwise\n   **/\n  function isUsingAsCollateral(DataTypes.UserConfigurationMap memory self, uint256 reserveIndex)\n    internal\n    pure\n    returns (bool)\n  {\n    require(reserveIndex < 128, Errors.UL_INVALID_INDEX);\n    return (self.data >> (reserveIndex * 2 + 1)) & 1 != 0;\n  }\n\n  /**\n   * @dev Used to validate if a user has been borrowing from any reserve\n   * @param self The configuration object\n   * @return True if the user has been borrowing any reserve, false otherwise\n   **/\n  function isBorrowingAny(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {\n    return self.data & BORROWING_MASK != 0;\n  }\n\n  /**\n   * @dev Used to validate if a user has not been using any reserve\n   * @param self The configuration object\n   * @return True if the user has been borrowing any reserve, false otherwise\n   **/\n  function isEmpty(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {\n    return self.data == 0;\n  }\n}\n"
    },
    "contracts/protocol/libraries/helpers/Errors.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\n/**\n * @title Errors library\n * @author Aave\n * @notice Defines the error messages emitted by the different contracts of the Aave protocol\n * @dev Error messages prefix glossary:\n *  - VL = ValidationLogic\n *  - MATH = Math libraries\n *  - CT = Common errors between tokens (AToken, VariableDebtToken and StableDebtToken)\n *  - AT = AToken\n *  - SDT = StableDebtToken\n *  - VDT = VariableDebtToken\n *  - LP = LendingPool\n *  - LPAPR = LendingPoolAddressesProviderRegistry\n *  - LPC = LendingPoolConfiguration\n *  - RL = ReserveLogic\n *  - LPCM = LendingPoolCollateralManager\n *  - P = Pausable\n */\nlibrary Errors {\n  //common errors\n  string public constant CALLER_NOT_POOL_ADMIN = '33'; // 'The caller must be the pool admin'\n  string public constant BORROW_ALLOWANCE_NOT_ENOUGH = '59'; // User borrows on behalf, but allowance are too small\n\n  //contract specific errors\n  string public constant VL_INVALID_AMOUNT = '1'; // 'Amount must be greater than 0'\n  string public constant VL_NO_ACTIVE_RESERVE = '2'; // 'Action requires an active reserve'\n  string public constant VL_RESERVE_FROZEN = '3'; // 'Action cannot be performed because the reserve is frozen'\n  string public constant VL_CURRENT_AVAILABLE_LIQUIDITY_NOT_ENOUGH = '4'; // 'The current liquidity is not enough'\n  string public constant VL_NOT_ENOUGH_AVAILABLE_USER_BALANCE = '5'; // 'User cannot withdraw more than the available balance'\n  string public constant VL_TRANSFER_NOT_ALLOWED = '6'; // 'Transfer cannot be allowed.'\n  string public constant VL_BORROWING_NOT_ENABLED = '7'; // 'Borrowing is not enabled'\n  string public constant VL_INVALID_INTEREST_RATE_MODE_SELECTED = '8'; // 'Invalid interest rate mode selected'\n  string public constant VL_COLLATERAL_BALANCE_IS_0 = '9'; // 'The collateral balance is 0'\n  string public constant VL_HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD = '10'; // 'Health factor is lesser than the liquidation threshold'\n  string public constant VL_COLLATERAL_CANNOT_COVER_NEW_BORROW = '11'; // 'There is not enough collateral to cover a new borrow'\n  string public constant VL_STABLE_BORROWING_NOT_ENABLED = '12'; // stable borrowing not enabled\n  string public constant VL_COLLATERAL_SAME_AS_BORROWING_CURRENCY = '13'; // collateral is (mostly) the same currency that is being borrowed\n  string public constant VL_AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE = '14'; // 'The requested amount is greater than the max loan size in stable rate mode\n  string public constant VL_NO_DEBT_OF_SELECTED_TYPE = '15'; // 'for repayment of stable debt, the user needs to have stable debt, otherwise, he needs to have variable debt'\n  string public constant VL_NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF = '16'; // 'To repay on behalf of an user an explicit amount to repay is needed'\n  string public constant VL_NO_STABLE_RATE_LOAN_IN_RESERVE = '17'; // 'User does not have a stable rate loan in progress on this reserve'\n  string public constant VL_NO_VARIABLE_RATE_LOAN_IN_RESERVE = '18'; // 'User does not have a variable rate loan in progress on this reserve'\n  string public constant VL_UNDERLYING_BALANCE_NOT_GREATER_THAN_0 = '19'; // 'The underlying balance needs to be greater than 0'\n  string public constant VL_DEPOSIT_ALREADY_IN_USE = '20'; // 'User deposit is already being used as collateral'\n  string public constant LP_NOT_ENOUGH_STABLE_BORROW_BALANCE = '21'; // 'User does not have any stable rate loan for this reserve'\n  string public constant LP_INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET = '22'; // 'Interest rate rebalance conditions were not met'\n  string public constant LP_LIQUIDATION_CALL_FAILED = '23'; // 'Liquidation call failed'\n  string public constant LP_NOT_ENOUGH_LIQUIDITY_TO_BORROW = '24'; // 'There is not enough liquidity available to borrow'\n  string public constant LP_REQUESTED_AMOUNT_TOO_SMALL = '25'; // 'The requested amount is too small for a FlashLoan.'\n  string public constant LP_INCONSISTENT_PROTOCOL_ACTUAL_BALANCE = '26'; // 'The actual balance of the protocol is inconsistent'\n  string public constant LP_CALLER_NOT_LENDING_POOL_CONFIGURATOR = '27'; // 'The caller of the function is not the lending pool configurator'\n  string public constant LP_INCONSISTENT_FLASHLOAN_PARAMS = '28';\n  string public constant CT_CALLER_MUST_BE_LENDING_POOL = '29'; // 'The caller of this function must be a lending pool'\n  string public constant CT_CANNOT_GIVE_ALLOWANCE_TO_HIMSELF = '30'; // 'User cannot give allowance to himself'\n  string public constant CT_TRANSFER_AMOUNT_NOT_GT_0 = '31'; // 'Transferred amount needs to be greater than zero'\n  string public constant RL_RESERVE_ALREADY_INITIALIZED = '32'; // 'Reserve has already been initialized'\n  string public constant LPC_RESERVE_LIQUIDITY_NOT_0 = '34'; // 'The liquidity of the reserve needs to be 0'\n  string public constant LPC_INVALID_ATOKEN_POOL_ADDRESS = '35'; // 'The liquidity of the reserve needs to be 0'\n  string public constant LPC_INVALID_STABLE_DEBT_TOKEN_POOL_ADDRESS = '36'; // 'The liquidity of the reserve needs to be 0'\n  string public constant LPC_INVALID_VARIABLE_DEBT_TOKEN_POOL_ADDRESS = '37'; // 'The liquidity of the reserve needs to be 0'\n  string public constant LPC_INVALID_STABLE_DEBT_TOKEN_UNDERLYING_ADDRESS = '38'; // 'The liquidity of the reserve needs to be 0'\n  string public constant LPC_INVALID_VARIABLE_DEBT_TOKEN_UNDERLYING_ADDRESS = '39'; // 'The liquidity of the reserve needs to be 0'\n  string public constant LPC_INVALID_ADDRESSES_PROVIDER_ID = '40'; // 'The liquidity of the reserve needs to be 0'\n  string public constant LPC_INVALID_CONFIGURATION = '75'; // 'Invalid risk parameters for the reserve'\n  string public constant LPC_CALLER_NOT_EMERGENCY_ADMIN = '76'; // 'The caller must be the emergency admin'\n  string public constant LPAPR_PROVIDER_NOT_REGISTERED = '41'; // 'Provider is not registered'\n  string public constant LPCM_HEALTH_FACTOR_NOT_BELOW_THRESHOLD = '42'; // 'Health factor is not below the threshold'\n  string public constant LPCM_COLLATERAL_CANNOT_BE_LIQUIDATED = '43'; // 'The collateral chosen cannot be liquidated'\n  string public constant LPCM_SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER = '44'; // 'User did not borrow the specified currency'\n  string public constant LPCM_NOT_ENOUGH_LIQUIDITY_TO_LIQUIDATE = '45'; // \"There isn't enough liquidity available to liquidate\"\n  string public constant LPCM_NO_ERRORS = '46'; // 'No errors'\n  string public constant LP_INVALID_FLASHLOAN_MODE = '47'; //Invalid flashloan mode selected\n  string public constant MATH_MULTIPLICATION_OVERFLOW = '48';\n  string public constant MATH_ADDITION_OVERFLOW = '49';\n  string public constant MATH_DIVISION_BY_ZERO = '50';\n  string public constant RL_LIQUIDITY_INDEX_OVERFLOW = '51'; //  Liquidity index overflows uint128\n  string public constant RL_VARIABLE_BORROW_INDEX_OVERFLOW = '52'; //  Variable borrow index overflows uint128\n  string public constant RL_LIQUIDITY_RATE_OVERFLOW = '53'; //  Liquidity rate overflows uint128\n  string public constant RL_VARIABLE_BORROW_RATE_OVERFLOW = '54'; //  Variable borrow rate overflows uint128\n  string public constant RL_STABLE_BORROW_RATE_OVERFLOW = '55'; //  Stable borrow rate overflows uint128\n  string public constant CT_INVALID_MINT_AMOUNT = '56'; //invalid amount to mint\n  string public constant LP_FAILED_REPAY_WITH_COLLATERAL = '57';\n  string public constant CT_INVALID_BURN_AMOUNT = '58'; //invalid amount to burn\n  string public constant LP_FAILED_COLLATERAL_SWAP = '60';\n  string public constant LP_INVALID_EQUAL_ASSETS_TO_SWAP = '61';\n  string public constant LP_REENTRANCY_NOT_ALLOWED = '62';\n  string public constant LP_CALLER_MUST_BE_AN_ATOKEN = '63';\n  string public constant LP_IS_PAUSED = '64'; // 'Pool is paused'\n  string public constant LP_NO_MORE_RESERVES_ALLOWED = '65';\n  string public constant LP_INVALID_FLASH_LOAN_EXECUTOR_RETURN = '66';\n  string public constant RC_INVALID_LTV = '67';\n  string public constant RC_INVALID_LIQ_THRESHOLD = '68';\n  string public constant RC_INVALID_LIQ_BONUS = '69';\n  string public constant RC_INVALID_DECIMALS = '70';\n  string public constant RC_INVALID_RESERVE_FACTOR = '71';\n  string public constant LPAPR_INVALID_ADDRESSES_PROVIDER_ID = '72';\n  string public constant VL_INCONSISTENT_FLASHLOAN_PARAMS = '73';\n  string public constant LP_INCONSISTENT_PARAMS_LENGTH = '74';\n  string public constant UL_INVALID_INDEX = '77';\n  string public constant LP_NOT_CONTRACT = '78';\n  string public constant SDT_STABLE_DEBT_OVERFLOW = '79';\n  string public constant SDT_BURN_EXCEEDS_BALANCE = '80';\n\n  enum CollateralManagerErrors {\n    NO_ERROR,\n    NO_COLLATERAL_AVAILABLE,\n    COLLATERAL_CANNOT_BE_LIQUIDATED,\n    CURRRENCY_NOT_BORROWED,\n    HEALTH_FACTOR_ABOVE_THRESHOLD,\n    NOT_ENOUGH_LIQUIDITY,\n    NO_ACTIVE_RESERVE,\n    HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD,\n    INVALID_EQUAL_ASSETS_TO_SWAP,\n    FROZEN_RESERVE\n  }\n}\n"
    },
    "contracts/protocol/libraries/helpers/Helpers.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\nimport {IERC20} from '../../../dependencies/openzeppelin/contracts/IERC20.sol';\nimport {DataTypes} from '../types/DataTypes.sol';\n\n/**\n * @title Helpers library\n * @author Aave\n */\nlibrary Helpers {\n  /**\n   * @dev Fetches the user current stable and variable debt balances\n   * @param user The user address\n   * @param reserve The reserve data object\n   * @return The stable and variable debt balance\n   **/\n  function getUserCurrentDebt(address user, DataTypes.ReserveData storage reserve)\n    internal\n    view\n    returns (uint256, uint256)\n  {\n    return (\n      IERC20(reserve.stableDebtTokenAddress).balanceOf(user),\n      IERC20(reserve.variableDebtTokenAddress).balanceOf(user)\n    );\n  }\n\n  function getUserCurrentDebtMemory(address user, DataTypes.ReserveData memory reserve)\n    internal\n    view\n    returns (uint256, uint256)\n  {\n    return (\n      IERC20(reserve.stableDebtTokenAddress).balanceOf(user),\n      IERC20(reserve.variableDebtTokenAddress).balanceOf(user)\n    );\n  }\n}\n"
    },
    "contracts/protocol/libraries/logic/GenericLogic.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from '../../../dependencies/openzeppelin/contracts/SafeMath.sol';\nimport {IERC20} from '../../../dependencies/openzeppelin/contracts/IERC20.sol';\nimport {ReserveLogic} from './ReserveLogic.sol';\nimport {ReserveConfiguration} from '../configuration/ReserveConfiguration.sol';\nimport {UserConfiguration} from '../configuration/UserConfiguration.sol';\nimport {WadRayMath} from '../math/WadRayMath.sol';\nimport {PercentageMath} from '../math/PercentageMath.sol';\nimport {IPriceOracleGetter} from '../../../interfaces/IPriceOracleGetter.sol';\nimport {DataTypes} from '../types/DataTypes.sol';\n\n/**\n * @title GenericLogic library\n * @author Aave\n * @title Implements protocol-level logic to calculate and validate the state of a user\n */\nlibrary GenericLogic {\n  using ReserveLogic for DataTypes.ReserveData;\n  using SafeMath for uint256;\n  using WadRayMath for uint256;\n  using PercentageMath for uint256;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using UserConfiguration for DataTypes.UserConfigurationMap;\n\n  uint256 public constant HEALTH_FACTOR_LIQUIDATION_THRESHOLD = 1 ether;\n\n  struct balanceDecreaseAllowedLocalVars {\n    uint256 decimals;\n    uint256 liquidationThreshold;\n    uint256 totalCollateralInETH;\n    uint256 totalDebtInETH;\n    uint256 avgLiquidationThreshold;\n    uint256 amountToDecreaseInETH;\n    uint256 collateralBalanceAfterDecrease;\n    uint256 liquidationThresholdAfterDecrease;\n    uint256 healthFactorAfterDecrease;\n    bool reserveUsageAsCollateralEnabled;\n  }\n\n  /**\n   * @dev Checks if a specific balance decrease is allowed\n   * (i.e. doesn't bring the user borrow position health factor under HEALTH_FACTOR_LIQUIDATION_THRESHOLD)\n   * @param asset The address of the underlying asset of the reserve\n   * @param user The address of the user\n   * @param amount The amount to decrease\n   * @param reservesData The data of all the reserves\n   * @param userConfig The user configuration\n   * @param reserves The list of all the active reserves\n   * @param oracle The address of the oracle contract\n   * @return true if the decrease of the balance is allowed\n   **/\n  function balanceDecreaseAllowed(\n    address asset,\n    address user,\n    uint256 amount,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    DataTypes.UserConfigurationMap calldata userConfig,\n    mapping(uint256 => address) storage reserves,\n    uint256 reservesCount,\n    address oracle\n  ) external view returns (bool) {\n    if (!userConfig.isBorrowingAny() || !userConfig.isUsingAsCollateral(reservesData[asset].id)) {\n      return true;\n    }\n\n    balanceDecreaseAllowedLocalVars memory vars;\n\n    (, vars.liquidationThreshold, , vars.decimals, ) = reservesData[asset]\n      .configuration\n      .getParams();\n\n    if (vars.liquidationThreshold == 0) {\n      return true;\n    }\n\n    (\n      vars.totalCollateralInETH,\n      vars.totalDebtInETH,\n      ,\n      vars.avgLiquidationThreshold,\n\n    ) = calculateUserAccountData(user, reservesData, userConfig, reserves, reservesCount, oracle);\n\n    if (vars.totalDebtInETH == 0) {\n      return true;\n    }\n\n    vars.amountToDecreaseInETH = IPriceOracleGetter(oracle).getAssetPrice(asset).mul(amount).div(\n      10**vars.decimals\n    );\n\n    vars.collateralBalanceAfterDecrease = vars.totalCollateralInETH.sub(vars.amountToDecreaseInETH);\n\n    //if there is a borrow, there can't be 0 collateral\n    if (vars.collateralBalanceAfterDecrease == 0) {\n      return false;\n    }\n\n    vars.liquidationThresholdAfterDecrease = vars\n      .totalCollateralInETH\n      .mul(vars.avgLiquidationThreshold)\n      .sub(vars.amountToDecreaseInETH.mul(vars.liquidationThreshold))\n      .div(vars.collateralBalanceAfterDecrease);\n\n    uint256 healthFactorAfterDecrease =\n      calculateHealthFactorFromBalances(\n        vars.collateralBalanceAfterDecrease,\n        vars.totalDebtInETH,\n        vars.liquidationThresholdAfterDecrease\n      );\n\n    return healthFactorAfterDecrease >= GenericLogic.HEALTH_FACTOR_LIQUIDATION_THRESHOLD;\n  }\n\n  struct CalculateUserAccountDataVars {\n    uint256 reserveUnitPrice;\n    uint256 tokenUnit;\n    uint256 compoundedLiquidityBalance;\n    uint256 compoundedBorrowBalance;\n    uint256 decimals;\n    uint256 ltv;\n    uint256 liquidationThreshold;\n    uint256 i;\n    uint256 healthFactor;\n    uint256 totalCollateralInETH;\n    uint256 totalDebtInETH;\n    uint256 avgLtv;\n    uint256 avgLiquidationThreshold;\n    uint256 reservesLength;\n    bool healthFactorBelowThreshold;\n    address currentReserveAddress;\n    bool usageAsCollateralEnabled;\n    bool userUsesReserveAsCollateral;\n  }\n\n  /**\n   * @dev Calculates the user data across the reserves.\n   * this includes the total liquidity/collateral/borrow balances in ETH,\n   * the average Loan To Value, the average Liquidation Ratio, and the Health factor.\n   * @param user The address of the user\n   * @param reservesData Data of all the reserves\n   * @param userConfig The configuration of the user\n   * @param reserves The list of the available reserves\n   * @param oracle The price oracle address\n   * @return The total collateral and total debt of the user in ETH, the avg ltv, liquidation threshold and the HF\n   **/\n  function calculateUserAccountData(\n    address user,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    DataTypes.UserConfigurationMap memory userConfig,\n    mapping(uint256 => address) storage reserves,\n    uint256 reservesCount,\n    address oracle\n  )\n    internal\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    CalculateUserAccountDataVars memory vars;\n\n    if (userConfig.isEmpty()) {\n      return (0, 0, 0, 0, uint256(-1));\n    }\n    for (vars.i = 0; vars.i < reservesCount; vars.i++) {\n      if (!userConfig.isUsingAsCollateralOrBorrowing(vars.i)) {\n        continue;\n      }\n\n      vars.currentReserveAddress = reserves[vars.i];\n      DataTypes.ReserveData storage currentReserve = reservesData[vars.currentReserveAddress];\n\n      (vars.ltv, vars.liquidationThreshold, , vars.decimals, ) = currentReserve\n        .configuration\n        .getParams();\n\n      vars.tokenUnit = 10**vars.decimals;\n      vars.reserveUnitPrice = IPriceOracleGetter(oracle).getAssetPrice(vars.currentReserveAddress);\n\n      if (vars.liquidationThreshold != 0 && userConfig.isUsingAsCollateral(vars.i)) {\n        vars.compoundedLiquidityBalance = IERC20(currentReserve.aTokenAddress).balanceOf(user);\n\n        uint256 liquidityBalanceETH =\n          vars.reserveUnitPrice.mul(vars.compoundedLiquidityBalance).div(vars.tokenUnit);\n\n        vars.totalCollateralInETH = vars.totalCollateralInETH.add(liquidityBalanceETH);\n\n        vars.avgLtv = vars.avgLtv.add(liquidityBalanceETH.mul(vars.ltv));\n        vars.avgLiquidationThreshold = vars.avgLiquidationThreshold.add(\n          liquidityBalanceETH.mul(vars.liquidationThreshold)\n        );\n      }\n\n      if (userConfig.isBorrowing(vars.i)) {\n        vars.compoundedBorrowBalance = IERC20(currentReserve.stableDebtTokenAddress).balanceOf(\n          user\n        );\n        vars.compoundedBorrowBalance = vars.compoundedBorrowBalance.add(\n          IERC20(currentReserve.variableDebtTokenAddress).balanceOf(user)\n        );\n\n        vars.totalDebtInETH = vars.totalDebtInETH.add(\n          vars.reserveUnitPrice.mul(vars.compoundedBorrowBalance).div(vars.tokenUnit)\n        );\n      }\n    }\n\n    vars.avgLtv = vars.totalCollateralInETH > 0 ? vars.avgLtv.div(vars.totalCollateralInETH) : 0;\n    vars.avgLiquidationThreshold = vars.totalCollateralInETH > 0\n      ? vars.avgLiquidationThreshold.div(vars.totalCollateralInETH)\n      : 0;\n\n    vars.healthFactor = calculateHealthFactorFromBalances(\n      vars.totalCollateralInETH,\n      vars.totalDebtInETH,\n      vars.avgLiquidationThreshold\n    );\n    return (\n      vars.totalCollateralInETH,\n      vars.totalDebtInETH,\n      vars.avgLtv,\n      vars.avgLiquidationThreshold,\n      vars.healthFactor\n    );\n  }\n\n  /**\n   * @dev Calculates the health factor from the corresponding balances\n   * @param totalCollateralInETH The total collateral in ETH\n   * @param totalDebtInETH The total debt in ETH\n   * @param liquidationThreshold The avg liquidation threshold\n   * @return The health factor calculated from the balances provided\n   **/\n  function calculateHealthFactorFromBalances(\n    uint256 totalCollateralInETH,\n    uint256 totalDebtInETH,\n    uint256 liquidationThreshold\n  ) internal pure returns (uint256) {\n    if (totalDebtInETH == 0) return uint256(-1);\n\n    return (totalCollateralInETH.percentMul(liquidationThreshold)).wadDiv(totalDebtInETH);\n  }\n\n  /**\n   * @dev Calculates the equivalent amount in ETH that an user can borrow, depending on the available collateral and the\n   * average Loan To Value\n   * @param totalCollateralInETH The total collateral in ETH\n   * @param totalDebtInETH The total borrow balance\n   * @param ltv The average loan to value\n   * @return the amount available to borrow in ETH for the user\n   **/\n\n  function calculateAvailableBorrowsETH(\n    uint256 totalCollateralInETH,\n    uint256 totalDebtInETH,\n    uint256 ltv\n  ) internal pure returns (uint256) {\n    uint256 availableBorrowsETH = totalCollateralInETH.percentMul(ltv);\n\n    if (availableBorrowsETH < totalDebtInETH) {\n      return 0;\n    }\n\n    availableBorrowsETH = availableBorrowsETH.sub(totalDebtInETH);\n    return availableBorrowsETH;\n  }\n}\n"
    },
    "contracts/protocol/libraries/logic/ReserveLogic.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\nimport {SafeMath} from '../../../dependencies/openzeppelin/contracts/SafeMath.sol';\nimport {IERC20} from '../../../dependencies/openzeppelin/contracts/IERC20.sol';\nimport {SafeERC20} from '../../../dependencies/openzeppelin/contracts/SafeERC20.sol';\nimport {IAToken} from '../../../interfaces/IAToken.sol';\nimport {IStableDebtToken} from '../../../interfaces/IStableDebtToken.sol';\nimport {IVariableDebtToken} from '../../../interfaces/IVariableDebtToken.sol';\nimport {IReserveInterestRateStrategy} from '../../../interfaces/IReserveInterestRateStrategy.sol';\nimport {ReserveConfiguration} from '../configuration/ReserveConfiguration.sol';\nimport {MathUtils} from '../math/MathUtils.sol';\nimport {WadRayMath} from '../math/WadRayMath.sol';\nimport {PercentageMath} from '../math/PercentageMath.sol';\nimport {Errors} from '../helpers/Errors.sol';\nimport {DataTypes} from '../types/DataTypes.sol';\n\n/**\n * @title ReserveLogic library\n * @author Aave\n * @notice Implements the logic to update the reserves state\n */\nlibrary ReserveLogic {\n  using SafeMath for uint256;\n  using WadRayMath for uint256;\n  using PercentageMath for uint256;\n  using SafeERC20 for IERC20;\n\n  /**\n   * @dev Emitted when the state of a reserve is updated\n   * @param asset The address of the underlying asset of the reserve\n   * @param liquidityRate The new liquidity rate\n   * @param stableBorrowRate The new stable borrow rate\n   * @param variableBorrowRate The new variable borrow rate\n   * @param liquidityIndex The new liquidity index\n   * @param variableBorrowIndex The new variable borrow index\n   **/\n  event ReserveDataUpdated(\n    address indexed asset,\n    uint256 liquidityRate,\n    uint256 stableBorrowRate,\n    uint256 variableBorrowRate,\n    uint256 liquidityIndex,\n    uint256 variableBorrowIndex\n  );\n\n  using ReserveLogic for DataTypes.ReserveData;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n\n  /**\n   * @dev Returns the ongoing normalized income for the reserve\n   * A value of 1e27 means there is no income. As time passes, the income is accrued\n   * A value of 2*1e27 means for each unit of asset one unit of income has been accrued\n   * @param reserve The reserve object\n   * @return the normalized income. expressed in ray\n   **/\n  function getNormalizedIncome(DataTypes.ReserveData storage reserve)\n    internal\n    view\n    returns (uint256)\n  {\n    uint40 timestamp = reserve.lastUpdateTimestamp;\n\n    //solium-disable-next-line\n    if (timestamp == uint40(block.timestamp)) {\n      //if the index was updated in the same block, no need to perform any calculation\n      return reserve.liquidityIndex;\n    }\n\n    uint256 cumulated =\n      MathUtils.calculateLinearInterest(reserve.currentLiquidityRate, timestamp).rayMul(\n        reserve.liquidityIndex\n      );\n\n    return cumulated;\n  }\n\n  /**\n   * @dev Returns the ongoing normalized variable debt for the reserve\n   * A value of 1e27 means there is no debt. As time passes, the income is accrued\n   * A value of 2*1e27 means that for each unit of debt, one unit worth of interest has been accumulated\n   * @param reserve The reserve object\n   * @return The normalized variable debt. expressed in ray\n   **/\n  function getNormalizedDebt(DataTypes.ReserveData storage reserve)\n    internal\n    view\n    returns (uint256)\n  {\n    uint40 timestamp = reserve.lastUpdateTimestamp;\n\n    //solium-disable-next-line\n    if (timestamp == uint40(block.timestamp)) {\n      //if the index was updated in the same block, no need to perform any calculation\n      return reserve.variableBorrowIndex;\n    }\n\n    uint256 cumulated =\n      MathUtils.calculateCompoundedInterest(reserve.currentVariableBorrowRate, timestamp).rayMul(\n        reserve.variableBorrowIndex\n      );\n\n    return cumulated;\n  }\n\n  /**\n   * @dev Updates the liquidity cumulative index and the variable borrow index.\n   * @param reserve the reserve object\n   **/\n  function updateState(DataTypes.ReserveData storage reserve) internal {\n    uint256 scaledVariableDebt =\n      IVariableDebtToken(reserve.variableDebtTokenAddress).scaledTotalSupply();\n    uint256 previousVariableBorrowIndex = reserve.variableBorrowIndex;\n    uint256 previousLiquidityIndex = reserve.liquidityIndex;\n    uint40 lastUpdatedTimestamp = reserve.lastUpdateTimestamp;\n\n    (uint256 newLiquidityIndex, uint256 newVariableBorrowIndex) =\n      _updateIndexes(\n        reserve,\n        scaledVariableDebt,\n        previousLiquidityIndex,\n        previousVariableBorrowIndex,\n        lastUpdatedTimestamp\n      );\n\n    _mintToTreasury(\n      reserve,\n      scaledVariableDebt,\n      previousVariableBorrowIndex,\n      newLiquidityIndex,\n      newVariableBorrowIndex,\n      lastUpdatedTimestamp\n    );\n  }\n\n  /**\n   * @dev Accumulates a predefined amount of asset to the reserve as a fixed, instantaneous income. Used for example to accumulate\n   * the flashloan fee to the reserve, and spread it between all the depositors\n   * @param reserve The reserve object\n   * @param totalLiquidity The total liquidity available in the reserve\n   * @param amount The amount to accomulate\n   **/\n  function cumulateToLiquidityIndex(\n    DataTypes.ReserveData storage reserve,\n    uint256 totalLiquidity,\n    uint256 amount\n  ) internal {\n    uint256 amountToLiquidityRatio = amount.wadToRay().rayDiv(totalLiquidity.wadToRay());\n\n    uint256 result = amountToLiquidityRatio.add(WadRayMath.ray());\n\n    result = result.rayMul(reserve.liquidityIndex);\n    require(result <= type(uint128).max, Errors.RL_LIQUIDITY_INDEX_OVERFLOW);\n\n    reserve.liquidityIndex = uint128(result);\n  }\n\n  /**\n   * @dev Initializes a reserve\n   * @param reserve The reserve object\n   * @param aTokenAddress The address of the overlying atoken contract\n   * @param interestRateStrategyAddress The address of the interest rate strategy contract\n   **/\n  function init(\n    DataTypes.ReserveData storage reserve,\n    address aTokenAddress,\n    address stableDebtTokenAddress,\n    address variableDebtTokenAddress,\n    address interestRateStrategyAddress\n  ) external {\n    require(reserve.aTokenAddress == address(0), Errors.RL_RESERVE_ALREADY_INITIALIZED);\n\n    reserve.liquidityIndex = uint128(WadRayMath.ray());\n    reserve.variableBorrowIndex = uint128(WadRayMath.ray());\n    reserve.aTokenAddress = aTokenAddress;\n    reserve.stableDebtTokenAddress = stableDebtTokenAddress;\n    reserve.variableDebtTokenAddress = variableDebtTokenAddress;\n    reserve.interestRateStrategyAddress = interestRateStrategyAddress;\n  }\n\n  struct UpdateInterestRatesLocalVars {\n    address stableDebtTokenAddress;\n    uint256 availableLiquidity;\n    uint256 totalStableDebt;\n    uint256 newLiquidityRate;\n    uint256 newStableRate;\n    uint256 newVariableRate;\n    uint256 avgStableRate;\n    uint256 totalVariableDebt;\n  }\n\n  /**\n   * @dev Updates the reserve current stable borrow rate, the current variable borrow rate and the current liquidity rate\n   * @param reserve The address of the reserve to be updated\n   * @param liquidityAdded The amount of liquidity added to the protocol (deposit or repay) in the previous action\n   * @param liquidityTaken The amount of liquidity taken from the protocol (redeem or borrow)\n   **/\n  function updateInterestRates(\n    DataTypes.ReserveData storage reserve,\n    address reserveAddress,\n    address aTokenAddress,\n    uint256 liquidityAdded,\n    uint256 liquidityTaken\n  ) internal {\n    UpdateInterestRatesLocalVars memory vars;\n\n    vars.stableDebtTokenAddress = reserve.stableDebtTokenAddress;\n\n    (vars.totalStableDebt, vars.avgStableRate) = IStableDebtToken(vars.stableDebtTokenAddress)\n      .getTotalSupplyAndAvgRate();\n\n    //calculates the total variable debt locally using the scaled total supply instead\n    //of totalSupply(), as it's noticeably cheaper. Also, the index has been\n    //updated by the previous updateState() call\n    vars.totalVariableDebt = IVariableDebtToken(reserve.variableDebtTokenAddress)\n      .scaledTotalSupply()\n      .rayMul(reserve.variableBorrowIndex);\n\n    (\n      vars.newLiquidityRate,\n      vars.newStableRate,\n      vars.newVariableRate\n    ) = IReserveInterestRateStrategy(reserve.interestRateStrategyAddress).calculateInterestRates(\n      reserveAddress,\n      aTokenAddress,\n      liquidityAdded,\n      liquidityTaken,\n      vars.totalStableDebt,\n      vars.totalVariableDebt,\n      vars.avgStableRate,\n      reserve.configuration.getReserveFactor()\n    );\n    require(vars.newLiquidityRate <= type(uint128).max, Errors.RL_LIQUIDITY_RATE_OVERFLOW);\n    require(vars.newStableRate <= type(uint128).max, Errors.RL_STABLE_BORROW_RATE_OVERFLOW);\n    require(vars.newVariableRate <= type(uint128).max, Errors.RL_VARIABLE_BORROW_RATE_OVERFLOW);\n\n    reserve.currentLiquidityRate = uint128(vars.newLiquidityRate);\n    reserve.currentStableBorrowRate = uint128(vars.newStableRate);\n    reserve.currentVariableBorrowRate = uint128(vars.newVariableRate);\n\n    emit ReserveDataUpdated(\n      reserveAddress,\n      vars.newLiquidityRate,\n      vars.newStableRate,\n      vars.newVariableRate,\n      reserve.liquidityIndex,\n      reserve.variableBorrowIndex\n    );\n  }\n\n  struct MintToTreasuryLocalVars {\n    uint256 currentStableDebt;\n    uint256 principalStableDebt;\n    uint256 previousStableDebt;\n    uint256 currentVariableDebt;\n    uint256 previousVariableDebt;\n    uint256 avgStableRate;\n    uint256 cumulatedStableInterest;\n    uint256 totalDebtAccrued;\n    uint256 amountToMint;\n    uint256 reserveFactor;\n    uint40 stableSupplyUpdatedTimestamp;\n  }\n\n  /**\n   * @dev Mints part of the repaid interest to the reserve treasury as a function of the reserveFactor for the\n   * specific asset.\n   * @param reserve The reserve reserve to be updated\n   * @param scaledVariableDebt The current scaled total variable debt\n   * @param previousVariableBorrowIndex The variable borrow index before the last accumulation of the interest\n   * @param newLiquidityIndex The new liquidity index\n   * @param newVariableBorrowIndex The variable borrow index after the last accumulation of the interest\n   **/\n  function _mintToTreasury(\n    DataTypes.ReserveData storage reserve,\n    uint256 scaledVariableDebt,\n    uint256 previousVariableBorrowIndex,\n    uint256 newLiquidityIndex,\n    uint256 newVariableBorrowIndex,\n    uint40 timestamp\n  ) internal {\n    MintToTreasuryLocalVars memory vars;\n\n    vars.reserveFactor = reserve.configuration.getReserveFactor();\n\n    if (vars.reserveFactor == 0) {\n      return;\n    }\n\n    //fetching the principal, total stable debt and the avg stable rate\n    (\n      vars.principalStableDebt,\n      vars.currentStableDebt,\n      vars.avgStableRate,\n      vars.stableSupplyUpdatedTimestamp\n    ) = IStableDebtToken(reserve.stableDebtTokenAddress).getSupplyData();\n\n    //calculate the last principal variable debt\n    vars.previousVariableDebt = scaledVariableDebt.rayMul(previousVariableBorrowIndex);\n\n    //calculate the new total supply after accumulation of the index\n    vars.currentVariableDebt = scaledVariableDebt.rayMul(newVariableBorrowIndex);\n\n    //calculate the stable debt until the last timestamp update\n    vars.cumulatedStableInterest = MathUtils.calculateCompoundedInterest(\n      vars.avgStableRate,\n      vars.stableSupplyUpdatedTimestamp,\n      timestamp\n    );\n\n    vars.previousStableDebt = vars.principalStableDebt.rayMul(vars.cumulatedStableInterest);\n\n    //debt accrued is the sum of the current debt minus the sum of the debt at the last update\n    vars.totalDebtAccrued = vars\n      .currentVariableDebt\n      .add(vars.currentStableDebt)\n      .sub(vars.previousVariableDebt)\n      .sub(vars.previousStableDebt);\n\n    vars.amountToMint = vars.totalDebtAccrued.percentMul(vars.reserveFactor);\n\n    if (vars.amountToMint != 0) {\n      IAToken(reserve.aTokenAddress).mintToTreasury(vars.amountToMint, newLiquidityIndex);\n    }\n  }\n\n  /**\n   * @dev Updates the reserve indexes and the timestamp of the update\n   * @param reserve The reserve reserve to be updated\n   * @param scaledVariableDebt The scaled variable debt\n   * @param liquidityIndex The last stored liquidity index\n   * @param variableBorrowIndex The last stored variable borrow index\n   **/\n  function _updateIndexes(\n    DataTypes.ReserveData storage reserve,\n    uint256 scaledVariableDebt,\n    uint256 liquidityIndex,\n    uint256 variableBorrowIndex,\n    uint40 timestamp\n  ) internal returns (uint256, uint256) {\n    uint256 currentLiquidityRate = reserve.currentLiquidityRate;\n\n    uint256 newLiquidityIndex = liquidityIndex;\n    uint256 newVariableBorrowIndex = variableBorrowIndex;\n\n    //only cumulating if there is any income being produced\n    if (currentLiquidityRate > 0) {\n      uint256 cumulatedLiquidityInterest =\n        MathUtils.calculateLinearInterest(currentLiquidityRate, timestamp);\n      newLiquidityIndex = cumulatedLiquidityInterest.rayMul(liquidityIndex);\n      require(newLiquidityIndex <= type(uint128).max, Errors.RL_LIQUIDITY_INDEX_OVERFLOW);\n\n      reserve.liquidityIndex = uint128(newLiquidityIndex);\n\n      //as the liquidity rate might come only from stable rate loans, we need to ensure\n      //that there is actual variable debt before accumulating\n      if (scaledVariableDebt != 0) {\n        uint256 cumulatedVariableBorrowInterest =\n          MathUtils.calculateCompoundedInterest(reserve.currentVariableBorrowRate, timestamp);\n        newVariableBorrowIndex = cumulatedVariableBorrowInterest.rayMul(variableBorrowIndex);\n        require(\n          newVariableBorrowIndex <= type(uint128).max,\n          Errors.RL_VARIABLE_BORROW_INDEX_OVERFLOW\n        );\n        reserve.variableBorrowIndex = uint128(newVariableBorrowIndex);\n      }\n    }\n\n    //solium-disable-next-line\n    reserve.lastUpdateTimestamp = uint40(block.timestamp);\n    return (newLiquidityIndex, newVariableBorrowIndex);\n  }\n}\n"
    },
    "contracts/protocol/libraries/logic/ValidationLogic.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from '../../../dependencies/openzeppelin/contracts/SafeMath.sol';\nimport {IERC20} from '../../../dependencies/openzeppelin/contracts/IERC20.sol';\nimport {ReserveLogic} from './ReserveLogic.sol';\nimport {GenericLogic} from './GenericLogic.sol';\nimport {WadRayMath} from '../math/WadRayMath.sol';\nimport {PercentageMath} from '../math/PercentageMath.sol';\nimport {SafeERC20} from '../../../dependencies/openzeppelin/contracts/SafeERC20.sol';\nimport {ReserveConfiguration} from '../configuration/ReserveConfiguration.sol';\nimport {UserConfiguration} from '../configuration/UserConfiguration.sol';\nimport {Errors} from '../helpers/Errors.sol';\nimport {Helpers} from '../helpers/Helpers.sol';\nimport {IReserveInterestRateStrategy} from '../../../interfaces/IReserveInterestRateStrategy.sol';\nimport {DataTypes} from '../types/DataTypes.sol';\n\n/**\n * @title ReserveLogic library\n * @author Aave\n * @notice Implements functions to validate the different actions of the protocol\n */\nlibrary ValidationLogic {\n  using ReserveLogic for DataTypes.ReserveData;\n  using SafeMath for uint256;\n  using WadRayMath for uint256;\n  using PercentageMath for uint256;\n  using SafeERC20 for IERC20;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using UserConfiguration for DataTypes.UserConfigurationMap;\n\n  uint256 public constant REBALANCE_UP_LIQUIDITY_RATE_THRESHOLD = 4000;\n  uint256 public constant REBALANCE_UP_USAGE_RATIO_THRESHOLD = 0.95 * 1e27; //usage ratio of 95%\n\n  /**\n   * @dev Validates a deposit action\n   * @param reserve The reserve object on which the user is depositing\n   * @param amount The amount to be deposited\n   */\n  function validateDeposit(DataTypes.ReserveData storage reserve, uint256 amount) external view {\n    (bool isActive, bool isFrozen, , ) = reserve.configuration.getFlags();\n\n    require(amount != 0, Errors.VL_INVALID_AMOUNT);\n    require(isActive, Errors.VL_NO_ACTIVE_RESERVE);\n    require(!isFrozen, Errors.VL_RESERVE_FROZEN);\n  }\n\n  /**\n   * @dev Validates a withdraw action\n   * @param reserveAddress The address of the reserve\n   * @param amount The amount to be withdrawn\n   * @param userBalance The balance of the user\n   * @param reservesData The reserves state\n   * @param userConfig The user configuration\n   * @param reserves The addresses of the reserves\n   * @param reservesCount The number of reserves\n   * @param oracle The price oracle\n   */\n  function validateWithdraw(\n    address reserveAddress,\n    uint256 amount,\n    uint256 userBalance,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    DataTypes.UserConfigurationMap storage userConfig,\n    mapping(uint256 => address) storage reserves,\n    uint256 reservesCount,\n    address oracle\n  ) external view {\n    require(amount != 0, Errors.VL_INVALID_AMOUNT);\n    require(amount <= userBalance, Errors.VL_NOT_ENOUGH_AVAILABLE_USER_BALANCE);\n\n    (bool isActive, , , ) = reservesData[reserveAddress].configuration.getFlags();\n    require(isActive, Errors.VL_NO_ACTIVE_RESERVE);\n\n    require(\n      GenericLogic.balanceDecreaseAllowed(\n        reserveAddress,\n        msg.sender,\n        amount,\n        reservesData,\n        userConfig,\n        reserves,\n        reservesCount,\n        oracle\n      ),\n      Errors.VL_TRANSFER_NOT_ALLOWED\n    );\n  }\n\n  struct ValidateBorrowLocalVars {\n    uint256 currentLtv;\n    uint256 currentLiquidationThreshold;\n    uint256 amountOfCollateralNeededETH;\n    uint256 userCollateralBalanceETH;\n    uint256 userBorrowBalanceETH;\n    uint256 availableLiquidity;\n    uint256 healthFactor;\n    bool isActive;\n    bool isFrozen;\n    bool borrowingEnabled;\n    bool stableRateBorrowingEnabled;\n  }\n\n  /**\n   * @dev Validates a borrow action\n   * @param asset The address of the asset to borrow\n   * @param reserve The reserve state from which the user is borrowing\n   * @param userAddress The address of the user\n   * @param amount The amount to be borrowed\n   * @param amountInETH The amount to be borrowed, in ETH\n   * @param interestRateMode The interest rate mode at which the user is borrowing\n   * @param maxStableLoanPercent The max amount of the liquidity that can be borrowed at stable rate, in percentage\n   * @param reservesData The state of all the reserves\n   * @param userConfig The state of the user for the specific reserve\n   * @param reserves The addresses of all the active reserves\n   * @param oracle The price oracle\n   */\n\n  function validateBorrow(\n    address asset,\n    DataTypes.ReserveData storage reserve,\n    address userAddress,\n    uint256 amount,\n    uint256 amountInETH,\n    uint256 interestRateMode,\n    uint256 maxStableLoanPercent,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    DataTypes.UserConfigurationMap storage userConfig,\n    mapping(uint256 => address) storage reserves,\n    uint256 reservesCount,\n    address oracle\n  ) external view {\n    ValidateBorrowLocalVars memory vars;\n\n    (vars.isActive, vars.isFrozen, vars.borrowingEnabled, vars.stableRateBorrowingEnabled) = reserve\n      .configuration\n      .getFlags();\n\n    require(vars.isActive, Errors.VL_NO_ACTIVE_RESERVE);\n    require(!vars.isFrozen, Errors.VL_RESERVE_FROZEN);\n    require(amount != 0, Errors.VL_INVALID_AMOUNT);\n\n    require(vars.borrowingEnabled, Errors.VL_BORROWING_NOT_ENABLED);\n\n    //validate interest rate mode\n    require(\n      uint256(DataTypes.InterestRateMode.VARIABLE) == interestRateMode ||\n        uint256(DataTypes.InterestRateMode.STABLE) == interestRateMode,\n      Errors.VL_INVALID_INTEREST_RATE_MODE_SELECTED\n    );\n\n    (\n      vars.userCollateralBalanceETH,\n      vars.userBorrowBalanceETH,\n      vars.currentLtv,\n      vars.currentLiquidationThreshold,\n      vars.healthFactor\n    ) = GenericLogic.calculateUserAccountData(\n      userAddress,\n      reservesData,\n      userConfig,\n      reserves,\n      reservesCount,\n      oracle\n    );\n\n    require(vars.userCollateralBalanceETH > 0, Errors.VL_COLLATERAL_BALANCE_IS_0);\n\n    require(\n      vars.healthFactor > GenericLogic.HEALTH_FACTOR_LIQUIDATION_THRESHOLD,\n      Errors.VL_HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD\n    );\n\n    //add the current already borrowed amount to the amount requested to calculate the total collateral needed.\n    vars.amountOfCollateralNeededETH = vars.userBorrowBalanceETH.add(amountInETH).percentDiv(\n      vars.currentLtv\n    ); //LTV is calculated in percentage\n\n    require(\n      vars.amountOfCollateralNeededETH <= vars.userCollateralBalanceETH,\n      Errors.VL_COLLATERAL_CANNOT_COVER_NEW_BORROW\n    );\n\n    /**\n     * Following conditions need to be met if the user is borrowing at a stable rate:\n     * 1. Reserve must be enabled for stable rate borrowing\n     * 2. Users cannot borrow from the reserve if their collateral is (mostly) the same currency\n     *    they are borrowing, to prevent abuses.\n     * 3. Users will be able to borrow only a portion of the total available liquidity\n     **/\n\n    if (interestRateMode == uint256(DataTypes.InterestRateMode.STABLE)) {\n      //check if the borrow mode is stable and if stable rate borrowing is enabled on this reserve\n\n      require(vars.stableRateBorrowingEnabled, Errors.VL_STABLE_BORROWING_NOT_ENABLED);\n\n      require(\n        !userConfig.isUsingAsCollateral(reserve.id) ||\n          reserve.configuration.getLtv() == 0 ||\n          amount > IERC20(reserve.aTokenAddress).balanceOf(userAddress),\n        Errors.VL_COLLATERAL_SAME_AS_BORROWING_CURRENCY\n      );\n\n      vars.availableLiquidity = IERC20(asset).balanceOf(reserve.aTokenAddress);\n\n      //calculate the max available loan size in stable rate mode as a percentage of the\n      //available liquidity\n      uint256 maxLoanSizeStable = vars.availableLiquidity.percentMul(maxStableLoanPercent);\n\n      require(amount <= maxLoanSizeStable, Errors.VL_AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE);\n    }\n  }\n\n  /**\n   * @dev Validates a repay action\n   * @param reserve The reserve state from which the user is repaying\n   * @param amountSent The amount sent for the repayment. Can be an actual value or uint(-1)\n   * @param onBehalfOf The address of the user msg.sender is repaying for\n   * @param stableDebt The borrow balance of the user\n   * @param variableDebt The borrow balance of the user\n   */\n  function validateRepay(\n    DataTypes.ReserveData storage reserve,\n    uint256 amountSent,\n    DataTypes.InterestRateMode rateMode,\n    address onBehalfOf,\n    uint256 stableDebt,\n    uint256 variableDebt\n  ) external view {\n    bool isActive = reserve.configuration.getActive();\n\n    require(isActive, Errors.VL_NO_ACTIVE_RESERVE);\n\n    require(amountSent > 0, Errors.VL_INVALID_AMOUNT);\n\n    require(\n      (stableDebt > 0 &&\n        DataTypes.InterestRateMode(rateMode) == DataTypes.InterestRateMode.STABLE) ||\n        (variableDebt > 0 &&\n          DataTypes.InterestRateMode(rateMode) == DataTypes.InterestRateMode.VARIABLE),\n      Errors.VL_NO_DEBT_OF_SELECTED_TYPE\n    );\n\n    require(\n      amountSent != uint256(-1) || msg.sender == onBehalfOf,\n      Errors.VL_NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF\n    );\n  }\n\n  /**\n   * @dev Validates a swap of borrow rate mode.\n   * @param reserve The reserve state on which the user is swapping the rate\n   * @param userConfig The user reserves configuration\n   * @param stableDebt The stable debt of the user\n   * @param variableDebt The variable debt of the user\n   * @param currentRateMode The rate mode of the borrow\n   */\n  function validateSwapRateMode(\n    DataTypes.ReserveData storage reserve,\n    DataTypes.UserConfigurationMap storage userConfig,\n    uint256 stableDebt,\n    uint256 variableDebt,\n    DataTypes.InterestRateMode currentRateMode\n  ) external view {\n    (bool isActive, bool isFrozen, , bool stableRateEnabled) = reserve.configuration.getFlags();\n\n    require(isActive, Errors.VL_NO_ACTIVE_RESERVE);\n    require(!isFrozen, Errors.VL_RESERVE_FROZEN);\n\n    if (currentRateMode == DataTypes.InterestRateMode.STABLE) {\n      require(stableDebt > 0, Errors.VL_NO_STABLE_RATE_LOAN_IN_RESERVE);\n    } else if (currentRateMode == DataTypes.InterestRateMode.VARIABLE) {\n      require(variableDebt > 0, Errors.VL_NO_VARIABLE_RATE_LOAN_IN_RESERVE);\n      /**\n       * user wants to swap to stable, before swapping we need to ensure that\n       * 1. stable borrow rate is enabled on the reserve\n       * 2. user is not trying to abuse the reserve by depositing\n       * more collateral than he is borrowing, artificially lowering\n       * the interest rate, borrowing at variable, and switching to stable\n       **/\n      require(stableRateEnabled, Errors.VL_STABLE_BORROWING_NOT_ENABLED);\n\n      require(\n        !userConfig.isUsingAsCollateral(reserve.id) ||\n          reserve.configuration.getLtv() == 0 ||\n          stableDebt.add(variableDebt) > IERC20(reserve.aTokenAddress).balanceOf(msg.sender),\n        Errors.VL_COLLATERAL_SAME_AS_BORROWING_CURRENCY\n      );\n    } else {\n      revert(Errors.VL_INVALID_INTEREST_RATE_MODE_SELECTED);\n    }\n  }\n\n  /**\n   * @dev Validates a stable borrow rate rebalance action\n   * @param reserve The reserve state on which the user is getting rebalanced\n   * @param reserveAddress The address of the reserve\n   * @param stableDebtToken The stable debt token instance\n   * @param variableDebtToken The variable debt token instance\n   * @param aTokenAddress The address of the aToken contract\n   */\n  function validateRebalanceStableBorrowRate(\n    DataTypes.ReserveData storage reserve,\n    address reserveAddress,\n    IERC20 stableDebtToken,\n    IERC20 variableDebtToken,\n    address aTokenAddress\n  ) external view {\n    (bool isActive, , , ) = reserve.configuration.getFlags();\n\n    require(isActive, Errors.VL_NO_ACTIVE_RESERVE);\n\n    //if the usage ratio is below 95%, no rebalances are needed\n    uint256 totalDebt =\n      stableDebtToken.totalSupply().add(variableDebtToken.totalSupply()).wadToRay();\n    uint256 availableLiquidity = IERC20(reserveAddress).balanceOf(aTokenAddress).wadToRay();\n    uint256 usageRatio = totalDebt == 0 ? 0 : totalDebt.rayDiv(availableLiquidity.add(totalDebt));\n\n    //if the liquidity rate is below REBALANCE_UP_THRESHOLD of the max variable APR at 95% usage,\n    //then we allow rebalancing of the stable rate positions.\n\n    uint256 currentLiquidityRate = reserve.currentLiquidityRate;\n    uint256 maxVariableBorrowRate =\n      IReserveInterestRateStrategy(reserve.interestRateStrategyAddress).getMaxVariableBorrowRate();\n\n    require(\n      usageRatio >= REBALANCE_UP_USAGE_RATIO_THRESHOLD &&\n        currentLiquidityRate <=\n        maxVariableBorrowRate.percentMul(REBALANCE_UP_LIQUIDITY_RATE_THRESHOLD),\n      Errors.LP_INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET\n    );\n  }\n\n  /**\n   * @dev Validates the action of setting an asset as collateral\n   * @param reserve The state of the reserve that the user is enabling or disabling as collateral\n   * @param reserveAddress The address of the reserve\n   * @param reservesData The data of all the reserves\n   * @param userConfig The state of the user for the specific reserve\n   * @param reserves The addresses of all the active reserves\n   * @param oracle The price oracle\n   */\n  function validateSetUseReserveAsCollateral(\n    DataTypes.ReserveData storage reserve,\n    address reserveAddress,\n    bool useAsCollateral,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    DataTypes.UserConfigurationMap storage userConfig,\n    mapping(uint256 => address) storage reserves,\n    uint256 reservesCount,\n    address oracle\n  ) external view {\n    uint256 underlyingBalance = IERC20(reserve.aTokenAddress).balanceOf(msg.sender);\n\n    require(underlyingBalance > 0, Errors.VL_UNDERLYING_BALANCE_NOT_GREATER_THAN_0);\n\n    require(\n      useAsCollateral ||\n        GenericLogic.balanceDecreaseAllowed(\n          reserveAddress,\n          msg.sender,\n          underlyingBalance,\n          reservesData,\n          userConfig,\n          reserves,\n          reservesCount,\n          oracle\n        ),\n      Errors.VL_DEPOSIT_ALREADY_IN_USE\n    );\n  }\n\n  /**\n   * @dev Validates a flashloan action\n   * @param assets The assets being flashborrowed\n   * @param amounts The amounts for each asset being borrowed\n   **/\n  function validateFlashloan(address[] memory assets, uint256[] memory amounts) internal pure {\n    require(assets.length == amounts.length, Errors.VL_INCONSISTENT_FLASHLOAN_PARAMS);\n  }\n\n  /**\n   * @dev Validates the liquidation action\n   * @param collateralReserve The reserve data of the collateral\n   * @param principalReserve The reserve data of the principal\n   * @param userConfig The user configuration\n   * @param userHealthFactor The user's health factor\n   * @param userStableDebt Total stable debt balance of the user\n   * @param userVariableDebt Total variable debt balance of the user\n   **/\n  function validateLiquidationCall(\n    DataTypes.ReserveData storage collateralReserve,\n    DataTypes.ReserveData storage principalReserve,\n    DataTypes.UserConfigurationMap storage userConfig,\n    uint256 userHealthFactor,\n    uint256 userStableDebt,\n    uint256 userVariableDebt\n  ) internal view returns (uint256, string memory) {\n    if (\n      !collateralReserve.configuration.getActive() || !principalReserve.configuration.getActive()\n    ) {\n      return (\n        uint256(Errors.CollateralManagerErrors.NO_ACTIVE_RESERVE),\n        Errors.VL_NO_ACTIVE_RESERVE\n      );\n    }\n\n    if (userHealthFactor >= GenericLogic.HEALTH_FACTOR_LIQUIDATION_THRESHOLD) {\n      return (\n        uint256(Errors.CollateralManagerErrors.HEALTH_FACTOR_ABOVE_THRESHOLD),\n        Errors.LPCM_HEALTH_FACTOR_NOT_BELOW_THRESHOLD\n      );\n    }\n\n    bool isCollateralEnabled =\n      collateralReserve.configuration.getLiquidationThreshold() > 0 &&\n        userConfig.isUsingAsCollateral(collateralReserve.id);\n\n    //if collateral isn't enabled as collateral by user, it cannot be liquidated\n    if (!isCollateralEnabled) {\n      return (\n        uint256(Errors.CollateralManagerErrors.COLLATERAL_CANNOT_BE_LIQUIDATED),\n        Errors.LPCM_COLLATERAL_CANNOT_BE_LIQUIDATED\n      );\n    }\n\n    if (userStableDebt == 0 && userVariableDebt == 0) {\n      return (\n        uint256(Errors.CollateralManagerErrors.CURRRENCY_NOT_BORROWED),\n        Errors.LPCM_SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER\n      );\n    }\n\n    return (uint256(Errors.CollateralManagerErrors.NO_ERROR), Errors.LPCM_NO_ERRORS);\n  }\n\n  /**\n   * @dev Validates an aToken transfer\n   * @param from The user from which the aTokens are being transferred\n   * @param reservesData The state of all the reserves\n   * @param userConfig The state of the user for the specific reserve\n   * @param reserves The addresses of all the active reserves\n   * @param oracle The price oracle\n   */\n  function validateTransfer(\n    address from,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    DataTypes.UserConfigurationMap storage userConfig,\n    mapping(uint256 => address) storage reserves,\n    uint256 reservesCount,\n    address oracle\n  ) internal view {\n    (, , , , uint256 healthFactor) =\n      GenericLogic.calculateUserAccountData(\n        from,\n        reservesData,\n        userConfig,\n        reserves,\n        reservesCount,\n        oracle\n      );\n\n    require(\n      healthFactor >= GenericLogic.HEALTH_FACTOR_LIQUIDATION_THRESHOLD,\n      Errors.VL_TRANSFER_NOT_ALLOWED\n    );\n  }\n}\n"
    },
    "contracts/protocol/libraries/math/MathUtils.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\nimport {SafeMath} from '../../../dependencies/openzeppelin/contracts/SafeMath.sol';\nimport {WadRayMath} from './WadRayMath.sol';\n\nlibrary MathUtils {\n  using SafeMath for uint256;\n  using WadRayMath for uint256;\n\n  /// @dev Ignoring leap years\n  uint256 internal constant SECONDS_PER_YEAR = 365 days;\n\n  /**\n   * @dev Function to calculate the interest accumulated using a linear interest rate formula\n   * @param rate The interest rate, in ray\n   * @param lastUpdateTimestamp The timestamp of the last update of the interest\n   * @return The interest rate linearly accumulated during the timeDelta, in ray\n   **/\n\n  function calculateLinearInterest(uint256 rate, uint40 lastUpdateTimestamp)\n    internal\n    view\n    returns (uint256)\n  {\n    //solium-disable-next-line\n    uint256 timeDifference = block.timestamp.sub(uint256(lastUpdateTimestamp));\n\n    return (rate.mul(timeDifference) / SECONDS_PER_YEAR).add(WadRayMath.ray());\n  }\n\n  /**\n   * @dev Function to calculate the interest using a compounded interest rate formula\n   * To avoid expensive exponentiation, the calculation is performed using a binomial approximation:\n   *\n   *  (1+x)^n = 1+n*x+[n/2*(n-1)]*x^2+[n/6*(n-1)*(n-2)*x^3...\n   *\n   * The approximation slightly underpays liquidity providers and undercharges borrowers, with the advantage of great gas cost reductions\n   * The whitepaper contains reference to the approximation and a table showing the margin of error per different time periods\n   *\n   * @param rate The interest rate, in ray\n   * @param lastUpdateTimestamp The timestamp of the last update of the interest\n   * @return The interest rate compounded during the timeDelta, in ray\n   **/\n  function calculateCompoundedInterest(\n    uint256 rate,\n    uint40 lastUpdateTimestamp,\n    uint256 currentTimestamp\n  ) internal pure returns (uint256) {\n    //solium-disable-next-line\n    uint256 exp = currentTimestamp.sub(uint256(lastUpdateTimestamp));\n\n    if (exp == 0) {\n      return WadRayMath.ray();\n    }\n\n    uint256 expMinusOne = exp - 1;\n\n    uint256 expMinusTwo = exp > 2 ? exp - 2 : 0;\n\n    uint256 ratePerSecond = rate / SECONDS_PER_YEAR;\n\n    uint256 basePowerTwo = ratePerSecond.rayMul(ratePerSecond);\n    uint256 basePowerThree = basePowerTwo.rayMul(ratePerSecond);\n\n    uint256 secondTerm = exp.mul(expMinusOne).mul(basePowerTwo) / 2;\n    uint256 thirdTerm = exp.mul(expMinusOne).mul(expMinusTwo).mul(basePowerThree) / 6;\n\n    return WadRayMath.ray().add(ratePerSecond.mul(exp)).add(secondTerm).add(thirdTerm);\n  }\n\n  /**\n   * @dev Calculates the compounded interest between the timestamp of the last update and the current block timestamp\n   * @param rate The interest rate (in ray)\n   * @param lastUpdateTimestamp The timestamp from which the interest accumulation needs to be calculated\n   **/\n  function calculateCompoundedInterest(uint256 rate, uint40 lastUpdateTimestamp)\n    internal\n    view\n    returns (uint256)\n  {\n    return calculateCompoundedInterest(rate, lastUpdateTimestamp, block.timestamp);\n  }\n}\n"
    },
    "contracts/protocol/libraries/math/PercentageMath.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\nimport {Errors} from '../helpers/Errors.sol';\n\n/**\n * @title PercentageMath library\n * @author Aave\n * @notice Provides functions to perform percentage calculations\n * @dev Percentages are defined by default with 2 decimals of precision (100.00). The precision is indicated by PERCENTAGE_FACTOR\n * @dev Operations are rounded half up\n **/\n\nlibrary PercentageMath {\n  uint256 constant PERCENTAGE_FACTOR = 1e4; //percentage plus two decimals\n  uint256 constant HALF_PERCENT = PERCENTAGE_FACTOR / 2;\n\n  /**\n   * @dev Executes a percentage multiplication\n   * @param value The value of which the percentage needs to be calculated\n   * @param percentage The percentage of the value to be calculated\n   * @return The percentage of value\n   **/\n  function percentMul(uint256 value, uint256 percentage) internal pure returns (uint256) {\n    if (value == 0 || percentage == 0) {\n      return 0;\n    }\n\n    require(\n      value <= (type(uint256).max - HALF_PERCENT) / percentage,\n      Errors.MATH_MULTIPLICATION_OVERFLOW\n    );\n\n    return (value * percentage + HALF_PERCENT) / PERCENTAGE_FACTOR;\n  }\n\n  /**\n   * @dev Executes a percentage division\n   * @param value The value of which the percentage needs to be calculated\n   * @param percentage The percentage of the value to be calculated\n   * @return The value divided the percentage\n   **/\n  function percentDiv(uint256 value, uint256 percentage) internal pure returns (uint256) {\n    require(percentage != 0, Errors.MATH_DIVISION_BY_ZERO);\n    uint256 halfPercentage = percentage / 2;\n\n    require(\n      value <= (type(uint256).max - halfPercentage) / PERCENTAGE_FACTOR,\n      Errors.MATH_MULTIPLICATION_OVERFLOW\n    );\n\n    return (value * PERCENTAGE_FACTOR + halfPercentage) / percentage;\n  }\n}\n"
    },
    "contracts/protocol/libraries/math/WadRayMath.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\nimport {Errors} from '../helpers/Errors.sol';\n\n/**\n * @title WadRayMath library\n * @author Aave\n * @dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (decimals with 27 digits)\n **/\n\nlibrary WadRayMath {\n  uint256 internal constant WAD = 1e18;\n  uint256 internal constant halfWAD = WAD / 2;\n\n  uint256 internal constant RAY = 1e27;\n  uint256 internal constant halfRAY = RAY / 2;\n\n  uint256 internal constant WAD_RAY_RATIO = 1e9;\n\n  /**\n   * @return One ray, 1e27\n   **/\n  function ray() internal pure returns (uint256) {\n    return RAY;\n  }\n\n  /**\n   * @return One wad, 1e18\n   **/\n\n  function wad() internal pure returns (uint256) {\n    return WAD;\n  }\n\n  /**\n   * @return Half ray, 1e27/2\n   **/\n  function halfRay() internal pure returns (uint256) {\n    return halfRAY;\n  }\n\n  /**\n   * @return Half ray, 1e18/2\n   **/\n  function halfWad() internal pure returns (uint256) {\n    return halfWAD;\n  }\n\n  /**\n   * @dev Multiplies two wad, rounding half up to the nearest wad\n   * @param a Wad\n   * @param b Wad\n   * @return The result of a*b, in wad\n   **/\n  function wadMul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0 || b == 0) {\n      return 0;\n    }\n\n    require(a <= (type(uint256).max - halfWAD) / b, Errors.MATH_MULTIPLICATION_OVERFLOW);\n\n    return (a * b + halfWAD) / WAD;\n  }\n\n  /**\n   * @dev Divides two wad, rounding half up to the nearest wad\n   * @param a Wad\n   * @param b Wad\n   * @return The result of a/b, in wad\n   **/\n  function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0, Errors.MATH_DIVISION_BY_ZERO);\n    uint256 halfB = b / 2;\n\n    require(a <= (type(uint256).max - halfB) / WAD, Errors.MATH_MULTIPLICATION_OVERFLOW);\n\n    return (a * WAD + halfB) / b;\n  }\n\n  /**\n   * @dev Multiplies two ray, rounding half up to the nearest ray\n   * @param a Ray\n   * @param b Ray\n   * @return The result of a*b, in ray\n   **/\n  function rayMul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0 || b == 0) {\n      return 0;\n    }\n\n    require(a <= (type(uint256).max - halfRAY) / b, Errors.MATH_MULTIPLICATION_OVERFLOW);\n\n    return (a * b + halfRAY) / RAY;\n  }\n\n  /**\n   * @dev Divides two ray, rounding half up to the nearest ray\n   * @param a Ray\n   * @param b Ray\n   * @return The result of a/b, in ray\n   **/\n  function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0, Errors.MATH_DIVISION_BY_ZERO);\n    uint256 halfB = b / 2;\n\n    require(a <= (type(uint256).max - halfB) / RAY, Errors.MATH_MULTIPLICATION_OVERFLOW);\n\n    return (a * RAY + halfB) / b;\n  }\n\n  /**\n   * @dev Casts ray down to wad\n   * @param a Ray\n   * @return a casted to wad, rounded half up to the nearest wad\n   **/\n  function rayToWad(uint256 a) internal pure returns (uint256) {\n    uint256 halfRatio = WAD_RAY_RATIO / 2;\n    uint256 result = halfRatio + a;\n    require(result >= halfRatio, Errors.MATH_ADDITION_OVERFLOW);\n\n    return result / WAD_RAY_RATIO;\n  }\n\n  /**\n   * @dev Converts wad up to ray\n   * @param a Wad\n   * @return a converted in ray\n   **/\n  function wadToRay(uint256 a) internal pure returns (uint256) {\n    uint256 result = a * WAD_RAY_RATIO;\n    require(result / WAD_RAY_RATIO == a, Errors.MATH_MULTIPLICATION_OVERFLOW);\n    return result;\n  }\n}\n"
    },
    "contracts/protocol/libraries/types/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\nlibrary DataTypes {\n  // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\n  struct ReserveData {\n    //stores the reserve configuration\n    ReserveConfigurationMap configuration;\n    //the liquidity index. Expressed in ray\n    uint128 liquidityIndex;\n    //variable borrow index. Expressed in ray\n    uint128 variableBorrowIndex;\n    //the current supply rate. Expressed in ray\n    uint128 currentLiquidityRate;\n    //the current variable borrow rate. Expressed in ray\n    uint128 currentVariableBorrowRate;\n    //the current stable borrow rate. Expressed in ray\n    uint128 currentStableBorrowRate;\n    uint40 lastUpdateTimestamp;\n    //tokens addresses\n    address aTokenAddress;\n    address stableDebtTokenAddress;\n    address variableDebtTokenAddress;\n    //address of the interest rate strategy\n    address interestRateStrategyAddress;\n    //the id of the reserve. Represents the position in the list of the active reserves\n    uint8 id;\n  }\n\n  struct ReserveConfigurationMap {\n    //bit 0-15: LTV\n    //bit 16-31: Liq. threshold\n    //bit 32-47: Liq. bonus\n    //bit 48-55: Decimals\n    //bit 56: Reserve is active\n    //bit 57: reserve is frozen\n    //bit 58: borrowing is enabled\n    //bit 59: stable rate borrowing enabled\n    //bit 60-63: reserved\n    //bit 64-79: reserve factor\n    uint256 data;\n  }\n\n  struct UserConfigurationMap {\n    uint256 data;\n  }\n\n  enum InterestRateMode {NONE, STABLE, VARIABLE}\n}\n"
    },
    "contracts/protocol/tokenization/AToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport {IERC20} from '../../dependencies/openzeppelin/contracts/IERC20.sol';\nimport {SafeERC20} from '../../dependencies/openzeppelin/contracts/SafeERC20.sol';\nimport {ILendingPool} from '../../interfaces/ILendingPool.sol';\nimport {IAToken} from '../../interfaces/IAToken.sol';\nimport {WadRayMath} from '../libraries/math/WadRayMath.sol';\nimport {Errors} from '../libraries/helpers/Errors.sol';\nimport {VersionedInitializable} from '../libraries/aave-upgradeability/VersionedInitializable.sol';\nimport {IncentivizedERC20} from './IncentivizedERC20.sol';\nimport {IAaveIncentivesController} from '../../interfaces/IAaveIncentivesController.sol';\nimport {SafeMath} from '../../dependencies/openzeppelin/contracts/SafeMath.sol';\nimport {IMFDstats} from '../../interfaces/IMFDstats.sol';\nimport {IMiddleFeeDistribution} from '../../interfaces/IMiddleFeeDistribution.sol';\n\n/**\n * @title Aave ERC20 AToken\n * @dev Implementation of the interest bearing token for the Aave protocol\n * @author Aave\n */\ncontract AToken is\n  VersionedInitializable,\n  IncentivizedERC20('ATOKEN_IMPL', 'ATOKEN_IMPL', 0),\n  IAToken\n{\n  using WadRayMath for uint256;\n  using SafeERC20 for IERC20;\n  using SafeMath for uint256;\n\n  bytes public constant EIP712_REVISION = bytes('1');\n  bytes32 internal constant EIP712_DOMAIN =\n    keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)');\n  bytes32 public constant PERMIT_TYPEHASH =\n    keccak256('Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)');\n\n  uint256 public constant ATOKEN_REVISION = 0x1;\n\n  /// @dev owner => next valid nonce to submit with permit()\n  mapping(address => uint256) public _nonces;\n\n  bytes32 public DOMAIN_SEPARATOR;\n\n  address internal _treasury;\n  IAaveIncentivesController internal _incentivesController;\n\n  event MfdStatsSuccess (string state);\n\n  modifier onlyLendingPool {\n    require(_msgSender() == address(_pool), Errors.CT_CALLER_MUST_BE_LENDING_POOL);\n    _;\n  }\n\n  function getRevision() internal pure virtual override returns (uint256) {\n    return ATOKEN_REVISION;\n  }\n\n  /**\n   * @dev Initializes the aToken\n   * @param pool The address of the lending pool where this aToken will be used\n   * @param treasury The address of the Aave treasury, receiving the fees on this aToken\n   * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH)\n   * @param incentivesController The smart contract managing potential incentives distribution\n   * @param aTokenDecimals The decimals of the aToken, same as the underlying asset's\n   * @param aTokenName The name of the aToken\n   * @param aTokenSymbol The symbol of the aToken\n   */\n  function initialize(\n    ILendingPool pool,\n    address treasury,\n    address underlyingAsset,\n    IAaveIncentivesController incentivesController,\n    uint8 aTokenDecimals,\n    string calldata aTokenName,\n    string calldata aTokenSymbol,\n    bytes calldata params\n  ) external override initializer {\n    uint256 chainId;\n\n    //solium-disable-next-line\n    assembly {\n      chainId := chainid()\n    }\n\n    DOMAIN_SEPARATOR = keccak256(\n      abi.encode(\n        EIP712_DOMAIN,\n        keccak256(bytes(aTokenName)),\n        keccak256(EIP712_REVISION),\n        chainId,\n        address(this)\n      )\n    );\n\n    _setName(aTokenName);\n    _setSymbol(aTokenSymbol);\n    _setDecimals(aTokenDecimals);\n\n    _pool = pool;\n    _treasury = treasury;\n    _underlyingAsset = underlyingAsset;\n    _incentivesController = incentivesController;\n\n    emit Initialized(\n      underlyingAsset,\n      address(pool),\n      treasury,\n      address(incentivesController),\n      aTokenDecimals,\n      aTokenName,\n      aTokenSymbol,\n      params\n    );\n  }\n\n  /**\n   * @dev Burns aTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\n   * - Only callable by the LendingPool, as extra state updates there need to be managed\n   * @param user The owner of the aTokens, getting them burned\n   * @param receiverOfUnderlying The address that will receive the underlying\n   * @param amount The amount being burned\n   * @param index The new liquidity index of the reserve\n   **/\n  function burn(\n    address user,\n    address receiverOfUnderlying,\n    uint256 amount,\n    uint256 index\n  ) external override onlyLendingPool {\n    uint256 amountScaled = amount.rayDiv(index);\n    require(amountScaled != 0, Errors.CT_INVALID_BURN_AMOUNT);\n    _burn(user, amountScaled);\n\n    IERC20(_underlyingAsset).safeTransfer(receiverOfUnderlying, amount);\n\n    emit Transfer(user, address(0), amount);\n    emit Burn(user, receiverOfUnderlying, amount, index);\n  }\n\n  /**\n   * @dev Mints `amount` aTokens to `user`\n   * - Only callable by the LendingPool, as extra state updates there need to be managed\n   * @param user The address receiving the minted tokens\n   * @param amount The amount of tokens getting minted\n   * @param index The new liquidity index of the reserve\n   * @return `true` if the the previous balance of the user was 0\n   */\n  function mint(\n    address user,\n    uint256 amount,\n    uint256 index\n  ) external override onlyLendingPool returns (bool) {\n    uint256 previousBalance = super.balanceOf(user);\n\n    uint256 amountScaled = amount.rayDiv(index);\n    require(amountScaled != 0, Errors.CT_INVALID_MINT_AMOUNT);\n    _mint(user, amountScaled);\n\n    emit Transfer(address(0), user, amount);\n    emit Mint(user, amount, index);\n\n    return previousBalance == 0;\n  }\n\n  /**\n   * @dev Mints aTokens to the reserve treasury\n   * - Only callable by the LendingPool\n   * @param amount The amount of tokens getting minted\n   * @param index The new liquidity index of the reserve\n   */\n  function mintToTreasury(uint256 amount, uint256 index) external override onlyLendingPool {\n    if (amount == 0) {\n      return;\n    }\n\n    address treasury = _treasury;\n\n    // Compared to the normal mint, we don't check for rounding errors.\n    // The amount to mint can easily be very small since it is a fraction of the interest ccrued.\n    // In that case, the treasury will experience a (very small) loss, but it\n    // wont cause potentially valid transactions to fail.\n    _mint(treasury, amount.rayDiv(index));\n    \n    try IMiddleFeeDistribution(treasury).getMFDstatsAddress() returns (address mfdStats) {\n        try IMFDstats(mfdStats).addTransfer(IMFDstats.AddTransferParam(_underlyingAsset, amount, treasury)) {\n          emit MfdStatsSuccess(\"Success!\");\n        } catch {\n          emit MfdStatsSuccess(\"Add Transfer Failed!\");\n        }\n    } catch {\n        emit MfdStatsSuccess(\"Get MFDstats Address Failed!\");\n    }\n\n    emit Transfer(address(0), treasury, amount);\n    emit Mint(treasury, amount, index);\n  }\n\n  /**\n   * @dev Transfers aTokens in the event of a borrow being liquidated, in case the liquidators reclaims the aToken\n   * - Only callable by the LendingPool\n   * @param from The address getting liquidated, current owner of the aTokens\n   * @param to The recipient\n   * @param value The amount of tokens getting transferred\n   **/\n  function transferOnLiquidation(\n    address from,\n    address to,\n    uint256 value\n  ) external override onlyLendingPool {\n    // Being a normal transfer, the Transfer() and BalanceTransfer() are emitted\n    // so no need to emit a specific event here\n    _transfer(from, to, value, false);\n\n    emit Transfer(from, to, value);\n  }\n\n  /**\n   * @dev Calculates the balance of the user: principal balance + interest generated by the principal\n   * @param user The user whose balance is calculated\n   * @return The balance of the user\n   **/\n  function balanceOf(address user)\n    public\n    view\n    override(IncentivizedERC20, IERC20)\n    returns (uint256)\n  {\n    return super.balanceOf(user).rayMul(_pool.getReserveNormalizedIncome(_underlyingAsset));\n  }\n\n  /**\n   * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the\n   * updated stored balance divided by the reserve's liquidity index at the moment of the update\n   * @param user The user whose balance is calculated\n   * @return The scaled balance of the user\n   **/\n  function scaledBalanceOf(address user) external view override returns (uint256) {\n    return super.balanceOf(user);\n  }\n\n  /**\n   * @dev Returns the scaled balance of the user and the scaled total supply.\n   * @param user The address of the user\n   * @return The scaled balance of the user\n   * @return The scaled balance and the scaled total supply\n   **/\n  function getScaledUserBalanceAndSupply(address user)\n    external\n    view\n    override\n    returns (uint256, uint256)\n  {\n    return (super.balanceOf(user), super.totalSupply());\n  }\n\n  /**\n   * @dev calculates the total supply of the specific aToken\n   * since the balance of every single user increases over time, the total supply\n   * does that too.\n   * @return the current total supply\n   **/\n  function totalSupply() public view override(IncentivizedERC20, IERC20) returns (uint256) {\n    uint256 currentSupplyScaled = super.totalSupply();\n\n    if (currentSupplyScaled == 0) {\n      return 0;\n    }\n\n    return currentSupplyScaled.rayMul(_pool.getReserveNormalizedIncome(_underlyingAsset));\n  }\n\n  /**\n   * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index)\n   * @return the scaled total supply\n   **/\n  function scaledTotalSupply() public view virtual override returns (uint256) {\n    return super.totalSupply();\n  }\n\n  /**\n   * @dev Returns the address of the Aave treasury, receiving the fees on this aToken\n   **/\n  function RESERVE_TREASURY_ADDRESS() public view returns (address) {\n    return _treasury;\n  }\n\n  /**\n   * @dev Returns the address of the underlying asset of this aToken (E.g. WETH for aWETH)\n   **/\n  function UNDERLYING_ASSET_ADDRESS() public override view returns (address) {\n    return _underlyingAsset;\n  }\n\n  /**\n   * @dev Returns the address of the lending pool where this aToken is used\n   **/\n  function POOL() public view returns (ILendingPool) {\n    return _pool;\n  }\n\n  /**\n   * @dev For internal usage in the logic of the parent contract IncentivizedERC20\n   **/\n  function _getIncentivesController() internal view override returns (IAaveIncentivesController) {\n    return _incentivesController;\n  }\n\n  /**\n   * @dev Returns the address of the incentives controller contract\n   **/\n  function getIncentivesController() external view override returns (IAaveIncentivesController) {\n    return _getIncentivesController();\n  }\n\n  /**\n   * @dev Transfers the underlying asset to `target`. Used by the LendingPool to transfer\n   * assets in borrow(), withdraw() and flashLoan()\n   * @param target The recipient of the aTokens\n   * @param amount The amount getting transferred\n   * @return The amount transferred\n   **/\n  function transferUnderlyingTo(address target, uint256 amount)\n    external\n    override\n    onlyLendingPool\n    returns (uint256)\n  {\n    IERC20(_underlyingAsset).safeTransfer(target, amount);\n    return amount;\n  }\n\n  /**\n   * @dev Invoked to execute actions on the aToken side after a repayment.\n   * @param user The user executing the repayment\n   * @param amount The amount getting repaid\n   **/\n  function handleRepayment(address user, uint256 amount) external override onlyLendingPool {}\n\n  /**\n   * @dev implements the permit function as for\n   * https://github.com/ethereum/EIPs/blob/8a34d644aacf0f9f8f00815307fd7dd5da07655f/EIPS/eip-2612.md\n   * @param owner The owner of the funds\n   * @param spender The spender\n   * @param value The amount\n   * @param deadline The deadline timestamp, type(uint256).max for max deadline\n   * @param v Signature param\n   * @param s Signature param\n   * @param r Signature param\n   */\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external {\n    require(owner != address(0), 'INVALID_OWNER');\n    //solium-disable-next-line\n    require(block.timestamp <= deadline, 'INVALID_EXPIRATION');\n    uint256 currentValidNonce = _nonces[owner];\n    bytes32 digest =\n      keccak256(\n        abi.encodePacked(\n          '\\x19\\x01',\n          DOMAIN_SEPARATOR,\n          keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, currentValidNonce, deadline))\n        )\n      );\n    require(owner == ecrecover(digest, v, r, s), 'INVALID_SIGNATURE');\n    _nonces[owner] = currentValidNonce.add(1);\n    _approve(owner, spender, value);\n  }\n\n  /**\n   * @dev Transfers the aTokens between two users. Validates the transfer\n   * (ie checks for valid HF after the transfer) if required\n   * @param from The source address\n   * @param to The destination address\n   * @param amount The amount getting transferred\n   * @param validate `true` if the transfer needs to be validated\n   **/\n  function _transfer(\n    address from,\n    address to,\n    uint256 amount,\n    bool validate\n  ) internal {\n    address underlyingAsset = _underlyingAsset;\n    ILendingPool pool = _pool;\n\n    uint256 index = pool.getReserveNormalizedIncome(underlyingAsset);\n\n    uint256 fromBalanceBefore = super.balanceOf(from).rayMul(index);\n    uint256 toBalanceBefore = super.balanceOf(to).rayMul(index);\n\n    super._transfer(from, to, amount.rayDiv(index));\n\n    if (validate) {\n      pool.finalizeTransfer(underlyingAsset, from, to, amount, fromBalanceBefore, toBalanceBefore);\n    }\n\n    emit BalanceTransfer(from, to, amount, index);\n  }\n\n  /**\n   * @dev Overrides the parent _transfer to force validated transfer() and transferFrom()\n   * @param from The source address\n   * @param to The destination address\n   * @param amount The amount getting transferred\n   **/\n  function _transfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal override {\n    _transfer(from, to, amount, true);\n  }\n}\n"
    },
    "contracts/protocol/tokenization/base/DebtTokenBase.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\nimport {ILendingPool} from '../../../interfaces/ILendingPool.sol';\nimport {ICreditDelegationToken} from '../../../interfaces/ICreditDelegationToken.sol';\nimport {\n  VersionedInitializable\n} from '../../libraries/aave-upgradeability/VersionedInitializable.sol';\nimport {IncentivizedERC20} from '../IncentivizedERC20.sol';\nimport {Errors} from '../../libraries/helpers/Errors.sol';\nimport {SafeMath} from '../../../dependencies/openzeppelin/contracts/SafeMath.sol';\n\n/**\n * @title DebtTokenBase\n * @notice Base contract for different types of debt tokens, like StableDebtToken or VariableDebtToken\n * @author Aave\n */\n\nabstract contract DebtTokenBase is\n  IncentivizedERC20('DEBTTOKEN_IMPL', 'DEBTTOKEN_IMPL', 0),\n  VersionedInitializable,\n  ICreditDelegationToken\n{\n  using SafeMath for uint256;\n\n  mapping(address => mapping(address => uint256)) internal _borrowAllowances;\n\n  /**\n   * @dev Only lending pool can call functions marked by this modifier\n   **/\n  modifier onlyLendingPool {\n    require(_msgSender() == address(_getLendingPool()), Errors.CT_CALLER_MUST_BE_LENDING_POOL);\n    _;\n  }\n\n  /**\n   * @dev delegates borrowing power to a user on the specific debt token\n   * @param delegatee the address receiving the delegated borrowing power\n   * @param amount the maximum amount being delegated. Delegation will still\n   * respect the liquidation constraints (even if delegated, a delegatee cannot\n   * force a delegator HF to go below 1)\n   **/\n  function approveDelegation(address delegatee, uint256 amount) external override {\n    _borrowAllowances[_msgSender()][delegatee] = amount;\n    emit BorrowAllowanceDelegated(_msgSender(), delegatee, _getUnderlyingAssetAddress(), amount);\n  }\n\n  /**\n   * @dev returns the borrow allowance of the user\n   * @param fromUser The user to giving allowance\n   * @param toUser The user to give allowance to\n   * @return the current allowance of toUser\n   **/\n  function borrowAllowance(address fromUser, address toUser)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return _borrowAllowances[fromUser][toUser];\n  }\n\n  /**\n   * @dev Being non transferrable, the debt token does not implement any of the\n   * standard ERC20 functions for transfer and allowance.\n   **/\n  function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n    recipient;\n    amount;\n    revert('TRANSFER_NOT_SUPPORTED');\n  }\n\n  function allowance(address owner, address spender)\n    public\n    view\n    virtual\n    override\n    returns (uint256)\n  {\n    owner;\n    spender;\n    revert('ALLOWANCE_NOT_SUPPORTED');\n  }\n\n  function approve(address spender, uint256 amount) public virtual override returns (bool) {\n    spender;\n    amount;\n    revert('APPROVAL_NOT_SUPPORTED');\n  }\n\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) public virtual override returns (bool) {\n    sender;\n    recipient;\n    amount;\n    revert('TRANSFER_NOT_SUPPORTED');\n  }\n\n  function increaseAllowance(address spender, uint256 addedValue)\n    public\n    virtual\n    override\n    returns (bool)\n  {\n    spender;\n    addedValue;\n    revert('ALLOWANCE_NOT_SUPPORTED');\n  }\n\n  function decreaseAllowance(address spender, uint256 subtractedValue)\n    public\n    virtual\n    override\n    returns (bool)\n  {\n    spender;\n    subtractedValue;\n    revert('ALLOWANCE_NOT_SUPPORTED');\n  }\n\n  function _decreaseBorrowAllowance(\n    address delegator,\n    address delegatee,\n    uint256 amount\n  ) internal {\n    uint256 newAllowance =\n      _borrowAllowances[delegator][delegatee].sub(amount, Errors.BORROW_ALLOWANCE_NOT_ENOUGH);\n\n    _borrowAllowances[delegator][delegatee] = newAllowance;\n\n    emit BorrowAllowanceDelegated(delegator, delegatee, _getUnderlyingAssetAddress(), newAllowance);\n  }\n\n  function _getUnderlyingAssetAddress() internal view virtual returns (address);\n\n  function _getLendingPool() internal view virtual returns (ILendingPool);\n}\n"
    },
    "contracts/protocol/tokenization/IncentivizedERC20.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\nimport {Context} from '../../dependencies/openzeppelin/contracts/Context.sol';\nimport {IERC20} from '../../dependencies/openzeppelin/contracts/IERC20.sol';\nimport {IERC20Detailed} from '../../dependencies/openzeppelin/contracts/IERC20Detailed.sol';\nimport {SafeMath} from '../../dependencies/openzeppelin/contracts/SafeMath.sol';\nimport {IAaveIncentivesController} from '../../interfaces/IAaveIncentivesController.sol';\nimport {ILendingPoolAddressesProvider} from '../../interfaces/ILendingPoolAddressesProvider.sol';\nimport {IPriceOracle} from '../../interfaces/IPriceOracle.sol';\nimport {ILendingPool} from '../../interfaces/ILendingPool.sol';\n\n/**\n * @title ERC20\n * @notice Basic ERC20 implementation\n * @author Aave, inspired by the Openzeppelin ERC20 implementation\n **/\nabstract contract IncentivizedERC20 is Context, IERC20, IERC20Detailed {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) internal _balances;\n\n  mapping(address => mapping(address => uint256)) private _allowances;\n  uint256 internal _totalSupply;\n  string private _name;\n  string private _symbol;\n  uint8 private _decimals;\n\n  ILendingPool internal _pool;\n  address internal _underlyingAsset;\n\n  constructor(\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_\n  ) {\n    _name = name_;\n    _symbol = symbol_;\n    _decimals = decimals_;\n  }\n\n  /**\n   * @return The name of the token\n   **/\n  function name() public view override returns (string memory) {\n    return _name;\n  }\n\n  /**\n   * @return The symbol of the token\n   **/\n  function symbol() public view override returns (string memory) {\n    return _symbol;\n  }\n\n  /**\n   * @return The decimals of the token\n   **/\n  function decimals() public view override returns (uint8) {\n    return _decimals;\n  }\n\n  /**\n   * @return The total supply of the token\n   **/\n  function totalSupply() public view virtual override returns (uint256) {\n    return _totalSupply;\n  }\n\n  /**\n   * @return The balance of the token\n   **/\n  function balanceOf(address account) public view virtual override returns (uint256) {\n    return _balances[account];\n  }\n\n  /**\n   * @return Abstract function implemented by the child aToken/debtToken.\n   * Done this way in order to not break compatibility with previous versions of aTokens/debtTokens\n   **/\n  function _getIncentivesController() internal view virtual returns(IAaveIncentivesController);\n\n  /**\n   * @dev Executes a transfer of tokens from _msgSender() to recipient\n   * @param recipient The recipient of the tokens\n   * @param amount The amount of tokens being transferred\n   * @return `true` if the transfer succeeds, `false` otherwise\n   **/\n  function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n    _transfer(_msgSender(), recipient, amount);\n    emit Transfer(_msgSender(), recipient, amount);\n    return true;\n  }\n\n  /**\n   * @dev Returns the allowance of spender on the tokens owned by owner\n   * @param owner The owner of the tokens\n   * @param spender The user allowed to spend the owner's tokens\n   * @return The amount of owner's tokens spender is allowed to spend\n   **/\n  function allowance(address owner, address spender)\n    public\n    view\n    virtual\n    override\n    returns (uint256)\n  {\n    return _allowances[owner][spender];\n  }\n\n  /**\n   * @dev Allows `spender` to spend the tokens owned by _msgSender()\n   * @param spender The user allowed to spend _msgSender() tokens\n   * @return `true`\n   **/\n  function approve(address spender, uint256 amount) public virtual override returns (bool) {\n    _approve(_msgSender(), spender, amount);\n    return true;\n  }\n\n  /**\n   * @dev Executes a transfer of token from sender to recipient, if _msgSender() is allowed to do so\n   * @param sender The owner of the tokens\n   * @param recipient The recipient of the tokens\n   * @param amount The amount of tokens being transferred\n   * @return `true` if the transfer succeeds, `false` otherwise\n   **/\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) public virtual override returns (bool) {\n    _transfer(sender, recipient, amount);\n    _approve(\n      sender,\n      _msgSender(),\n      _allowances[sender][_msgSender()].sub(amount, 'ERC20: transfer amount exceeds allowance')\n    );\n    emit Transfer(sender, recipient, amount);\n    return true;\n  }\n\n  /**\n   * @dev Increases the allowance of spender to spend _msgSender() tokens\n   * @param spender The user allowed to spend on behalf of _msgSender()\n   * @param addedValue The amount being added to the allowance\n   * @return `true`\n   **/\n  function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n    return true;\n  }\n\n  /**\n   * @dev Decreases the allowance of spender to spend _msgSender() tokens\n   * @param spender The user allowed to spend on behalf of _msgSender()\n   * @param subtractedValue The amount being subtracted to the allowance\n   * @return `true`\n   **/\n  function decreaseAllowance(address spender, uint256 subtractedValue)\n    public\n    virtual\n    returns (bool)\n  {\n    _approve(\n      _msgSender(),\n      spender,\n      _allowances[_msgSender()][spender].sub(\n        subtractedValue,\n        'ERC20: decreased allowance below zero'\n      )\n    );\n    return true;\n  }\n\n  function _transfer(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) internal virtual {\n    require(sender != address(0), 'ERC20: transfer from the zero address');\n    require(recipient != address(0), 'ERC20: transfer to the zero address');\n\n    _beforeTokenTransfer(sender, recipient, amount);\n\n    uint256 senderBalance = _balances[sender].sub(amount, 'ERC20: transfer amount exceeds balance');\n\n    if (address(_getIncentivesController()) != address(0)) {\n      // uint256 currentTotalSupply = _totalSupply;\n      _getIncentivesController().handleActionBefore(sender);\n      if (sender != recipient) {\n        _getIncentivesController().handleActionBefore(recipient);\n      }\n    }\n\n    _balances[sender] = senderBalance;\n    uint256 recipientBalance = _balances[recipient].add(amount);\n    _balances[recipient] = recipientBalance;\n\n    if (address(_getIncentivesController()) != address(0)) {\n      uint256 currentTotalSupply = _totalSupply;\n      _getIncentivesController().handleActionAfter(sender, senderBalance, currentTotalSupply);\n      if (sender != recipient) {\n        _getIncentivesController().handleActionAfter(recipient, recipientBalance, currentTotalSupply);\n      }\n    }\n  }\n\n  function _mint(address account, uint256 amount) internal virtual {\n    require(account != address(0), 'ERC20: mint to the zero address');\n\n    _beforeTokenTransfer(address(0), account, amount);\n\n    uint256 currentTotalSupply = _totalSupply.add(amount);\n    uint256 accountBalance = _balances[account].add(amount);\n    if (address(_getIncentivesController()) != address(0)) {\n      _getIncentivesController().handleActionBefore(account);\n    }\n    _totalSupply = currentTotalSupply;\n    _balances[account] = accountBalance;\n    if (address(_getIncentivesController()) != address(0)) {\n      _getIncentivesController().handleActionAfter(account, accountBalance, currentTotalSupply);\n    }\n  }\n\n  function _burn(address account, uint256 amount) internal virtual {\n    require(account != address(0), 'ERC20: burn from the zero address');\n\n    _beforeTokenTransfer(account, address(0), amount);\n\n    uint256 currentTotalSupply = _totalSupply.sub(amount);\n    uint256 accountBalance = _balances[account].sub(amount, 'ERC20: burn amount exceeds balance');\n\n    if (address(_getIncentivesController()) != address(0)) {\n      _getIncentivesController().handleActionBefore(account);\n    }\n\n    _totalSupply = currentTotalSupply;\n    _balances[account] = accountBalance;\n\n    if (address(_getIncentivesController()) != address(0)) {\n      _getIncentivesController().handleActionAfter(account, accountBalance, currentTotalSupply);\n    }\n  }\n\n  function _approve(\n    address owner,\n    address spender,\n    uint256 amount\n  ) internal virtual {\n    require(owner != address(0), 'ERC20: approve from the zero address');\n    require(spender != address(0), 'ERC20: approve to the zero address');\n\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  function _setName(string memory newName) internal {\n    _name = newName;\n  }\n\n  function _setSymbol(string memory newSymbol) internal {\n    _symbol = newSymbol;\n  }\n\n  function _setDecimals(uint8 newDecimals) internal {\n    _decimals = newDecimals;\n  }\n\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual {}\n\n  function getAssetPrice() external view returns (uint256) {\n      ILendingPoolAddressesProvider provider = _pool.getAddressesProvider();\n      address oracle = provider.getPriceOracle();\n      return IPriceOracle(oracle).getAssetPrice(_underlyingAsset);\n  }\n}\n"
    },
    "contracts/protocol/tokenization/StableDebtToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\nimport {DebtTokenBase} from './base/DebtTokenBase.sol';\nimport {MathUtils} from '../libraries/math/MathUtils.sol';\nimport {WadRayMath} from '../libraries/math/WadRayMath.sol';\nimport {IStableDebtToken} from '../../interfaces/IStableDebtToken.sol';\nimport {ILendingPool} from '../../interfaces/ILendingPool.sol';\nimport {IAaveIncentivesController} from '../../interfaces/IAaveIncentivesController.sol';\nimport {Errors} from '../libraries/helpers/Errors.sol';\nimport {SafeMath} from '../../dependencies/openzeppelin/contracts/SafeMath.sol';\n\n/**\n * @title StableDebtToken\n * @notice Implements a stable debt token to track the borrowing positions of users\n * at stable rate mode\n * @author Aave\n **/\ncontract StableDebtToken is IStableDebtToken, DebtTokenBase {\n  using WadRayMath for uint256;\n  using SafeMath for uint256;\n\n  uint256 public constant DEBT_TOKEN_REVISION = 0x1;\n\n  uint256 internal _avgStableRate;\n  mapping(address => uint40) internal _timestamps;\n  mapping(address => uint256) internal _usersStableRate;\n  uint40 internal _totalSupplyTimestamp;\n\n  IAaveIncentivesController internal _incentivesController;\n\n  /**\n   * @dev Initializes the debt token.\n   * @param pool The address of the lending pool where this aToken will be used\n   * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH)\n   * @param incentivesController The smart contract managing potential incentives distribution\n   * @param debtTokenDecimals The decimals of the debtToken, same as the underlying asset's\n   * @param debtTokenName The name of the token\n   * @param debtTokenSymbol The symbol of the token\n   */\n  function initialize(\n    ILendingPool pool,\n    address underlyingAsset,\n    IAaveIncentivesController incentivesController,\n    uint8 debtTokenDecimals,\n    string memory debtTokenName,\n    string memory debtTokenSymbol,\n    bytes calldata params\n  ) public override initializer {\n    _setName(debtTokenName);\n    _setSymbol(debtTokenSymbol);\n    _setDecimals(debtTokenDecimals);\n\n    _pool = pool;\n    _underlyingAsset = underlyingAsset;\n    _incentivesController = incentivesController;\n\n    emit Initialized(\n      underlyingAsset,\n      address(pool),\n      address(incentivesController),\n      debtTokenDecimals,\n      debtTokenName,\n      debtTokenSymbol,\n      params\n    );\n  }\n\n  /**\n   * @dev Gets the revision of the stable debt token implementation\n   * @return The debt token implementation revision\n   **/\n  function getRevision() internal pure virtual override returns (uint256) {\n    return DEBT_TOKEN_REVISION;\n  }\n\n  /**\n   * @dev Returns the average stable rate across all the stable rate debt\n   * @return the average stable rate\n   **/\n  function getAverageStableRate() external view virtual override returns (uint256) {\n    return _avgStableRate;\n  }\n\n  /**\n   * @dev Returns the timestamp of the last user action\n   * @return The last update timestamp\n   **/\n  function getUserLastUpdated(address user) external view virtual override returns (uint40) {\n    return _timestamps[user];\n  }\n\n  /**\n   * @dev Returns the stable rate of the user\n   * @param user The address of the user\n   * @return The stable rate of user\n   **/\n  function getUserStableRate(address user) external view virtual override returns (uint256) {\n    return _usersStableRate[user];\n  }\n\n  /**\n   * @dev Calculates the current user debt balance\n   * @return The accumulated debt of the user\n   **/\n  function balanceOf(address account) public view virtual override returns (uint256) {\n    uint256 accountBalance = super.balanceOf(account);\n    uint256 stableRate = _usersStableRate[account];\n    if (accountBalance == 0) {\n      return 0;\n    }\n    uint256 cumulatedInterest =\n      MathUtils.calculateCompoundedInterest(stableRate, _timestamps[account]);\n    return accountBalance.rayMul(cumulatedInterest);\n  }\n\n  struct MintLocalVars {\n    uint256 previousSupply;\n    uint256 nextSupply;\n    uint256 amountInRay;\n    uint256 newStableRate;\n    uint256 currentAvgStableRate;\n  }\n\n  /**\n   * @dev Mints debt token to the `onBehalfOf` address.\n   * -  Only callable by the LendingPool\n   * - The resulting rate is the weighted average between the rate of the new debt\n   * and the rate of the previous debt\n   * @param user The address receiving the borrowed underlying, being the delegatee in case\n   * of credit delegate, or same as `onBehalfOf` otherwise\n   * @param onBehalfOf The address receiving the debt tokens\n   * @param amount The amount of debt tokens to mint\n   * @param rate The rate of the debt being minted\n   **/\n  function mint(\n    address user,\n    address onBehalfOf,\n    uint256 amount,\n    uint256 rate\n  ) external override onlyLendingPool returns (bool) {\n    MintLocalVars memory vars;\n\n    if (user != onBehalfOf) {\n      _decreaseBorrowAllowance(onBehalfOf, user, amount);\n    }\n\n    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf);\n\n    vars.previousSupply = totalSupply();\n    vars.currentAvgStableRate = _avgStableRate;\n    vars.nextSupply = _totalSupply = vars.previousSupply.add(amount);\n\n    vars.amountInRay = amount.wadToRay();\n\n    vars.newStableRate = _usersStableRate[onBehalfOf]\n      .rayMul(currentBalance.wadToRay())\n      .add(vars.amountInRay.rayMul(rate))\n      .rayDiv(currentBalance.add(amount).wadToRay());\n\n    require(vars.newStableRate <= type(uint128).max, Errors.SDT_STABLE_DEBT_OVERFLOW);\n    _usersStableRate[onBehalfOf] = vars.newStableRate;\n\n    //solium-disable-next-line\n    _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp);\n\n    // Calculates the updated average stable rate\n    vars.currentAvgStableRate = _avgStableRate = vars\n      .currentAvgStableRate\n      .rayMul(vars.previousSupply.wadToRay())\n      .add(rate.rayMul(vars.amountInRay))\n      .rayDiv(vars.nextSupply.wadToRay());\n\n    _mint(onBehalfOf, amount.add(balanceIncrease), vars.previousSupply);\n\n    emit Transfer(address(0), onBehalfOf, amount);\n\n    emit Mint(\n      user,\n      onBehalfOf,\n      amount,\n      currentBalance,\n      balanceIncrease,\n      vars.newStableRate,\n      vars.currentAvgStableRate,\n      vars.nextSupply\n    );\n\n    return currentBalance == 0;\n  }\n\n  /**\n   * @dev Burns debt of `user`\n   * @param user The address of the user getting his debt burned\n   * @param amount The amount of debt tokens getting burned\n   **/\n  function burn(address user, uint256 amount) external override onlyLendingPool {\n    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(user);\n\n    uint256 previousSupply = totalSupply();\n    uint256 newAvgStableRate = 0;\n    uint256 nextSupply = 0;\n    uint256 userStableRate = _usersStableRate[user];\n\n    // Since the total supply and each single user debt accrue separately,\n    // there might be accumulation errors so that the last borrower repaying\n    // mght actually try to repay more than the available debt supply.\n    // In this case we simply set the total supply and the avg stable rate to 0\n    if (previousSupply <= amount) {\n      _avgStableRate = 0;\n      _totalSupply = 0;\n    } else {\n      nextSupply = _totalSupply = previousSupply.sub(amount);\n      uint256 firstTerm = _avgStableRate.rayMul(previousSupply.wadToRay());\n      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());\n\n      // For the same reason described above, when the last user is repaying it might\n      // happen that user rate * user balance > avg rate * total supply. In that case,\n      // we simply set the avg rate to 0\n      if (secondTerm >= firstTerm) {\n        newAvgStableRate = _avgStableRate = _totalSupply = 0;\n      } else {\n        newAvgStableRate = _avgStableRate = firstTerm.sub(secondTerm).rayDiv(nextSupply.wadToRay());\n      }\n    }\n\n    if (amount == currentBalance) {\n      _usersStableRate[user] = 0;\n      _timestamps[user] = 0;\n    } else {\n      //solium-disable-next-line\n      _timestamps[user] = uint40(block.timestamp);\n    }\n    //solium-disable-next-line\n    _totalSupplyTimestamp = uint40(block.timestamp);\n\n    if (balanceIncrease > amount) {\n      uint256 amountToMint = balanceIncrease.sub(amount);\n      _mint(user, amountToMint, previousSupply);\n      emit Mint(\n        user,\n        user,\n        amountToMint,\n        currentBalance,\n        balanceIncrease,\n        userStableRate,\n        newAvgStableRate,\n        nextSupply\n      );\n    } else {\n      uint256 amountToBurn = amount.sub(balanceIncrease);\n      _burn(user, amountToBurn, previousSupply);\n      emit Burn(user, amountToBurn, currentBalance, balanceIncrease, newAvgStableRate, nextSupply);\n    }\n\n    emit Transfer(user, address(0), amount);\n  }\n\n  /**\n   * @dev Calculates the increase in balance since the last user interaction\n   * @param user The address of the user for which the interest is being accumulated\n   * @return The previous principal balance, the new principal balance and the balance increase\n   **/\n  function _calculateBalanceIncrease(address user)\n    internal\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    uint256 previousPrincipalBalance = super.balanceOf(user);\n\n    if (previousPrincipalBalance == 0) {\n      return (0, 0, 0);\n    }\n\n    // Calculation of the accrued interest since the last accumulation\n    uint256 balanceIncrease = balanceOf(user).sub(previousPrincipalBalance);\n\n    return (\n      previousPrincipalBalance,\n      previousPrincipalBalance.add(balanceIncrease),\n      balanceIncrease\n    );\n  }\n\n  /**\n   * @dev Returns the principal and total supply, the average borrow rate and the last supply update timestamp\n   **/\n  function getSupplyData()\n    public\n    view\n    override\n    returns (\n      uint256,\n      uint256,\n      uint256,\n      uint40\n    )\n  {\n    uint256 avgRate = _avgStableRate;\n    return (super.totalSupply(), _calcTotalSupply(avgRate), avgRate, _totalSupplyTimestamp);\n  }\n\n  /**\n   * @dev Returns the the total supply and the average stable rate\n   **/\n  function getTotalSupplyAndAvgRate() public view override returns (uint256, uint256) {\n    uint256 avgRate = _avgStableRate;\n    return (_calcTotalSupply(avgRate), avgRate);\n  }\n\n  /**\n   * @dev Returns the total supply\n   **/\n  function totalSupply() public view override returns (uint256) {\n    return _calcTotalSupply(_avgStableRate);\n  }\n\n  /**\n   * @dev Returns the timestamp at which the total supply was updated\n   **/\n  function getTotalSupplyLastUpdated() public view override returns (uint40) {\n    return _totalSupplyTimestamp;\n  }\n\n  /**\n   * @dev Returns the principal debt balance of the user from\n   * @param user The user's address\n   * @return The debt balance of the user since the last burn/mint action\n   **/\n  function principalBalanceOf(address user) external view virtual override returns (uint256) {\n    return super.balanceOf(user);\n  }\n\n  /**\n   * @dev Returns the address of the underlying asset of this aToken (E.g. WETH for aWETH)\n   **/\n  function UNDERLYING_ASSET_ADDRESS() public view returns (address) {\n    return _underlyingAsset;\n  }\n\n  /**\n   * @dev Returns the address of the lending pool where this aToken is used\n   **/\n  function POOL() public view returns (ILendingPool) {\n    return _pool;\n  }\n\n  /**\n   * @dev Returns the address of the incentives controller contract\n   **/\n  function getIncentivesController() external view override returns (IAaveIncentivesController) {\n    return _getIncentivesController();\n  }\n\n  /**\n   * @dev For internal usage in the logic of the parent contracts\n   **/\n  function _getIncentivesController() internal view override returns (IAaveIncentivesController) {\n    return _incentivesController;\n  }\n\n  /**\n   * @dev For internal usage in the logic of the parent contracts\n   **/\n  function _getUnderlyingAssetAddress() internal view override returns (address) {\n    return _underlyingAsset;\n  }\n\n  /**\n   * @dev For internal usage in the logic of the parent contracts\n   **/\n  function _getLendingPool() internal view override returns (ILendingPool) {\n    return _pool;\n  }\n\n  /**\n   * @dev Calculates the total supply\n   * @param avgRate The average rate at which the total supply increases\n   * @return The debt balance of the user since the last burn/mint action\n   **/\n  function _calcTotalSupply(uint256 avgRate) internal view virtual returns (uint256) {\n    uint256 principalSupply = super.totalSupply();\n\n    if (principalSupply == 0) {\n      return 0;\n    }\n\n    uint256 cumulatedInterest =\n      MathUtils.calculateCompoundedInterest(avgRate, _totalSupplyTimestamp);\n\n    return principalSupply.rayMul(cumulatedInterest);\n  }\n\n  /**\n   * @dev Mints stable debt tokens to an user\n   * @param account The account receiving the debt tokens\n   * @param amount The amount being minted\n   * @param oldTotalSupply the total supply before the minting event\n   **/\n  function _mint(\n    address account,\n    uint256 amount,\n    uint256 oldTotalSupply\n  ) internal {\n    uint256 oldAccountBalance = _balances[account];\n    if (address(_incentivesController) != address(0)) {\n      _incentivesController.handleActionBefore(account);\n    }\n    _balances[account] = oldAccountBalance.add(amount);\n    if (address(_incentivesController) != address(0)) {\n      _incentivesController.handleActionAfter(account, oldAccountBalance, oldTotalSupply);\n    }\n  }\n\n  /**\n   * @dev Burns stable debt tokens of an user\n   * @param account The user getting his debt burned\n   * @param amount The amount being burned\n   * @param oldTotalSupply The total supply before the burning event\n   **/\n  function _burn(\n    address account,\n    uint256 amount,\n    uint256 oldTotalSupply\n  ) internal {\n    uint256 oldAccountBalance = _balances[account];\n    if (address(_incentivesController) != address(0)) {\n      _incentivesController.handleActionBefore(account);\n    }\n    _balances[account] = oldAccountBalance.sub(amount, Errors.SDT_BURN_EXCEEDS_BALANCE);\n    if (address(_incentivesController) != address(0)) {\n      _incentivesController.handleActionAfter(account, oldAccountBalance, oldTotalSupply);\n    }\n  }\n}\n"
    },
    "contracts/protocol/tokenization/VariableDebtToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\nimport {IVariableDebtToken} from '../../interfaces/IVariableDebtToken.sol';\nimport {WadRayMath} from '../libraries/math/WadRayMath.sol';\nimport {Errors} from '../libraries/helpers/Errors.sol';\nimport {DebtTokenBase} from './base/DebtTokenBase.sol';\nimport {ILendingPool} from '../../interfaces/ILendingPool.sol';\nimport {IAaveIncentivesController} from '../../interfaces/IAaveIncentivesController.sol';\nimport {SafeMath} from '../../dependencies/openzeppelin/contracts/SafeMath.sol';\n\n/**\n * @title VariableDebtToken\n * @notice Implements a variable debt token to track the borrowing positions of users\n * at variable rate mode\n * @author Aave\n **/\ncontract VariableDebtToken is DebtTokenBase, IVariableDebtToken {\n  using WadRayMath for uint256;\n  using SafeMath for uint256;\n\n  uint256 public constant DEBT_TOKEN_REVISION = 0x1;\n\n  IAaveIncentivesController internal _incentivesController;\n\n  /**\n   * @dev Initializes the debt token.\n   * @param pool The address of the lending pool where this aToken will be used\n   * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH)\n   * @param incentivesController The smart contract managing potential incentives distribution\n   * @param debtTokenDecimals The decimals of the debtToken, same as the underlying asset's\n   * @param debtTokenName The name of the token\n   * @param debtTokenSymbol The symbol of the token\n   */\n  function initialize(\n    ILendingPool pool,\n    address underlyingAsset,\n    IAaveIncentivesController incentivesController,\n    uint8 debtTokenDecimals,\n    string memory debtTokenName,\n    string memory debtTokenSymbol,\n    bytes calldata params\n  ) public override initializer {\n    _setName(debtTokenName);\n    _setSymbol(debtTokenSymbol);\n    _setDecimals(debtTokenDecimals);\n\n    _pool = pool;\n    _underlyingAsset = underlyingAsset;\n    _incentivesController = incentivesController;\n\n    emit Initialized(\n      underlyingAsset,\n      address(pool),\n      address(incentivesController),\n      debtTokenDecimals,\n      debtTokenName,\n      debtTokenSymbol,\n      params\n    );\n  }\n\n  /**\n   * @dev Gets the revision of the stable debt token implementation\n   * @return The debt token implementation revision\n   **/\n  function getRevision() internal pure virtual override returns (uint256) {\n    return DEBT_TOKEN_REVISION;\n  }\n\n  /**\n   * @dev Calculates the accumulated debt balance of the user\n   * @return The debt balance of the user\n   **/\n  function balanceOf(address user) public view virtual override returns (uint256) {\n    uint256 scaledBalance = super.balanceOf(user);\n\n    if (scaledBalance == 0) {\n      return 0;\n    }\n\n    return scaledBalance.rayMul(_pool.getReserveNormalizedVariableDebt(_underlyingAsset));\n  }\n\n  /**\n   * @dev Mints debt token to the `onBehalfOf` address\n   * -  Only callable by the LendingPool\n   * @param user The address receiving the borrowed underlying, being the delegatee in case\n   * of credit delegate, or same as `onBehalfOf` otherwise\n   * @param onBehalfOf The address receiving the debt tokens\n   * @param amount The amount of debt being minted\n   * @param index The variable debt index of the reserve\n   * @return `true` if the the previous balance of the user is 0\n   **/\n  function mint(\n    address user,\n    address onBehalfOf,\n    uint256 amount,\n    uint256 index\n  ) external override onlyLendingPool returns (bool) {\n    if (user != onBehalfOf) {\n      _decreaseBorrowAllowance(onBehalfOf, user, amount);\n    }\n\n    uint256 previousBalance = super.balanceOf(onBehalfOf);\n    uint256 amountScaled = amount.rayDiv(index);\n    require(amountScaled != 0, Errors.CT_INVALID_MINT_AMOUNT);\n\n    _mint(onBehalfOf, amountScaled);\n\n    emit Transfer(address(0), onBehalfOf, amount);\n    emit Mint(user, onBehalfOf, amount, index);\n\n    return previousBalance == 0;\n  }\n\n  /**\n   * @dev Burns user variable debt\n   * - Only callable by the LendingPool\n   * @param user The user whose debt is getting burned\n   * @param amount The amount getting burned\n   * @param index The variable debt index of the reserve\n   **/\n  function burn(\n    address user,\n    uint256 amount,\n    uint256 index\n  ) external override onlyLendingPool {\n    uint256 amountScaled = amount.rayDiv(index);\n    require(amountScaled != 0, Errors.CT_INVALID_BURN_AMOUNT);\n\n    _burn(user, amountScaled);\n\n    emit Transfer(user, address(0), amount);\n    emit Burn(user, amount, index);\n  }\n\n  /**\n   * @dev Returns the principal debt balance of the user from\n   * @return The debt balance of the user since the last burn/mint action\n   **/\n  function scaledBalanceOf(address user) public view virtual override returns (uint256) {\n    return super.balanceOf(user);\n  }\n\n  /**\n   * @dev Returns the total supply of the variable debt token. Represents the total debt accrued by the users\n   * @return The total supply\n   **/\n  function totalSupply() public view virtual override returns (uint256) {\n    return super.totalSupply().rayMul(_pool.getReserveNormalizedVariableDebt(_underlyingAsset));\n  }\n\n  /**\n   * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index)\n   * @return the scaled total supply\n   **/\n  function scaledTotalSupply() public view virtual override returns (uint256) {\n    return super.totalSupply();\n  }\n\n  /**\n   * @dev Returns the principal balance of the user and principal total supply.\n   * @param user The address of the user\n   * @return The principal balance of the user\n   * @return The principal total supply\n   **/\n  function getScaledUserBalanceAndSupply(address user)\n    external\n    view\n    override\n    returns (uint256, uint256)\n  {\n    return (super.balanceOf(user), super.totalSupply());\n  }\n\n  /**\n   * @dev Returns the address of the underlying asset of this aToken (E.g. WETH for aWETH)\n   **/\n  function UNDERLYING_ASSET_ADDRESS() public view returns (address) {\n    return _underlyingAsset;\n  }\n\n  /**\n   * @dev Returns the address of the incentives controller contract\n   **/\n  function getIncentivesController() external view override returns (IAaveIncentivesController) {\n    return _getIncentivesController();\n  }\n\n  /**\n   * @dev Returns the address of the lending pool where this aToken is used\n   **/\n  function POOL() public view returns (ILendingPool) {\n    return _pool;\n  }\n\n  function _getIncentivesController() internal view override returns (IAaveIncentivesController) {\n    return _incentivesController;\n  }\n\n  function _getUnderlyingAssetAddress() internal view override returns (address) {\n    return _underlyingAsset;\n  }\n\n  function _getLendingPool() internal view override returns (ILendingPool) {\n    return _pool;\n  }\n}\n"
    },
    "contracts/staking/ChefIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \"../interfaces/IMultiFeeDistribution.sol\";\nimport \"../interfaces/IEligibilityDataProvider.sol\";\nimport \"../interfaces/IOnwardIncentivesController.sol\";\nimport \"../interfaces/IAToken.sol\";\nimport \"../interfaces/IMiddleFeeDistribution.sol\";\nimport \"../interfaces/IBounty.sol\";\n\nimport \"../dependencies/openzeppelin/contracts/SafeMath.sol\";\nimport \"../dependencies/openzeppelin/contracts/IERC20.sol\";\nimport \"../dependencies/openzeppelin/contracts/IERC20Detailed.sol\";\nimport \"../dependencies/openzeppelin/contracts/SafeERC20.sol\";\nimport \"../dependencies/openzeppelin/upgradeability/Initializable.sol\";\nimport \"../dependencies/openzeppelin/upgradeability/OwnableUpgradeable.sol\";\nimport \"../dependencies/openzeppelin/upgradeability/PausableUpgradeable.sol\";\n\n// based on the Sushi MasterChef\n// https://github.com/sushiswap/sushiswap/blob/master/contracts/MasterChef.sol\ncontract ChefIncentivesController is\n    Initializable,\n    PausableUpgradeable,\n    OwnableUpgradeable\n{\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    // Info of each user.\n    // reward = user.`amount` * pool.`accRewardPerShare` - `rewardDebt`\n    struct UserInfo {\n        uint256 amount;\n        uint256 rewardDebt;\n        uint256 enterTime;\n        uint256 lastClaimTime;\n    }\n\n    // Info of each pool.\n    struct PoolInfo {\n        uint256 totalSupply;\n        uint256 allocPoint; // How many allocation points assigned to this pool.\n        uint256 lastRewardTime; // Last second that reward distribution occurs.\n        uint256 accRewardPerShare; // Accumulated rewards per share, times ACC_REWARD_PRECISION. See below.\n        IOnwardIncentivesController onwardIncentives;\n    }\n\n    // Info about token emissions for a given time period.\n    struct EmissionPoint {\n        uint128 startTimeOffset;\n        uint128 rewardsPerSecond;\n    }\n\n    // Emitted when rewardPerSecond is updated\n    event RewardsPerSecondUpdated(\n        uint256 indexed rewardsPerSecond,\n        bool persist\n    );\n\n    event BalanceUpdated(\n        address indexed token,\n        address indexed user,\n        uint256 balance,\n        uint256 totalSupply\n    );\n\n    event EmissionScheduleAppended(\n        uint256[] startTimeOffsets,\n        uint256[] rewardsPerSeconds\n    );\n\n    event ChefReserveLow(uint256 _balance);\n\n    event ChefReserveEmpty(uint256 _balance);\n\n    event Disqualified(address indexed user, uint256 rewardsRemoved);\n\n    // multiplier for reward calc\n    uint256 private constant ACC_REWARD_PRECISION = 1e12;\n\n    // Data about the future reward rates. emissionSchedule stored in chronological order,\n    // whenever the number of blocks since the start block exceeds the next block offset a new\n    // reward rate is applied.\n    EmissionPoint[] public emissionSchedule;\n\n    // If true, keep this new reward rate indefinitely\n    // If false, keep this reward rate until the next scheduled block offset, then return to the schedule.\n    bool public persistRewardsPerSecond;\n\n    /********************** Emission Info ***********************/\n\n    // Array of tokens for reward\n    address[] public registeredTokens;\n\n    // Current reward per second\n    uint256 public rewardsPerSecond;\n\n    // last RPS, used during refill after reserve empty\n    uint256 public lastRPS;\n\n    // Index in emission schedule which the last rewardsPerSeconds was used\n    // only used for scheduled rewards\n    uint256 public emissionScheduleIndex;\n\n    // Info of each pool.\n    mapping(address => PoolInfo) public poolInfo;\n    mapping(address => bool) private validRTokens;\n\n    // Total allocation poitns. Must be the sum of all allocation points in all pools.\n    uint256 public totalAllocPoint;\n\n    // token => user => Info of each user that stakes LP tokens.\n    mapping(address => mapping(address => UserInfo)) public userInfo;\n\n    // user => base claimable balance\n    mapping(address => uint256) public userBaseClaimable;\n\n    // MFD, LPMFD, bounties, AC, middlefee\n    mapping(address => bool) public eligibilityExempt;\n\n    // The block number when reward mining starts.\n    uint256 public startTime;\n\n    bool public ELIGIBILITY_ENABLED;\n\n    address public poolConfigurator;\n    uint256 public depositedRewards;\n    uint256 public accountedRewards;\n    uint256 public lastAllPoolUpdate;\n\n    IMiddleFeeDistribution public rewardMinter;\n    IEligibilityDataProvider public eligibleDataProvider;\n    address public bountyManager;\n\n    function initialize(\n        address _poolConfigurator,\n        IEligibilityDataProvider _eligibleDataProvider,\n        IMiddleFeeDistribution _rewardMinter,\n        uint256 _rewardsPerSecond\n    ) public initializer {\n        require(address(_poolConfigurator) != address(0));\n        require(address(_eligibleDataProvider) != address(0));\n        require(address(_rewardMinter) != address(0));\n\n        __Ownable_init();\n        __Pausable_init();\n\n        poolConfigurator = _poolConfigurator;\n        eligibleDataProvider = _eligibleDataProvider;\n        rewardMinter = _rewardMinter;\n        rewardsPerSecond = _rewardsPerSecond;\n        persistRewardsPerSecond = true;\n\n        ELIGIBILITY_ENABLED = true;\n    }\n\n    function poolLength() external view returns (uint256) {\n        return registeredTokens.length;\n    }\n\n    function _getMfd() internal view returns (IMultiFeeDistribution mfd) {\n        address multiFeeDistribution = rewardMinter\n            .getMultiFeeDistributionAddress();\n        mfd = IMultiFeeDistribution(multiFeeDistribution);\n    }\n\n    function _getLpMfd() internal view returns (IMultiFeeDistribution mfd) {\n        address multiFeeDistribution = rewardMinter\n            .getLPFeeDistributionAddress();\n        mfd = IMultiFeeDistribution(multiFeeDistribution);\n    }\n\n    function setOnwardIncentives(\n        address _token,\n        IOnwardIncentivesController _incentives\n    ) external onlyOwner {\n        require(poolInfo[_token].lastRewardTime != 0, \"pool doesn't exist\");\n        poolInfo[_token].onwardIncentives = _incentives;\n    }\n\n    function setBountyManager(address _bountyManager) external onlyOwner {\n        bountyManager = _bountyManager;\n    }\n\n    function setEligibilityEnabled(bool _newVal) external onlyOwner {\n        ELIGIBILITY_ENABLED = _newVal;\n    }\n\n    /********************** Pool Setup + Admin ***********************/\n\n    function start() public onlyOwner {\n        require(startTime == 0, \"already started\");\n        startTime = block.timestamp;\n    }\n\n    // Add a new lp to the pool. Can only be called by the poolConfigurator.\n    function addPool(address _token, uint256 _allocPoint) external {\n        require(msg.sender == poolConfigurator, \"not allowed\");\n        require(poolInfo[_token].lastRewardTime == 0, \"pool already exists\");\n        _updateEmissions();\n        totalAllocPoint = totalAllocPoint.add(_allocPoint);\n        registeredTokens.push(_token);\n        poolInfo[_token] = PoolInfo({\n            totalSupply: 0,\n            allocPoint: _allocPoint,\n            lastRewardTime: block.timestamp,\n            accRewardPerShare: 0,\n            onwardIncentives: IOnwardIncentivesController(0)\n        });\n        validRTokens[_token] = true;\n    }\n\n    // Update the given pool's allocation point. Can only be called by the owner.\n    function batchUpdateAllocPoint(\n        address[] calldata _tokens,\n        uint256[] calldata _allocPoints\n    ) public onlyOwner {\n        require(\n            _tokens.length == _allocPoints.length,\n            \"params length mismatch\"\n        );\n        _massUpdatePools();\n        uint256 _totalAllocPoint = totalAllocPoint;\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            PoolInfo storage pool = poolInfo[_tokens[i]];\n            require(pool.lastRewardTime > 0, \"pool doesn't exist\");\n            _totalAllocPoint = _totalAllocPoint.sub(pool.allocPoint).add(\n                _allocPoints[i]\n            );\n            pool.allocPoint = _allocPoints[i];\n        }\n        totalAllocPoint = _totalAllocPoint;\n    }\n\n    /**\n     * @notice Sets the reward per second to be distributed. Can only be called by the owner.\n     * @dev Its decimals count is ACC_REWARD_PRECISION\n     * @param _rewardsPerSecond The amount of reward to be distributed per second.\n     */\n    function setRewardsPerSecond(uint256 _rewardsPerSecond, bool _persist)\n        external\n        onlyOwner\n    {\n        _massUpdatePools();\n        rewardsPerSecond = _rewardsPerSecond;\n        persistRewardsPerSecond = _persist;\n        emit RewardsPerSecondUpdated(_rewardsPerSecond, _persist);\n    }\n\n    function setScheduledRewardsPerSecond() internal {\n        if (!persistRewardsPerSecond) {\n            uint256 length = emissionSchedule.length;\n            uint256 i = emissionScheduleIndex;\n            uint128 offset = uint128(block.timestamp.sub(startTime));\n            for (\n                ;\n                i < length && offset >= emissionSchedule[i].startTimeOffset;\n                i++\n            ) {}\n            if (i > emissionScheduleIndex) {\n                emissionScheduleIndex = i;\n                _massUpdatePools();\n                rewardsPerSecond = uint256(\n                    emissionSchedule[i - 1].rewardsPerSecond\n                );\n            }\n        }\n    }\n\n    function setEmissionSchedule(\n        uint256[] calldata _startTimeOffsets,\n        uint256[] calldata _rewardsPerSecond\n    ) external onlyOwner {\n        uint256 length = _startTimeOffsets.length;\n        require(\n            length > 0 && length == _rewardsPerSecond.length,\n            \"empty or mismatch params\"\n        );\n\n        for (uint256 i = 0; i < length; i++) {\n            require(\n                _startTimeOffsets[i] <= type(uint128).max,\n                \"startTimeOffsets > max uint128\"\n            );\n            require(\n                _rewardsPerSecond[i] <= type(uint128).max,\n                \"rewardsPerSecond > max uint128\"\n            );\n\n            if (startTime > 0) {\n                require(\n                    _startTimeOffsets[i] > block.timestamp.sub(startTime),\n                    \"invalid start time\"\n                );\n            }\n            emissionSchedule.push(\n                EmissionPoint({\n                    startTimeOffset: uint128(_startTimeOffsets[i]),\n                    rewardsPerSecond: uint128(_rewardsPerSecond[i])\n                })\n            );\n        }\n        emit EmissionScheduleAppended(_startTimeOffsets, _rewardsPerSecond);\n    }\n\n    function recoverERC20(address tokenAddress, uint256 tokenAmount)\n        external\n        onlyOwner\n    {\n        IERC20(tokenAddress).safeTransfer(owner(), tokenAmount);\n    }\n\n    /********************** Pool State Changers ***********************/\n\n    function _updateEmissions() internal {\n        if (block.timestamp > endRewardTime()) {\n            _massUpdatePools();\n            lastRPS = rewardsPerSecond;\n            rewardsPerSecond = 0;\n            return;\n        }\n        setScheduledRewardsPerSecond();\n    }\n\n    // Update reward variables for all pools\n    function _massUpdatePools() internal {\n        uint256 totalAP = totalAllocPoint;\n        uint256 length = registeredTokens.length;\n        for (uint256 i = 0; i < length; ++i) {\n            _updatePool(poolInfo[registeredTokens[i]], totalAP);\n        }\n        lastAllPoolUpdate = block.timestamp;\n    }\n\n    // Update reward variables of the given pool to be up-to-date.\n    function _updatePool(PoolInfo storage pool, uint256 _totalAllocPoint)\n        internal\n    {\n        uint256 timestamp = block.timestamp;\n        if (endRewardTime() <= block.timestamp) {\n            timestamp = endRewardTime();\n        }\n        if (timestamp <= pool.lastRewardTime) {\n            return;\n        }\n\n        uint256 lpSupply = pool.totalSupply;\n        if (lpSupply == 0) {\n            pool.lastRewardTime = timestamp;\n            return;\n        }\n\n        uint256 duration = timestamp.sub(pool.lastRewardTime);\n        uint256 rawReward = duration.mul(rewardsPerSecond);\n        if (availableRewards() < rawReward) {\n            rawReward = availableRewards();\n        }\n        uint256 reward = rawReward.mul(pool.allocPoint).div(_totalAllocPoint);\n        accountedRewards = accountedRewards.add(reward);\n        pool.accRewardPerShare = pool.accRewardPerShare.add(\n            reward.mul(ACC_REWARD_PRECISION).div(lpSupply)\n        );\n        pool.lastRewardTime = timestamp;\n    }\n\n    /********************** Emission Calc + Transfer ***********************/\n\n    function pendingRewards(address _user, address[] memory _tokens)\n        public\n        view\n        returns (uint256[] memory)\n    {\n        uint256[] memory claimable = new uint256[](_tokens.length);\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address token = _tokens[i];\n            PoolInfo storage pool = poolInfo[token];\n            UserInfo storage user = userInfo[token][_user];\n            uint256 accRewardPerShare = pool.accRewardPerShare;\n            uint256 lpSupply = pool.totalSupply;\n            if (block.timestamp > pool.lastRewardTime && lpSupply != 0) {\n                uint256 duration = block.timestamp.sub(pool.lastRewardTime);\n                uint256 reward = duration\n                    .mul(rewardsPerSecond)\n                    .mul(pool.allocPoint)\n                    .div(totalAllocPoint);\n                accRewardPerShare = accRewardPerShare.add(\n                    reward.mul(ACC_REWARD_PRECISION).div(lpSupply)\n                );\n            }\n            claimable[i] = user\n                .amount\n                .mul(accRewardPerShare)\n                .div(ACC_REWARD_PRECISION)\n                .sub(user.rewardDebt);\n        }\n        return claimable;\n    }\n\n    // Claim pending rewards for one or more pools.\n    // Rewards are not received directly, they are minted by the rewardMinter.\n    function claim(address _user, address[] memory _tokens) public {\n        if (ELIGIBILITY_ENABLED) {\n            checkAndProcessEligibility(_user);\n        }\n\n        _updateEmissions();\n\n        uint256 pending = userBaseClaimable[_user];\n        userBaseClaimable[_user] = 0;\n        uint256 _totalAllocPoint = totalAllocPoint;\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            require(validRTokens[_tokens[i]]);\n            PoolInfo storage pool = poolInfo[_tokens[i]];\n            require(pool.lastRewardTime > 0, \"pool doesn't exist\");\n            _updatePool(pool, _totalAllocPoint);\n            UserInfo storage user = userInfo[_tokens[i]][_user];\n            uint256 rewardDebt = user.amount.mul(pool.accRewardPerShare).div(\n                ACC_REWARD_PRECISION\n            );\n            pending = pending.add(rewardDebt.sub(user.rewardDebt));\n            user.rewardDebt = rewardDebt;\n            user.lastClaimTime = block.timestamp;\n        }\n\n        _mint(_user, pending);\n\n        if (endRewardTime() < block.timestamp + 5 days) {\n            _emitReserveLow();\n        }\n    }\n\n    function _emitReserveLow() internal {\n        address rdntToken = rewardMinter.getRdntTokenAddress();\n        emit ChefReserveLow(IERC20(rdntToken).balanceOf(address(this)));\n    }\n\n    function _mint(address _user, uint256 _amount) internal {\n        _amount = _sendRadiant(address(_getMfd()), _amount);\n        _getMfd().mint(_user, _amount, true);\n    }\n\n    function setEligibilityExempt(address _contract) public onlyOwner {\n        eligibilityExempt[_contract] = true;\n    }\n\n    /********************** Eligibility + Disqualification ***********************/\n\n    /**\n     * @notice `after` Hook for deposit and borrow update.\n     * @dev important! eligible status can be updated here\n     */\n    function handleActionAfter(\n        address _user,\n        uint256 _balance,\n        uint256 _totalSupply\n    ) external {\n        require(\n            validRTokens[msg.sender] || msg.sender == address(_getLpMfd()),\n            \"!rToken || lpmfd\"\n        );\n\n        if (\n            _user == address(rewardMinter) ||\n            _user == address(_getMfd()) ||\n            _user == address(_getLpMfd()) ||\n            eligibilityExempt[_user]\n        ) {\n            return;\n        }\n        if (ELIGIBILITY_ENABLED) {\n            eligibleDataProvider.refresh(_user);\n            if (eligibleDataProvider.isEligibleForRewards(_user)) {\n                _handleActionAfterForToken(\n                    msg.sender,\n                    _user,\n                    _balance,\n                    _totalSupply\n                );\n            } else {\n                checkAndProcessEligibility(_user);\n            }\n        } else {\n            _handleActionAfterForToken(\n                msg.sender,\n                _user,\n                _balance,\n                _totalSupply\n            );\n        }\n    }\n\n    function _handleActionAfterForToken(\n        address _token,\n        address _user,\n        uint256 _balance,\n        uint256 _totalSupply\n    ) internal {\n        PoolInfo storage pool = poolInfo[_token];\n        require(pool.lastRewardTime > 0, \"pool doesn't exist\");\n        _updateEmissions();\n        _updatePool(pool, totalAllocPoint);\n        UserInfo storage user = userInfo[_token][_user];\n        uint256 amount = user.amount;\n        uint256 accRewardPerShare = pool.accRewardPerShare;\n        if (amount != 0) {\n            uint256 pending = amount\n                .mul(accRewardPerShare)\n                .div(ACC_REWARD_PRECISION)\n                .sub(user.rewardDebt);\n            if (pending != 0) {\n                userBaseClaimable[_user] = userBaseClaimable[_user].add(\n                    pending\n                );\n            }\n        }\n        pool.totalSupply = pool.totalSupply.sub(user.amount);\n        user.amount = _balance;\n        user.rewardDebt = _balance.mul(accRewardPerShare).div(\n            ACC_REWARD_PRECISION\n        );\n        if (user.amount > 0) {\n            user.enterTime = block.timestamp;\n        }\n        pool.totalSupply = pool.totalSupply.add(_balance);\n        if (pool.onwardIncentives != IOnwardIncentivesController(0)) {\n            pool.onwardIncentives.handleAction(\n                _token,\n                _user,\n                _balance,\n                _totalSupply\n            );\n        }\n\n        emit BalanceUpdated(_token, _user, _balance, _totalSupply);\n    }\n\n    /**\n     * @notice `before` Hook for deposit and borrow update.\n     */\n    function handleActionBefore(address _user) external {}\n\n    /**\n     * @notice Hook for lock update.\n     * @dev Called by the locking contracts before locking or unlocking happens\n     */\n    function beforeLockUpdate(address _user) external {\n        require(\n            msg.sender == address(_getLpMfd()) ||\n                msg.sender == address(_getMfd())\n        );\n        if (ELIGIBILITY_ENABLED) {\n            uint256 userBounty = bountyForUser(_user);\n            bool isRelock = !_getLpMfd().autoRelockDisabled(_user);\n            if (userBounty != 0 && !isRelock) {\n                checkAndProcessEligibility(_user);\n            }\n        }\n    }\n\n    /**\n     * @notice Hook for lock update.\n     * @dev Called by the locking contracts after locking or unlocking happens\n     */\n    function afterLockUpdate(address _user) external {\n        require(\n            msg.sender == address(_getLpMfd()) ||\n                msg.sender == address(_getMfd()),\n            \"!lpMFD || !MFD\"\n        );\n\n        if (ELIGIBILITY_ENABLED) {\n            eligibleDataProvider.updatePrice();\n            if (eligibleDataProvider.isEligibleForRewards(_user)) {\n                for (uint256 i = 0; i < registeredTokens.length; i++) {\n                    uint256 newBal = IERC20(registeredTokens[i]).balanceOf(\n                        _user\n                    );\n                    if (newBal != 0) {\n                        _handleActionAfterForToken(\n                            registeredTokens[i],\n                            _user,\n                            newBal,\n                            poolInfo[registeredTokens[i]]\n                                .totalSupply\n                                .add(newBal)\n                                .sub(\n                                    userInfo[registeredTokens[i]][_user].amount\n                                )\n                        );\n                    }\n                }\n            }\n            eligibleDataProvider.refresh(_user);\n        }\n    }\n\n    /********************** Eligibility + Disqualification ***********************/\n\n    function earnedSince(address _user, uint256 lastEligibleTime)\n        public\n        view\n        returns (uint256 earnedAmount)\n    {\n        if (\n            !ELIGIBILITY_ENABLED ||\n            eligibleDataProvider.isEligibleForRewards(_user)\n        ) {\n            return 0;\n        }\n\n        uint256 ineligibleDuration;\n        if (lastEligibleTime < block.timestamp) {\n            ineligibleDuration = block.timestamp.sub(lastEligibleTime);\n        }\n\n        uint256[] memory claimable = pendingRewards(_user, registeredTokens);\n        for (uint256 i = 0; i < claimable.length; i++) {\n            UserInfo storage user = userInfo[registeredTokens[i]][_user];\n            uint256 referenceTime;\n\n            if (user.lastClaimTime > user.enterTime) {\n                referenceTime = user.lastClaimTime;\n            } else {\n                referenceTime = user.enterTime;\n            }\n\n            uint256 referenceDuration = block.timestamp - referenceTime;\n            if (referenceDuration > 0) {\n                uint256 rps = claimable[i].div(referenceDuration);\n                uint256 ineligAmt = ineligibleDuration.mul(rps);\n                if (ineligAmt > claimable[i]) {\n                    ineligAmt = claimable[i];\n                }\n                earnedAmount = earnedAmount.add(ineligAmt);\n            }\n        }\n    }\n\n    function bountyForUser(address _user) public view returns (uint256 bounty) {\n        bounty = earnedSince(\n            _user,\n            eligibleDataProvider.lastEligibleTime(_user)\n        );\n    }\n\n    function harvestIneligible(address _target, uint256 _bounty)\n        internal\n        returns (uint256)\n    {\n        require(ELIGIBILITY_ENABLED, \"!EE\");\n        claimToBase(_target, registeredTokens);\n        if (_bounty < userBaseClaimable[_target]) {\n            userBaseClaimable[_target] = userBaseClaimable[_target].sub(\n                _bounty\n            );\n        } else {\n            _bounty = userBaseClaimable[_target];\n            userBaseClaimable[_target] = 0;\n        }\n        return _bounty;\n    }\n\n    function hasEligibleDeposits(address _user)\n        internal\n        view\n        returns (bool hasDeposits)\n    {\n        for (uint256 i = 0; i < registeredTokens.length; i++) {\n            UserInfo storage user = userInfo[registeredTokens[i]][_user];\n            if (user.amount != 0) {\n                hasDeposits = true;\n                break;\n            }\n        }\n    }\n\n    function checkAndProcessEligibility(address _user, bool _execute)\n        internal\n        returns (uint256 bountyAmt, bool issueBaseBounty)\n    {\n        // for expire DQ\n        bool hasRelock = !_getLpMfd().autoRelockDisabled(_user);\n        bool isMarketDq = eligibleDataProvider.isMarketDisqualified(_user);\n        bool isEligible = eligibleDataProvider.isEligibleForRewards(_user);\n        uint256 lastEligibleTime = eligibleDataProvider.lastEligibleTime(_user);\n        uint256 lastDqTime = eligibleDataProvider.getDqTime(_user);\n        bool hasEligDeposits = hasEligibleDeposits(_user);\n        bool alreadyDqd = lastDqTime != 0;\n\n        // market dq:\n        //    stop all types immediately, BB\n        // timedq:\n        //    if !relock, remove inelig\n        //    if relock, no-op\n        if (!isEligible && !alreadyDqd) {\n            // inelig earned emissions\n            if (isMarketDq && hasEligDeposits) {\n                // all user types DQ when market, will DQ below if _execute\n                issueBaseBounty = true;\n            } else {\n                // expired dq\n                if (\n                    lastEligibleTime != 0 && lastEligibleTime < block.timestamp\n                ) {\n                    if (!hasRelock) {\n                        bountyAmt = bountyForUser(_user);\n                    }\n                }\n            }\n        }\n        if (_execute) {\n            if (bountyAmt != 0 || issueBaseBounty) {\n                require(!isEligible, \"user still eligible\");\n                stopEmissionsFor(_user);\n            }\n\n            if (bountyAmt != 0) {\n                uint256 rewardsRemoved = harvestIneligible(_user, bountyAmt);\n                emit Disqualified(_user, rewardsRemoved);\n            }\n            eligibleDataProvider.refresh(_user);\n        }\n    }\n\n    function checkAndProcessEligibility(address _user) internal {\n        checkAndProcessEligibility(_user, true);\n    }\n\n    function claimBounty(address _user, bool _execute)\n        public\n        returns (uint256 bountyAmt, bool issueBaseBounty)\n    {\n        require(msg.sender == address(bountyManager), \"bounty only\");\n        (bountyAmt, issueBaseBounty) = checkAndProcessEligibility(\n            _user,\n            _execute\n        );\n        if (_execute) {\n            address rdntAddr = rewardMinter.getRdntTokenAddress();\n            IERC20(rdntAddr).safeApprove(address(bountyManager), bountyAmt);\n        }\n    }\n\n    function stopEmissionsFor(address _user) internal {\n        require(ELIGIBILITY_ENABLED, \"!EE\");\n        require(\n            !eligibleDataProvider.isEligibleForRewards(_user),\n            \"user is still eligible\"\n        );\n        uint256 length = registeredTokens.length;\n        for (uint256 i = 0; i < length; ++i) {\n            address token = registeredTokens[i];\n            PoolInfo storage pool = poolInfo[token];\n            UserInfo storage user = userInfo[token][_user];\n\n            _handleActionAfterForToken(\n                token,\n                _user,\n                0,\n                pool.totalSupply.sub(user.amount)\n            );\n        }\n        eligibleDataProvider.setDqTime(_user, block.timestamp);\n    }\n\n    function _sendRadiant(address _user, uint256 _amount)\n        internal\n        returns (uint256)\n    {\n        if (_amount == 0) {\n            return 0;\n        }\n\n        address rdntToken = rewardMinter.getRdntTokenAddress();\n        uint256 chefReserve = IERC20(rdntToken).balanceOf(address(this));\n        if (_amount > chefReserve) {\n            emit ChefReserveEmpty(chefReserve);\n            _pause();\n        } else {\n            IERC20(rdntToken).safeTransfer(_user, _amount);\n        }\n        return _amount;\n    }\n\n    /********************** RDNT Reserve Management ***********************/\n\n    function endRewardTime() public view returns (uint256 timestamp) {\n        uint256 unclaimedRewards = depositedRewards.sub(accountedRewards);\n        uint256 extra = 0;\n        for (uint256 i; i < registeredTokens.length; i++) {\n            if (\n                poolInfo[registeredTokens[i]].lastRewardTime <=\n                lastAllPoolUpdate\n            ) {\n                continue;\n            } else {\n                extra = extra.add(\n                    poolInfo[registeredTokens[i]]\n                        .lastRewardTime\n                        .sub(lastAllPoolUpdate)\n                        .mul(poolInfo[registeredTokens[i]].allocPoint)\n                        .mul(rewardsPerSecond)\n                        .div(totalAllocPoint)\n                );\n            }\n        }\n        if (rewardsPerSecond == 0) {\n            timestamp = uint256(-1);\n        } else {\n            timestamp =\n                (unclaimedRewards + extra).div(rewardsPerSecond) +\n                (lastAllPoolUpdate);\n        }\n    }\n\n    function registerRewardDeposit(uint256 _amount) external onlyOwner {\n        depositedRewards = depositedRewards.add(_amount);\n        _massUpdatePools();\n        if (rewardsPerSecond == 0 && lastRPS > 0) {\n            rewardsPerSecond = lastRPS;\n        }\n    }\n\n    function availableRewards() internal view returns (uint256 amount) {\n        return depositedRewards.sub(accountedRewards);\n    }\n\n    /********************** Helper/Convenience Methods ***********************/\n\n    /**\n     * @notice Claim pending rewards for one or more pools into base claimable.\n     * @dev Rewards are not transferred, just converted into base claimable.\n     */\n    function claimToBase(address _user, address[] memory _tokens) public {\n        uint256 _userBaseClaimable = userBaseClaimable[_user];\n\n        // updatePool must be called after calculation of pending rewards\n        // this is because of reward calculation based on eligibility\n        uint256[] memory pending = pendingRewards(_user, _tokens);\n        _updateEmissions();\n        uint256 _totalAllocPoint = totalAllocPoint;\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            require(validRTokens[_tokens[i]]);\n            UserInfo storage user = userInfo[_tokens[i]][_user];\n            _userBaseClaimable = _userBaseClaimable.add(pending[i]);\n\n            // Set pending reward to zero\n            PoolInfo storage pool = poolInfo[_tokens[i]];\n            _updatePool(pool, _totalAllocPoint);\n            uint256 newDebt = user.amount.mul(pool.accRewardPerShare).div(\n                ACC_REWARD_PRECISION\n            );\n            user.rewardDebt = newDebt;\n            user.lastClaimTime = block.timestamp;\n        }\n        userBaseClaimable[_user] = _userBaseClaimable;\n    }\n\n    function saveUserRewards(address[] memory _users) public {\n        address[] memory _tokens = registeredTokens;\n        for (uint256 i = 0; i < _users.length; i++) {\n            if (_users[i] != address(0)) {\n                claimToBase(_users[i], _tokens);\n            }\n        }\n    }\n\n    function claimAll(address _user) external {\n        claim(_user, registeredTokens);\n    }\n\n    function allPendingRewards(address _user)\n        public\n        view\n        returns (uint256 pending)\n    {\n        pending = userBaseClaimable[_user];\n        uint256[] memory claimable = pendingRewards(_user, registeredTokens);\n        for (uint256 i = 0; i < claimable.length; i++) {\n            pending += claimable[i];\n        }\n    }\n}\n"
    },
    "contracts/staking/LockerList.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../libraries/AddressPagination.sol\";\nimport \"../dependencies/openzeppelin/contracts/Ownable.sol\";\n\n\n/// @title Locker List Contract\n/// @author Radiant\n/// @dev All function calls are currently implemented without side effects\ncontract LockerList is Ownable {\n    using AddressPagination for address[];\n\n    // Users list\n    address[] internal userlist;\n    mapping(address => uint256) internal indexOf;\n    mapping(address => bool) internal inserted;\n\n    /********************** Events ***********************/\n\n    event LockerAdded(address indexed locker);\n    event LockerRemoved(address indexed locker);\n\n    /**\n     * @dev Constructor\n     */\n    constructor() Ownable() {}\n\n    /********************** Lockers list ***********************/\n    /**\n     * @notice Return the number of users.\n     */\n    function lockersCount() external view returns (uint256) {\n        return userlist.length;\n    }\n\n    /**\n     * @notice Return the list of users.\n     */\n    function getUsers(uint256 page, uint256 limit)\n        external\n        view\n        returns (address[] memory)\n    {\n        return userlist.paginate(page, limit);\n    }\n\n    function addToList(address user) external onlyOwner {\n        if (inserted[user] == false) {\n            inserted[user] = true;\n            indexOf[user] = userlist.length;\n            userlist.push(user);\n        }\n\n        emit LockerAdded(user);\n    }\n\n    function removeFromList(address user) external onlyOwner {\n        assert(inserted[user] == true);\n\n        delete inserted[user];\n\n        uint256 index = indexOf[user];\n        uint256 lastIndex = userlist.length - 1;\n        address lastUser = userlist[lastIndex];\n\n        indexOf[lastUser] = index;\n        delete indexOf[user];\n\n        userlist[index] = lastUser;\n        userlist.pop();\n\n        emit LockerRemoved(user);\n    }\n}\n"
    },
    "contracts/staking/MFDHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../interfaces/IAToken.sol\";\nimport \"../interfaces/ILendingPoolAddressesProvider.sol\";\nimport \"../interfaces/ILendingPool.sol\";\nimport \"../interfaces/IFeeDistribution.sol\";\nimport \"../interfaces/IMultiFeeDistribution.sol\";\nimport \"../dependencies/openzeppelin/upgradeability/Initializable.sol\";\nimport \"../dependencies/openzeppelin/upgradeability/OwnableUpgradeable.sol\";\nimport \"../dependencies/openzeppelin/contracts/SafeMath.sol\";\n\n/*\n * Helper functions for MFD compounding + bounties\n */\ncontract MFDHelper is Initializable, OwnableUpgradeable {\n    using SafeMath for uint256;\n\n    event RoutesUpdated(\n        address _token,\n        address[] _routes\n    );\n    event RewardBaseTokensUpdated(\n        address[] _tokens\n    );\n\n    mapping(address => address[]) public rewardToBaseRoute;\n    address public baseToken; // weth\n    address public rdnt;\n    address public addressProvider;\n    address[] public rewardBaseTokens;\n    address public mfd;\n\n    function initialize(\n        address _baseToken,\n        address _rdnt,\n        address _addressProvider\n\n    ) public initializer {\n        __Ownable_init();\n\n        baseToken = _baseToken;\n        rdnt = _rdnt;\n        addressProvider = _addressProvider;\n    }\n\n    function addRewardBaseTokens(address[] memory _tokens) external onlyOwner{\n        rewardBaseTokens = _tokens;\n        emit RewardBaseTokensUpdated(_tokens);\n    }\n\n    function setRoutes(address _token, address[] memory _routes) external onlyOwner{\n        rewardToBaseRoute[_token] = _routes;\n        emit RoutesUpdated(_token, _routes);\n    }\n\n    /**\n     * @notice Bounty amount of user per each reward token\n     * @dev Reward is RDNT and rTokens\n     */\n    function getIneligibleRewards(\n        IFeeDistribution.RewardData[] memory pendingRewards,\n        LockedBalance[] memory locks,\n        uint256 lastClaimTime\n    )\n        external\n        view\n        returns (IFeeDistribution.RewardData[] memory bounties)\n    {\n        uint256 percentOver = _getIneligiblePercent(locks, lastClaimTime);\n\n        bounties = new IFeeDistribution.RewardData[](\n            pendingRewards.length\n        );\n\n        for (uint256 i = 0; i < pendingRewards.length; i++) {\n            address token = pendingRewards[i].token;\n            uint256 amount = pendingRewards[i].amount;\n\n            bounties[i].token = token;\n            // > 100% ineligible time\n            if (percentOver > 10000) {\n                bounties[i].amount = amount;\n            } else {\n                bounties[i].amount = amount.mul(percentOver).div(10000);\n            }\n        }\n    }\n\n    /**\n     * @notice Decide ineligble percent of the user\n     */\n    function _getIneligiblePercent(\n        LockedBalance[] memory locks,\n        uint256 lastClaimTime\n    )\n        internal\n        view\n        returns (uint256 percentOver)\n    {\n        uint256 totalLockAMTxTIME;\n        uint256 expiredAMTxTIME;\n\n        for (uint256 i = 0; i < locks.length; i++) {\n            uint256 startTime = lastClaimTime != 0\n                ? lastClaimTime\n                : locks[i].unlockTime.sub(\n                    locks[i].duration\n                );\n            totalLockAMTxTIME += locks[i].amount.mul(\n                block.timestamp - startTime\n            );\n            if (locks[i].unlockTime < block.timestamp) {\n                uint256 timeDiff = block.timestamp.sub(\n                    locks[i].unlockTime\n                );\n                expiredAMTxTIME += timeDiff.mul(locks[i].amount);\n            }\n        }\n        if (totalLockAMTxTIME != 0) {\n            percentOver = expiredAMTxTIME.mul(10000).div(totalLockAMTxTIME);\n        }\n    }\n\n    function getLendingPool() external view returns (address) {\n        return ILendingPoolAddressesProvider(addressProvider).getLendingPool();\n    }\n\n    function getUnderlying(address token) external view returns (address underlying) {\n        underlying = IAToken(token).UNDERLYING_ASSET_ADDRESS();\n    }\n\n    function getRewardToBaseRoute(address token) external view returns (address[] memory) {\n        return rewardToBaseRoute[token];\n    }\n\n    function getRouteToRdnt() external view returns (address[] memory routeToRdnt) {\n        routeToRdnt = new address[](2);\n        routeToRdnt[0] = baseToken;\n        routeToRdnt[1] = address(rdnt);\n        return routeToRdnt;\n    }\n\n    function quoteSelfCompound() external view returns (uint256 tokensOut) {\n        (bool success, bytes memory data) = address(mfd).staticcall(\n            abi.encodeWithSignature(\n                \"convertPendingRewardsToWeth(address)\",\n                msg.sender\n            )\n        );\n        require(success);\n        tokensOut = abi.decode(data, (uint256));\n    }\n\n    function setMFD(address _mfd) external onlyOwner {\n        mfd = _mfd;\n    }\n}"
    },
    "contracts/staking/MFDPlus.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../staking/MultiFeeDistribution.sol\";\nimport \"../uniswap/periphery/interfaces/IUniswapV2Router02.sol\";\nimport \"../interfaces/ILendingPool.sol\";\nimport \"../interfaces/IFeeDistribution.sol\";\nimport \"../interfaces/ILockZap.sol\";\nimport \"../interfaces/IMFDHelper.sol\";\n\n/// @title MFD Plus Bounty and Compund\n/// @author Radiant\n/// @dev All function calls are currently implemented without side effects\ncontract MFDPlus is MultiFeeDistribution {\n\tusing SafeERC20 for IERC20;\n\tusing SafeMath for uint256;\n\tusing SafeERC20 for IMintableToken;\n\n\t// Option flags\n\tbool public BOUNTY_ENABLED;\n\tbool public AC_ENABLED;\n\n\t// note: relock disabled is default, autocompound default false\n\tmapping(address => bool) public autocompoundEnabled;\n\tmapping(address => uint256) public lastAutocompound;\n\n\t// Compound params\n\tuint256 public autocompoundThreshold;\n\tuint256 public autocompoundFee;\n\tuint256 public compoundAcceptableSlippage;\n\n\t// Contract Addresses\n\taddress public bountyManager;\n\taddress public baseToken; // weth\n\tIMFDHelper public mfdHelper;\n\taddress public uniRouter;\n\n\tevent Compounded(address indexed _user, uint256 _amount);\n\tevent ExpiredLocksRemoved(address indexed _user, uint256 unlockable, uint256 ineligInRdnt);\n\n\t/************************ Setters ************************/\n\n\tfunction setCompoundOptions(\n\t\taddress _baseToken,\n\t\taddress _uniRouter,\n\t\taddress _bountyManager,\n\t\taddress _mfdHelper,\n\t\tbool _bountyEnabled,\n\t\tbool _acEnabled,\n\t\tuint256 _autocompoundThreshold,\n\t\tuint256 _autocompoundFee,\n\t\tuint256 _compoundAcceptableSlippage\n\t) public onlyOwner {\n\t\t// require(_uniRouter != address(0));\n\t\t// require(_baseToken != address(0));\n\t\t// require(_bountyManager != address(0));\n\t\t// require(_mfdHelper != address(0));\n\t\t// require(_autocompoundThreshold != uint256(0));\n\t\t// require(_autocompoundFee != uint256(0));\n\t\t// require(_compoundAcceptableSlippage != uint256(0));\n\n\t\tuniRouter = _uniRouter;\n\t\tbaseToken = _baseToken;\n\t\tbountyManager = _bountyManager;\n\t\tmfdHelper = IMFDHelper(_mfdHelper);\n\t\tautocompoundThreshold = _autocompoundThreshold; //RDNT\n\t\tautocompoundFee = _autocompoundFee; //%\n\t\tcompoundAcceptableSlippage = _compoundAcceptableSlippage;\n\t\tBOUNTY_ENABLED = _bountyEnabled;\n\t\tAC_ENABLED = _acEnabled;\n\t}\n\n\t// function setAutoCompoundAndBountiesEnabled(bool _AC_ENABLED, bool _BOUNTY_ENABLED) public onlyOwner {\n\t// \tAC_ENABLED = _AC_ENABLED;\n\t// \tBOUNTY_ENABLED = _BOUNTY_ENABLED;\n\t// }\n\n\t/**\n\t * @notice set autocompound status for msg.sender\n\t * @param _status AC on?\n\t */\n\tfunction setAutocompound(bool _status) external {\n\t\tautocompoundEnabled[msg.sender] = _status;\n\t}\n\n\t/************************ Execution ************************/\n\n\t/**\n\t * @notice Claims bounty.\n\t * @dev Remove expired locks\n\t * @param _user address.\n\t * @param _execute flag for actual claim.\n\t */\n\tfunction claimBounty(address _user, bool _execute) public returns (uint256 bountyAmt, bool issueBaseBounty) {\n\t\trequire(BOUNTY_ENABLED);\n\t\trequire(msg.sender == address(bountyManager));\n\n\t\tif (_execute) {\n\t\t\t_updateReward(_user);\n\t\t}\n\n\t\t(, uint256 unlockable, , , ) = lockedBalances(_user);\n\t\tif (unlockable == 0) {\n\t\t\treturn (0, false);\n\t\t}\n\n\t\t// If Relock is true, then issue base bounty\n\t\tif (!autoRelockDisabled[_user]) {\n\t\t\tissueBaseBounty = true;\n\t\t}\n\n\t\tif (!_execute) {\n\t\t\t// If relock is false, then calc bounty\n\t\t\tif (autoRelockDisabled[_user]) {\n\t\t\t\tbountyAmt = _wethToRdnt(\n\t\t\t\t\t_convertPendingRewardsToWeth(_user, bountyForUser(_user), _execute, true),\n\t\t\t\t\tfalse\n\t\t\t\t);\n\t\t\t}\n\t\t\t// If relock is true, just issue base bounty\n\t\t\treturn (bountyAmt, issueBaseBounty);\n\t\t} else {\n\t\t\t// If not relock, then remove ineleig plat rev\n\t\t\tif (autoRelockDisabled[_user]) {\n\t\t\t\tbountyAmt = _removeIneligiblePlatRev(_user);\n\t\t\t}\n\t\t\t// Withdraw the user's expried locks\n\t\t\t_withdrawExpiredLocksFor(_user, false, true, userLocks[_user].length);\n\t\t\temit ExpiredLocksRemoved(_user, unlockable, bountyAmt);\n\t\t\trdntToken.safeApprove(address(bountyManager), bountyAmt);\n\t\t}\n\t}\n\n\t/**\n\t * @notice Remove inelgible Platform Revenue.\n\t * @param _user address.\n\t */\n\tfunction _removeIneligiblePlatRev(address _user) internal returns (uint256 ineligRemovedInRdnt) {\n\t\trequire(BOUNTY_ENABLED);\n\n\t\tIFeeDistribution.RewardData[] memory bounties = bountyForUser(_user);\n\t\tIFeeDistribution.RewardData[] memory penalties = new IFeeDistribution.RewardData[](bounties.length);\n\n\t\tfor (uint256 i; i < bounties.length; i++) {\n\t\t\taddress token = bounties[i].token;\n\t\t\tuint256 penalty = bounties[i].amount;\n\t\t\tuint256 reward = rewards[_user][token].div(1e12);\n\n\t\t\t// Avoid cases if reward not enough\n\t\t\tif (reward > penalty) {\n\t\t\t\treward = reward.sub(penalty);\n\t\t\t} else {\n\t\t\t\tpenalty = reward;\n\t\t\t\treward = 0;\n\t\t\t}\n\t\t\trewards[_user][token] = reward.mul(1e12);\n\n\t\t\tpenalties[i].token = token;\n\t\t\tpenalties[i].amount = penalty;\n\n\t\t\temit IneligibleRewardRemoved(_user, token, penalty);\n\t\t}\n\n\t\tineligRemovedInRdnt = _wethToRdnt(_convertPendingRewardsToWeth(_user, penalties, true, false), true);\n\t}\n\n\t/**\n\t * @notice Bounty amount of user per each reward token\n\t * @dev Reward is in rTokens\n\t */\n\tfunction bountyForUser(address _user) public view returns (IFeeDistribution.RewardData[] memory bounties) {\n\t\tIFeeDistribution.RewardData[] memory pending = claimableRewards(_user);\n\t\tLockedBalance[] memory locks = userLocks[_user];\n\t\tbounties = mfdHelper.getIneligibleRewards(pending, locks, lastClaimTime[_user]);\n\t}\n\n\t/**\n\t * @notice Compound user's rewards\n\t * @dev Can be auto compound or manual compound\n\t * @param _user user address\n\t * @param _execute whether to execute txn, or just quote (expected amount out for bounty executor and slippage)\n\t */\n\tfunction claimCompound(address _user, bool _execute) public returns (uint256 tokensOut) {\n\t\tbool isAutoCompound = _user != msg.sender;\n\n\t\tif (isAutoCompound && !autocompoundEnabled[_user]) {\n\t\t\tif (_execute) {\n\t\t\t\trevert();\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tif (_execute) {\n\t\t\t_updateReward(_user);\n\t\t}\n\n\t\tuint256 pendingInRdnt = _wethToRdnt(\n\t\t\t_convertPendingRewardsToWeth(_user, claimableRewards(_user), false, true),\n\t\t\tfalse\n\t\t);\n\n\t\t// user is not eligible for AC: too low pending or too soon since last execute\n\t\tif (\n\t\t\tisAutoCompound &&\n\t\t\t(pendingInRdnt < autocompoundThreshold || block.timestamp.sub(lastAutocompound[_user]) < 1 days)\n\t\t) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t(uint256 wethZapped, uint256 feeInWeth) = _compoundUser(_user, isAutoCompound, _execute);\n\n\t\tif (isAutoCompound) {\n\t\t\ttokensOut = _wethToRdnt(feeInWeth, _execute);\n\t\t\tif (_execute) {\n\t\t\t\trdntToken.safeApprove(address(bountyManager), tokensOut);\n\t\t\t\tlastAutocompound[_user] = block.timestamp;\n\t\t\t}\n\t\t} else {\n\t\t\ttokensOut = wethZapped;\n\t\t}\n\t}\n\n\t/**\n\t * @notice Return expected amout our for a user to compound themself\n\t * @dev has own funcs because claimBounty above doesnt handle slippage\n\t */\n\tfunction quoteSelfCompound() external view returns (uint256 tokensOut) {\n\t\ttokensOut = IMFDHelper(mfdHelper).quoteSelfCompound();\n\t}\n\n\t/**\n\t * @notice Compound msg.sender\n\t * @dev has own funcs because claimBounty above doesnt handle slippage\n\t * @param _quote expected amount WETH out, quoted before this txn\n\t */\n\tfunction selfCompound(uint256 _quote) external returns (uint256 tokensOut) {\n\t\trequire(_quote != 0);\n\t\ttokensOut = claimCompound(msg.sender, true);\n\t\tuint256 minAmountOut = _quote.sub(_quote.mul(compoundAcceptableSlippage).div(100));\n\t\trequire(tokensOut >= minAmountOut);\n\t}\n\n\t/**\n\t * @notice Compound: zap user pending rewards into locked LP\n\t * @dev has own funcs because claimBounty above doesnt handle slippage\n\t * @param _user address\n\t * @param _takeFee whether to remove % fee from converted WETH to pay Bounty hunter\n\t * @param _execute execute txn or just quote\n\t */\n\tfunction _compoundUser(\n\t\taddress _user,\n\t\tbool _takeFee,\n\t\tbool _execute\n\t) internal returns (uint256 wethZapped, uint256 feeInWeth) {\n\t\twethZapped = _convertPendingRewardsToWeth(_user, claimableRewards(_user), _execute, true);\n\n\t\tif (_takeFee) {\n\t\t\tfeeInWeth = wethZapped.mul(autocompoundFee).div(100);\n\t\t\twethZapped = wethZapped.sub(feeInWeth);\n\t\t}\n\n\t\tif (_execute) {\n\t\t\tIERC20(baseToken).safeApprove(lockZap, wethZapped);\n\t\t\tILockZap(lockZap).zapOnBehalf(false, wethZapped, 0, _user);\n\t\t\tlastClaimTime[_user] = block.timestamp;\n\n\t\t\temit Compounded(_user, wethZapped);\n\t\t}\n\t}\n\n\t/**\n\t * @notice Bounty amount of user per each reward token\n\t * @dev returns total WETH amount from swapping all token balances in _pending array\n\t * @param _user address\n\t * @param _pending array of {rToken, amount}. could be their pending, or an array of penalties already\n\t * removed from their pending\n\t * @param _execute execute txn or just quote\n\t * @param _decrementUserBalance for each rToken amount in _pending, remove from their pending balance\n\t */\n\tfunction _convertPendingRewardsToWeth(\n\t\taddress _user,\n\t\tIFeeDistribution.RewardData[] memory _pending,\n\t\tbool _execute,\n\t\tbool _decrementUserBalance\n\t) internal returns (uint256 wethOut) {\n\t\tfor (uint256 i = 0; i < _pending.length; i++) {\n\t\t\taddress token = _pending[i].token;\n\t\t\tuint256 removedAmount = _pending[i].amount;\n\t\t\tif (removedAmount == 0 || IERC20(token).balanceOf(address(this)) == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\taddress underlying = mfdHelper.getUnderlying(token);\n\n\t\t\tif (_execute) {\n\t\t\t\tuint256 pendingReward = rewards[_user][token].div(1e12);\n\n\t\t\t\tif (_decrementUserBalance) {\n\t\t\t\t\trequire(pendingReward >= removedAmount);\n\t\t\t\t\trewards[_user][token] = rewards[_user][token].sub(removedAmount.mul(1e12));\n\t\t\t\t}\n\t\t\t\trewardData[token].balance = rewardData[token].balance.sub(removedAmount);\n\t\t\t\temit RewardPaid(_user, token, removedAmount);\n\n\t\t\t\tILendingPool lendingPool = ILendingPool(mfdHelper.getLendingPool());\n\t\t\t\tremovedAmount = lendingPool.withdraw(underlying, removedAmount, address(this));\n\t\t\t}\n\n\t\t\tif (underlying == baseToken) {\n\t\t\t\twethOut = wethOut.add(removedAmount);\n\t\t\t} else {\n\t\t\t\tif (_execute) {\n\t\t\t\t\tIERC20(underlying).safeApprove(uniRouter, removedAmount);\n\t\t\t\t\tuint256[] memory amounts = IUniswapV2Router02(uniRouter).swapExactTokensForTokens(\n\t\t\t\t\t\tremovedAmount,\n\t\t\t\t\t\t0, // slippage handled after this function\n\t\t\t\t\t\tmfdHelper.getRewardToBaseRoute(underlying),\n\t\t\t\t\t\taddress(this),\n\t\t\t\t\t\tblock.timestamp + 10\n\t\t\t\t\t);\n\t\t\t\t\twethOut = wethOut.add(amounts[amounts.length - 1]);\n\t\t\t\t} else {\n\t\t\t\t\tuint256[] memory amounts = IUniswapV2Router02(uniRouter).getAmountsOut(\n\t\t\t\t\t\tremovedAmount, //amt in\n\t\t\t\t\t\tmfdHelper.getRewardToBaseRoute(underlying) //path\n\t\t\t\t\t);\n\t\t\t\t\twethOut = wethOut.add(amounts[amounts.length - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @notice shortcut for above, using users claimable rewards\n\t * @param _user address\n\t */\n\tfunction convertPendingRewardsToWeth(address _user) public returns (uint256 wethOut) {\n\t\treturn _convertPendingRewardsToWeth(_user, claimableRewards(_user), false, false);\n\t}\n\n\t/**\n\t * @notice given WETH, return RDNT\n\t * @param _wethIn WETH in\n\t * @param _execute whether to execute swap, or return expected amt out\n\t */\n\tfunction _wethToRdnt(uint256 _wethIn, bool _execute) internal returns (uint256 rdntOut) {\n\t\tif (_wethIn != 0) {\n\t\t\tif (_execute) {\n\t\t\t\tIERC20(baseToken).safeApprove(uniRouter, _wethIn);\n\t\t\t\tuint256[] memory amounts = IUniswapV2Router02(uniRouter).swapExactTokensForTokens(\n\t\t\t\t\t_wethIn,\n\t\t\t\t\t0,\n\t\t\t\t\tmfdHelper.getRouteToRdnt(),\n\t\t\t\t\taddress(this),\n\t\t\t\t\tblock.timestamp + 600\n\t\t\t\t);\n\t\t\t\trdntOut = amounts[amounts.length - 1];\n\t\t\t} else {\n\t\t\t\tuint256[] memory amounts = IUniswapV2Router02(uniRouter).getAmountsOut(\n\t\t\t\t\t_wethIn, //amt in\n\t\t\t\t\tmfdHelper.getRouteToRdnt()\n\t\t\t\t);\n\t\t\t\trdntOut = amounts[amounts.length - 1];\n\t\t\t}\n\t\t}\n\t}\n}\n"
    },
    "contracts/staking/MFDstats.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\nimport \"../dependencies/openzeppelin/contracts/IERC20Detailed.sol\";\nimport \"../dependencies/openzeppelin/contracts/IERC20.sol\";\nimport \"../dependencies/openzeppelin/upgradeability/Initializable.sol\";\nimport \"../dependencies/openzeppelin/upgradeability/OwnableUpgradeable.sol\";\nimport \"../misc/interfaces/IAaveOracle.sol\";\nimport \"../dependencies/openzeppelin/contracts/SafeMath.sol\";\nimport \"../interfaces/IChainlinkAggregator.sol\";\nimport {IMultiFeeDistribution} from '../interfaces/IMultiFeeDistribution.sol';\nimport {IMiddleFeeDistribution} from '../interfaces/IMiddleFeeDistribution.sol';\n\ncontract MFDstats is Initializable, OwnableUpgradeable {\n    using SafeMath for uint256;\n\n    address private _aaveOracle;\n    address private _emissionsReserve;\n    address private _mfd;\n\n    struct MFDTransfer {\n        uint256 timestamp;\n        uint256 usdValue;\n        uint256 lpUsdValue;\n    }\n\n    struct AssetAddresses {\n        uint256 count;\n        mapping(uint256 => address) assetAddress;\n        mapping(uint256 => string) assetSymbol;\n        mapping(address => uint256) indexOfAddress;\n    }\n\n    struct TrackPerAsset {\n        address assetAddress;\n        string assetSymbol;\n        uint256 usdValue;\n        uint256 lpUsdValue;\n    }\n\n    struct AddTransferParam {\n        address asset;\n        uint256 amount;\n        address treasury;\n    }\n\n    AssetAddresses private allAddresses;\n\n    mapping(address => uint256) private _totalPerAsset;\n    mapping(address => uint256) private _lpTotalPerAsset;\n    mapping(address => MFDTransfer[]) private mfdTransfersPerAsset;\n\n    IMiddleFeeDistribution public middleFee;\n\n    uint256 public constant DAY_SECONDS = 86400;\n    uint8 public constant DECIMALS = 18;\n    uint256 public constant RATIO_DIVISOR = 10000;\n\n    address[] public vests; \n\n    event NewTransferAdded(address indexed asset, uint256 usdValue, uint256 lpUsdValue);\n\n    function initialize(\n        address aaveOracle, address emissionsReserve\n    ) public initializer {\n        _aaveOracle = aaveOracle;\n        _emissionsReserve = emissionsReserve;\n        __Ownable_init();\n    }\n\n    function getPriceDecimal (address assetAddress) external view returns (uint8) {\n        address sourceOfAsset = IAaveOracle(_aaveOracle).getSourceOfAsset(\n            assetAddress\n        );\n        uint8 priceDecimal = IChainlinkAggregator(sourceOfAsset).decimals();\n        return priceDecimal;\n    }\n\n    function setMiddleFee(IMiddleFeeDistribution _middleFee) external onlyOwner {\n        middleFee = _middleFee;\n    }\n\n    function addTransfer(AddTransferParam memory param) external {\n        require(middleFee.isRewardToken(msg.sender), \"!rToken\");\n\n        uint256 lpLockingRewardRatio = IMiddleFeeDistribution(param.treasury).lpLockingRewardRatio();\n        uint256 operationExpenseRatio = IMiddleFeeDistribution(param.treasury).operationExpenseRatio();\n        address operationExpenses = IMiddleFeeDistribution(param.treasury).operationExpenses();\n        uint256 assetPrice = IAaveOracle(_aaveOracle).getAssetPrice(\n            param.asset\n        );\n        address sourceOfAsset = IAaveOracle(_aaveOracle).getSourceOfAsset(\n            param.asset\n        );\n        \n        if (operationExpenses != address(0) && operationExpenseRatio > 0) {\n            uint256 opExAmount = param.amount.mul(operationExpenseRatio).div(RATIO_DIVISOR);\n            param.amount = param.amount.sub(opExAmount);\n        }\n        uint8 priceDecimal = IChainlinkAggregator(sourceOfAsset).decimals();\n        uint8 assetDecimals = IERC20Detailed(param.asset).decimals();\n        uint256 usdValue = assetPrice\n            .mul(param.amount)\n            .mul(10**DECIMALS)\n            .div(10**priceDecimal)\n            .div(10**assetDecimals);\n        uint256 lpUsdValue = usdValue.mul(lpLockingRewardRatio).div(RATIO_DIVISOR);\n        usdValue = usdValue.sub(lpUsdValue);\n\n        uint256 index;\n\n        if (allAddresses.indexOfAddress[param.asset] == 0) {\n            allAddresses.count++;\n            allAddresses.assetAddress[allAddresses.count] = param.asset;\n            allAddresses.assetSymbol[allAddresses.count] = IERC20Detailed(\n                param.asset\n            ).symbol();\n            allAddresses.indexOfAddress[param.asset] = allAddresses.count;\n        }\n        _totalPerAsset[param.asset] = _totalPerAsset[param.asset].add(usdValue);\n        _lpTotalPerAsset[param.asset] = _lpTotalPerAsset[param.asset].add(\n            lpUsdValue\n        );\n\n        for (uint256 i = 0; i < mfdTransfersPerAsset[param.asset].length; i++) {\n            if (\n                block.timestamp.sub(\n                    mfdTransfersPerAsset[param.asset][i].timestamp\n                ) <= DAY_SECONDS\n            ) {\n                index = i;\n                break;\n            }\n        }\n\n        for (\n            uint256 i = index;\n            i < mfdTransfersPerAsset[param.asset].length;\n            i++\n        ) {\n            mfdTransfersPerAsset[param.asset][i - index] = mfdTransfersPerAsset[\n                param.asset\n            ][i];\n        }\n\n        for (uint256 i = 0; i < index; i++) {\n            mfdTransfersPerAsset[param.asset].pop();\n        }\n\n        mfdTransfersPerAsset[param.asset].push(\n            MFDTransfer(block.timestamp, usdValue, lpUsdValue)\n        );\n\n        emit NewTransferAdded(param.asset, usdValue, lpUsdValue);\n    }\n\n    function getTotal() external view returns (TrackPerAsset[] memory) {\n        TrackPerAsset[] memory totalPerAsset = new TrackPerAsset[](\n            allAddresses.count + 1\n        );\n        uint256 total;\n        uint256 lpTotal;\n        for (uint256 i = 1; i <= allAddresses.count; i++) {\n            total = total.add(_totalPerAsset[allAddresses.assetAddress[i]]);\n            lpTotal = lpTotal.add(\n                _lpTotalPerAsset[allAddresses.assetAddress[i]]\n            );\n\n            totalPerAsset[i] = TrackPerAsset(\n                allAddresses.assetAddress[i],\n                allAddresses.assetSymbol[i],\n                _totalPerAsset[allAddresses.assetAddress[i]],\n                _lpTotalPerAsset[allAddresses.assetAddress[i]]\n            );\n        }\n        totalPerAsset[0] = TrackPerAsset(address(0), \"\", total, lpTotal);\n        return totalPerAsset;\n    }\n\n    function getLastDayTotal() external view returns (TrackPerAsset[] memory) {\n        TrackPerAsset[] memory lastDayTotalPerAsset = new TrackPerAsset[](\n            allAddresses.count + 1\n        );\n        uint256 lastdayTotal;\n        uint256 lpLastDayTotal;\n\n        for (uint256 i = 1; i <= allAddresses.count; i++) {\n            uint256 assetLastDayTotal;\n            uint256 lpAssetLastDayTotal;\n\n            assert(mfdTransfersPerAsset[allAddresses.assetAddress[i]].length > 0);\n            for (\n                uint256 j = mfdTransfersPerAsset[\n                    allAddresses.assetAddress[i]\n                ].length.sub(1);\n                ;\n                j--\n            ) {\n                if (\n                    block.timestamp.sub(\n                        mfdTransfersPerAsset[allAddresses.assetAddress[i]][\n                            j\n                        ].timestamp\n                    ) <= DAY_SECONDS\n                ) {\n                    assetLastDayTotal = assetLastDayTotal.add(\n                        mfdTransfersPerAsset[allAddresses.assetAddress[i]][\n                            j\n                        ].usdValue\n                    );\n                    lpAssetLastDayTotal = lpAssetLastDayTotal.add(\n                        mfdTransfersPerAsset[allAddresses.assetAddress[i]][\n                            j\n                        ].lpUsdValue\n                    );\n                } else {\n                    break;\n                }\n                if (j == 0) break;\n            }\n\n            lastdayTotal = lastdayTotal.add(assetLastDayTotal);\n            lpLastDayTotal = lpLastDayTotal.add(lpAssetLastDayTotal);\n            lastDayTotalPerAsset[i] = TrackPerAsset(\n                allAddresses.assetAddress[i],\n                allAddresses.assetSymbol[i],\n                assetLastDayTotal,\n                lpAssetLastDayTotal\n            );\n        }\n\n        lastDayTotalPerAsset[0] = TrackPerAsset(\n            address(0),\n            \"\",\n            lastdayTotal,\n            lpLastDayTotal\n        );\n\n        return lastDayTotalPerAsset;\n    }\n\n    function calcBalanceSum (\n        address daoTreasuryAddress,\n        address chef,\n        address migration,\n        address bountyManager,\n        address mfd,\n        address emissionsReserve\n    ) internal view returns (uint256) {\n        IERC20 rdnt = IERC20(middleFee.getRdntTokenAddress());\n        uint256 daoBalance = rdnt.balanceOf(daoTreasuryAddress);\n        uint256 chefBalance = rdnt.balanceOf(chef);\n        uint256 migrationBalance = rdnt.balanceOf(migration);\n        uint256 bountyBalance = rdnt.balanceOf(bountyManager);\n        // mfd balance\n        uint256 mfdLockedBalance = rdnt.balanceOf(mfd);\n        uint256 emissionsReserveBalance = rdnt.balanceOf(emissionsReserve);\n\n        return daoBalance\n            + chefBalance\n            + migrationBalance\n            + bountyBalance\n            + mfdLockedBalance\n            + emissionsReserveBalance;\n    }\n\n    function calcVestsBalances() internal view returns(uint256) {\n        uint256 total;\n        IERC20 rdnt = IERC20(middleFee.getRdntTokenAddress());\n        for(uint256 i = 0; i < vests.length; i++) {\n            total = total.add(rdnt.balanceOf(vests[i]));\n        }\n        return total;\n    }\n\n    function getCirculatingSupply(\n        address _chef,\n        address _bountyManager,\n        address _migration\n    ) external view returns (uint256) {\n        IMultiFeeDistribution mfd = IMultiFeeDistribution(middleFee.getMultiFeeDistributionAddress());\n        IMultiFeeDistribution lpMfd = IMultiFeeDistribution(middleFee.getLPFeeDistributionAddress());\n        IERC20 rdnt = IERC20(middleFee.getRdntTokenAddress());\n\n        address daoTreasuryAddress = mfd.daoTreasury();\n        uint256 balanceSum = calcBalanceSum(\n            daoTreasuryAddress,\n            _chef,\n            _migration,\n            _bountyManager,\n            address(mfd),\n            _emissionsReserve\n        );\n        uint256 vestsBal = calcVestsBalances();\n        // lp fee distribution balance\n        IERC20 lpToken = IERC20(lpMfd.stakingToken());\n        uint256 lockedLPAmount = lpToken.balanceOf(address(lpMfd));\n        uint256 lpTotalSupply = lpToken.totalSupply();\n        uint256 lpfdLockedBalance;\n\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(address(lpToken)).getReserves();\n        if (IUniswapV2Pair(address(lpToken)).token0() == address(rdnt)) {\n            lpfdLockedBalance = reserve0 * lockedLPAmount / lpTotalSupply;\n        } else {\n            lpfdLockedBalance = reserve1 * lockedLPAmount / lpTotalSupply;\n        }\n        //total supply\n        uint256 totalSupply = rdnt.totalSupply();\n        uint256 totalBalance = lpfdLockedBalance.add(balanceSum).add(vestsBal);\n        if(totalSupply >= totalBalance) return totalSupply.sub(totalBalance);\n        else return 0;\n    }\n\n    function addVest (address _vest) external onlyOwner {\n        vests.push(_vest);\n    }\n}\n"
    },
    "contracts/staking/MiddleFeeDistribution.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../interfaces/IMiddleFeeDistribution.sol\";\nimport \"../interfaces/IMultiFeeDistribution.sol\";\nimport \"../interfaces/IMintableToken.sol\";\n\nimport \"../dependencies/openzeppelin/contracts/IERC20.sol\";\nimport \"../dependencies/openzeppelin/contracts/IERC20Detailed.sol\";\nimport \"../dependencies/openzeppelin/contracts/SafeERC20.sol\";\nimport \"../dependencies/openzeppelin/contracts/SafeMath.sol\";\nimport \"../dependencies/openzeppelin/upgradeability/Initializable.sol\";\nimport \"../dependencies/openzeppelin/upgradeability/OwnableUpgradeable.sol\";\n\n/// @title Fee distributor inside \n/// @author Radiant\n/// @dev All function calls are currently implemented without side effects\ncontract MiddleFeeDistribution is IMiddleFeeDistribution, Initializable, OwnableUpgradeable {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    /// @notice RDNT token\n    IMintableToken public rdntToken;\n\n    /// @notice Fee distributor contract for lp locking\n    IMultiFeeDistribution public lpFeeDistribution;\n\n    /// @notice Fee distributor contract for earnings and RDNT lockings\n    IMultiFeeDistribution public multiFeeDistribution;\n    \n    /// @notice Reward ratio for lp locking in bips\n    uint256 public override lpLockingRewardRatio;\n\n    /// @notice Reward ratio for operation expenses\n    uint256 public override operationExpenseRatio;\n\n    uint256 public constant RATIO_DIVISOR = 10000;\n\n    mapping(address => bool) public override isRewardToken;\n\n    /// @notice Operation Expense account\n    address public override operationExpenses;\n\n    /// @notice Admin address\n    address public admin;\n\n    // MFDStats address\n    address internal _mfdStats;\n\n    /********************** Events ***********************/\n\n    /// @notice Emitted when ERC20 token is recovered\n    event Recovered(address token, uint256 amount);\n\n    /// @notice Emitted when reward token is forwarded\n    event ForwardReward(address token, uint256 amount);\n\n    /// @notice Emitted when OpEx info is updated\n    event SetOperationExpenses(address opEx, uint256 ratio);\n\n    /// @notice Emitted when LP locking reward ratio is set \n    event LpLockingRewardRatioUpdated(uint256 _lpLockingRewardRatio);\n\n    /// @notice Emitted when lp fee distribution is set\n    event LPFeeDistributionUpdated(IMultiFeeDistribution _lpFeeDistribution);\n\n    /// @notice Emitted when operation expenses is set\n    event OperationExpensesUpdated(address _operationExpenses, uint256 _operationExpenseRatio);\n\n    /**\n    * @dev Throws if called by any account other than the admin or owner.\n    */\n    modifier onlyAdminOrOwner() {\n        require(admin == _msgSender() || owner() == _msgSender(), 'caller is not the admin or owner');\n        _;\n    }\n\n    function initialize(\n        address _rdntToken,\n        address mfdStats,\n        IMultiFeeDistribution _lpFeeDistribution,\n        IMultiFeeDistribution _multiFeeDistribution\n    ) public initializer {\n        __Ownable_init();\n\n        rdntToken = IMintableToken(_rdntToken);\n        _mfdStats = mfdStats;\n        lpFeeDistribution = _lpFeeDistribution;\n        multiFeeDistribution = _multiFeeDistribution;\n\n        lpLockingRewardRatio = 10000;\n        admin = msg.sender;\n    }\n\n    function getMFDstatsAddress () external view override returns (address) {\n        return _mfdStats;\n    }\n\n    function getRdntTokenAddress () external view override returns (address) {\n        return address(rdntToken);\n    }\n\n    function getLPFeeDistributionAddress () external view override returns (address) {\n        return address(lpFeeDistribution);\n    }\n\n    function getMultiFeeDistributionAddress () external view override returns (address) {\n        return address(multiFeeDistribution);\n    }\n\n    /**\n     * @notice Returns lock information of a user.\n     * @dev It currently returns just MFD infos.\n     */\n    function lockedBalances(\n        address user\n    ) view external override returns (\n        uint256 total,\n        uint256 unlockable,\n        uint256 locked,\n        uint256 lockedWithMultiplier,\n        LockedBalance[] memory lockData\n    ) {\n        return multiFeeDistribution.lockedBalances(user);\n    }\n    \n    /**\n     * @notice Set reward ratio for lp token locking\n     */\n    function setLpLockingRewardRatio(uint256 _lpLockingRewardRatio) external onlyAdminOrOwner {\n        require(_lpLockingRewardRatio <= RATIO_DIVISOR, \"Invalid ratio\");\n        lpLockingRewardRatio = _lpLockingRewardRatio;\n        emit LpLockingRewardRatioUpdated(_lpLockingRewardRatio);\n    }\n    \n    /**\n     * @notice Set lp fee distribution contract\n     */\n    function setLPFeeDistribution(IMultiFeeDistribution _lpFeeDistribution) external onlyAdminOrOwner {\n        lpFeeDistribution = _lpFeeDistribution;\n        emit LPFeeDistributionUpdated(_lpFeeDistribution);\n    }\n    \n    /**\n     * @notice Set operation expenses account\n     */\n    function setOperationExpenses(address _operationExpenses, uint256 _operationExpenseRatio) external onlyAdminOrOwner {\n        require(_operationExpenseRatio <= RATIO_DIVISOR, \"Invalid ratio\");\n        operationExpenses = _operationExpenses;\n        operationExpenseRatio = _operationExpenseRatio;\n        emit OperationExpensesUpdated(_operationExpenses, _operationExpenseRatio);\n    }\n\n    /**\n     * @notice Add a new reward token to be distributed to stakers\n     */\n    function addReward(address _rewardsToken) external override onlyAdminOrOwner {\n        multiFeeDistribution.addReward(_rewardsToken);\n        lpFeeDistribution.addReward(_rewardsToken);\n        isRewardToken[_rewardsToken] = true;\n    }\n\n    /**\n     * @notice Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders\n     */\n    function forwardReward(address[] memory _rewardTokens) external override {\n        require(\n            msg.sender == address(lpFeeDistribution) ||\n            msg.sender == address(multiFeeDistribution)\n        );\n        \n        for (uint256 i = 0; i < _rewardTokens.length; i += 1) {\n            uint256 total = IERC20(_rewardTokens[i]).balanceOf(address(this));\n            \n            if (operationExpenses != address(0) && operationExpenseRatio != 0) {\n                uint256 opExAmount = total.mul(operationExpenseRatio).div(RATIO_DIVISOR);\n                if (opExAmount != 0) {\n                    IERC20(_rewardTokens[i]).safeTransfer(operationExpenses, opExAmount);\n                }\n                total = total.sub(opExAmount);\n            }\n            total = IERC20(_rewardTokens[i]).balanceOf(address(this));\n            uint256 lpReward = total.mul(lpLockingRewardRatio).div(RATIO_DIVISOR);\n            if (lpReward != 0) {\n                IERC20(_rewardTokens[i]).safeTransfer(address(lpFeeDistribution), lpReward);\n            }\n            uint256 rdntReward = IERC20(_rewardTokens[i]).balanceOf(address(this));\n            if (rdntReward != 0) {\n                IERC20(_rewardTokens[i]).safeTransfer(address(multiFeeDistribution), rdntReward);\n            }\n        }\n    }\n\n    /**\n     * @notice Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders\n     */\n    function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyOwner {\n        IERC20(tokenAddress).safeTransfer(owner(), tokenAmount);\n        emit Recovered(tokenAddress, tokenAmount);\n    }\n}\n"
    },
    "contracts/staking/MultiFeeDistribution.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../interfaces/IChefIncentivesController.sol\";\nimport \"../interfaces/IMiddleFeeDistribution.sol\";\nimport \"../interfaces/IBounty.sol\";\nimport {IMultiFeeDistribution} from \"../interfaces/IMultiFeeDistribution.sol\";\nimport \"../interfaces/IMintableToken.sol\";\nimport \"../interfaces/ILockerList.sol\";\nimport \"../interfaces/LockedBalance.sol\";\nimport \"../interfaces/IChainlinkAggregator.sol\";\nimport \"../interfaces/IPriceProvider.sol\";\nimport \"../dependencies/openzeppelin/contracts/IERC20.sol\";\nimport \"../dependencies/openzeppelin/contracts/IERC20Detailed.sol\";\nimport \"../dependencies/openzeppelin/contracts/SafeERC20.sol\";\nimport \"../dependencies/openzeppelin/contracts/SafeMath.sol\";\nimport \"../dependencies/openzeppelin/upgradeability/Initializable.sol\";\nimport \"../dependencies/openzeppelin/upgradeability/OwnableUpgradeable.sol\";\n\n/// @title Multi Fee Distribution Contract\n/// @author Radiant\n/// @dev All function calls are currently implemented without side effects\ncontract MultiFeeDistribution is IMultiFeeDistribution, Initializable, OwnableUpgradeable {\n\tusing SafeMath for uint256;\n\tusing SafeERC20 for IERC20;\n\tusing SafeERC20 for IMintableToken;\n\n\tstruct Reward {\n\t\tuint256 periodFinish;\n\t\tuint256 rewardPerSecond;\n\t\tuint256 lastUpdateTime;\n\t\tuint256 rewardPerTokenStored;\n\t\t// tracks already-added balances to handle accrued interest in aToken rewards\n\t\t// for the stakingToken this value is unused and will always be 0\n\t\tuint256 balance;\n\t}\n\n\tstruct Balances {\n\t\tuint256 total; // sum of earnings and lockings; no use when LP and RDNT is different\n\t\tuint256 unlocked; // RDNT token\n\t\tuint256 locked; // LP token or RDNT token\n\t\tuint256 lockedWithMultiplier; // Multiplied locked amount\n\t\tuint256 earned; // RDNT token\n\t}\n\n\taddress private _priceProvider;\n\n\t/********************** Constants ***********************/\n\n\tuint256 public constant QUART = 25000; //  25%\n\tuint256 public constant HALF = 65000; //  65%\n\tuint256 public constant WHOLE = 100000; // 100%\n\n\t/// @notice Proportion of burn amount\n\tuint256 public BURN;\n\n\t/// @notice Duration that rewards are streamed over\n\tuint256 public REWARDS_DURATION;\n\n\t/// @notice Duration that rewards loop back\n\tuint256 public REWARDS_LOOKBACK;\n\n\t/// @notice Multiplier for earnings, fixed to 1\n\t// uint256 public constant DEFAULT_MUTLIPLIER = 1;\n\n\t/// @notice Default lock index\n\tuint256 public constant DEFAULT_LOCK_INDEX = 1;\n\n\t/// @notice Duration of lock/earned penalty period, used for earnings\n\tuint256 public DEFAULT_LOCK_DURATION;\n\n\t/// @notice Duration of vesting RDNT\n\tuint256 public VEST_DURATION;\n\n\t/********************** Contract Addresses ***********************/\n\n\t/// @notice Address of Middle Fee Distribution Contract\n\tIMiddleFeeDistribution public middleFeeDistribution;\n\n\t/// @notice Address of CIC contract\n\tIChefIncentivesController public incentivesController;\n\n\t/// @notice Address of RDNT\n\tIMintableToken public rdntToken;\n\n\t/// @notice Address of LP token\n\taddress public override stakingToken;\n\n\t// Address of Lock Zapper\n\taddress internal lockZap;\n\n\t/********************** Lock & Earn Info ***********************/\n\n\t// Private mappings for balance data\n\tmapping(address => Balances) private balances;\n\tmapping(address => LockedBalance[]) internal userLocks;\n\tmapping(address => LockedBalance[]) private userEarnings;\n\n\t/// @notice Total locked value\n\tuint256 public lockedSupply;\n\n\t/// @notice Total locked value in multipliers\n\tuint256 public lockedSupplyWithMultiplier;\n\n\t// Time lengths\n\tuint256[] internal lockPeriod;\n\n\t// Multipliers\n\tuint256[] internal rewardMultipliers;\n\n\t/********************** Reward Info ***********************/\n\n\t/// @notice Reward tokens being distributed\n\taddress[] public rewardTokens;\n\n\t/// @notice Reward data per token\n\tmapping(address => Reward) public rewardData;\n\n\t/// @notice user -> reward token -> rpt; RPT for paid amount\n\tmapping(address => mapping(address => uint256)) public userRewardPerTokenPaid;\n\n\t/// @notice user -> reward token -> amount; used to store reward amount\n\tmapping(address => mapping(address => uint256)) public rewards;\n\n\t/********************** Other Info ***********************/\n\n\t/// @notice DAO wallet\n\taddress public override daoTreasury;\n\n\t/// @notice treasury wallet\n\taddress public STARFLEET_TREASURY;\n\n\t/// @notice Addresses approved to call mint\n\tmapping(address => bool) public minters;\n\n\t// Addresses to relock\n\tmapping(address => bool) public override autoRelockDisabled;\n\n\t// Default lock index for relock\n\tmapping(address => uint256) public override defaultLockIndex;\n\n\t/// @notice Flag to prevent more minter addings\n\tbool public mintersAreSet;\n\n\t// Users list\n\tILockerList public userlist;\n\n\tmapping(address => uint256) public lastClaimTime;\n\n\taddress public BountyManager;\n\n\t// to prevent unbounded lock length iteration during withdraw/clean\n\n\t/********************** Events ***********************/\n\n\tevent RewardAdded(uint256 reward);\n\tevent Staked(address indexed user, uint256 amount, bool locked);\n\tevent Locked(address indexed user, uint256 usdValue, bool isLP);\n\tevent Withdrawn(address indexed user, address indexed token, uint256 receivedAmount, uint256 penalty, uint256 burn);\n\tevent RewardPaid(address indexed user, address indexed rewardToken, uint256 reward);\n\tevent IneligibleRewardRemoved(address indexed user, address indexed rewardToken, uint256 reward);\n\tevent RewardsDurationUpdated(address token, uint256 newDuration);\n\tevent Recovered(address token, uint256 amount);\n\tevent Relocked(address indexed user, uint256 amount, uint256 lockIndex);\n\n\t/**\n\t * @dev Constructor\n\t *  First reward MUST be the RDNT token or things will break\n\t *  related to the 50% penalty and distribution to locked balances.\n\t * @param _rdntToken RDNT token address.\n\t * @param _rewardsDuration set reward stream time.\n\t * @param _rewardsLookback reward lookback\n\t * @param _lockDuration lock duration\n\t */\n\tfunction initialize(\n\t\taddress _rdntToken,\n\t\taddress _lockZap,\n\t\taddress _dao,\n\t\taddress _userlist,\n\t\taddress priceProvider,\n\t\tuint256 _rewardsDuration,\n\t\tuint256 _rewardsLookback,\n\t\tuint256 _lockDuration,\n\t\tuint256 _burnRatio,\n\t\tuint256 _vestDuration\n\t) public initializer {\n\t\t// require(_rdntToken != address(0));\n\t\t// require(_lockZap != address(0));\n\t\t// require(_dao != address(0));\n\t\t// require(_userlist != address(0));\n\t\t// require(priceProvider != address(0));\n\t\t// require(_rewardsDuration != uint256(0));\n\t\t// require(_rewardsLookback != uint256(0));\n\t\t// require(_lockDuration != uint256(0));\n\t\t// require(_vestDuration != uint256(0));\n\t\t// require(_burnRatio <= WHOLE);\n\t\t// require(_rewardsLookback <= _rewardsDuration);\n\n\t\t__Ownable_init();\n\n\t\trdntToken = IMintableToken(_rdntToken);\n\t\tlockZap = _lockZap;\n\t\tdaoTreasury = _dao;\n\t\t_priceProvider = priceProvider;\n\t\tuserlist = ILockerList(_userlist);\n\t\trewardTokens.push(_rdntToken);\n\t\trewardData[_rdntToken].lastUpdateTime = block.timestamp;\n\n\t\tREWARDS_DURATION = _rewardsDuration;\n\t\tREWARDS_LOOKBACK = _rewardsLookback;\n\t\tDEFAULT_LOCK_DURATION = _lockDuration;\n\t\tBURN = _burnRatio;\n\t\tVEST_DURATION = _vestDuration;\n\t}\n\n\t/********************** Setters ***********************/\n\n\t/**\n\t * @notice Set minters\n\t * @dev Can be called only once\n\t */\n\tfunction setMinters(address[] memory _minters) external onlyOwner {\n\t\trequire(!mintersAreSet);\n\t\tfor (uint256 i; i < _minters.length; i++) {\n\t\t\tminters[_minters[i]] = true;\n\t\t}\n\t\tmintersAreSet = true;\n\t}\n\n\tfunction addBountyContract(address _bounty) external onlyOwner {\n\t\tBountyManager = _bounty;\n\t\tminters[_bounty] = true;\n\t}\n\n\t/**\n\t * @notice Add a new reward token to be distributed to stakers.\n\t */\n\tfunction setLockTypeInfo(uint256[] memory _lockPeriod, uint256[] memory _rewardMultipliers) external onlyOwner {\n\t\trequire(_lockPeriod.length == _rewardMultipliers.length);\n\t\tdelete lockPeriod;\n\t\tdelete rewardMultipliers;\n\t\tfor (uint256 i = 0; i < _lockPeriod.length; i += 1) {\n\t\t\tlockPeriod.push(_lockPeriod[i]);\n\t\t\trewardMultipliers.push(_rewardMultipliers[i]);\n\t\t}\n\t}\n\n\t/**\n\t * @notice Set CIC, MFD and Treasury.\n\t */\n\tfunction setAddresses(\n\t\tIChefIncentivesController _controller,\n\t\tIMiddleFeeDistribution _middleFeeDistribution,\n\t\taddress _treasury\n\t) external onlyOwner {\n\t\tincentivesController = _controller;\n\t\tmiddleFeeDistribution = _middleFeeDistribution;\n\t\tSTARFLEET_TREASURY = _treasury;\n\t}\n\n\t/**\n\t * @notice Set LP token.\n\t */\n\tfunction setLPToken(address _stakingToken) external onlyOwner {\n\t\trequire(stakingToken == address(0));\n\t\tstakingToken = _stakingToken;\n\t}\n\n\t/**\n\t * @notice Add a new reward token to be distributed to stakers.\n\t */\n\tfunction addReward(address _rewardToken) external override {\n\t\trequire(minters[msg.sender]);\n\t\trequire(rewardData[_rewardToken].lastUpdateTime == 0);\n\t\trewardTokens.push(_rewardToken);\n\t\trewardData[_rewardToken].lastUpdateTime = block.timestamp;\n\t\trewardData[_rewardToken].periodFinish = block.timestamp;\n\t}\n\n\t/********************** View functions ***********************/\n\n\t/**\n\t * @notice Set default lock type index for user relock.\n\t */\n\tfunction setDefaultRelockTypeIndex(uint256 _index) external override {\n\t\trequire(_index < lockPeriod.length);\n\t\tdefaultLockIndex[msg.sender] = _index;\n\t}\n\n\tfunction getLockDurations() external view returns (uint256[] memory) {\n\t\treturn lockPeriod;\n\t}\n\n\tfunction getLockMultipliers() external view returns (uint256[] memory) {\n\t\treturn rewardMultipliers;\n\t}\n\n\t/**\n\t * @notice Set relock status\n\t */\n\tfunction setRelock(bool _status) external {\n\t\tif (BountyManager != address(0)) {\n\t\t\tIBounty(BountyManager).onRelockUpdate(msg.sender, !autoRelockDisabled[msg.sender], _status);\n\t\t}\n\t\tautoRelockDisabled[msg.sender] = !_status;\n\t}\n\n\t/**\n\t * @notice Returns all locks of a user.\n\t */\n\tfunction lockInfo(address user) external view override returns (LockedBalance[] memory) {\n\t\treturn userLocks[user];\n\t}\n\n\t/**\n\t * @notice Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders.\n\t */\n\t// function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyOwner {\n\t// \trequire(rewardData[tokenAddress].lastUpdateTime == 0);\n\t// \tIERC20(tokenAddress).safeTransfer(owner(), tokenAmount);\n\t// \temit Recovered(tokenAddress, tokenAmount);\n\t// }\n\n\t/**\n\t * @notice Withdraw and restake assets.\n\t */\n\tfunction relock() external {\n\t\tuint256 amount = _withdrawExpiredLocksFor(msg.sender, true, true, userLocks[msg.sender].length);\n\t\t_stake(amount, msg.sender, defaultLockIndex[msg.sender], false);\n\t\temit Relocked(msg.sender, amount, defaultLockIndex[msg.sender]);\n\t}\n\n\t/**\n\t * @notice Total balance of an account, including unlocked, locked and earned tokens.\n\t */\n\tfunction totalBalance(address user) external view override returns (uint256 amount) {\n\t\tif (stakingToken == address(rdntToken)) {\n\t\t\treturn balances[user].total;\n\t\t}\n\t\treturn balances[user].locked;\n\t}\n\n\t/**\n\t * @notice Information on a user's lockings\n\t * @return total balance of locks\n\t * @return unlockable balance\n\t * @return locked balance\n\t * @return lockedWithMultiplier\n\t * @return lockData which is an array of locks\n\t */\n\tfunction lockedBalances(address user)\n\t\tpublic\n\t\tview\n\t\toverride\n\t\treturns (\n\t\t\tuint256 total,\n\t\t\tuint256 unlockable,\n\t\t\tuint256 locked,\n\t\t\tuint256 lockedWithMultiplier,\n\t\t\tLockedBalance[] memory lockData\n\t\t)\n\t{\n\t\tLockedBalance[] storage locks = userLocks[user];\n\t\tuint256 idx;\n\t\tfor (uint256 i = 0; i < locks.length; i++) {\n\t\t\tif (locks[i].unlockTime > block.timestamp) {\n\t\t\t\tif (idx == 0) {\n\t\t\t\t\tlockData = new LockedBalance[](locks.length - i);\n\t\t\t\t}\n\t\t\t\tlockData[idx] = locks[i];\n\t\t\t\tidx++;\n\t\t\t\tlocked = locked.add(locks[i].amount);\n\t\t\t\tlockedWithMultiplier = lockedWithMultiplier.add(locks[i].amount.mul(locks[i].multiplier));\n\t\t\t} else {\n\t\t\t\tunlockable = unlockable.add(locks[i].amount);\n\t\t\t}\n\t\t}\n\t\treturn (balances[user].locked, unlockable, locked, lockedWithMultiplier, lockData);\n\t}\n\n\t/**\n\t * @notice Earnings which is locked yet\n\t * @dev Earned balances may be withdrawn immediately for a 50% penalty.\n\t * @return total earnings\n\t * @return unlocked earnings\n\t * @return earningsData which is an array of all infos\n\t */\n\tfunction earnedBalances(address user)\n\t\tpublic\n\t\tview\n\t\treturns (\n\t\t\tuint256 total,\n\t\t\tuint256 unlocked,\n\t\t\tEarnedBalance[] memory earningsData\n\t\t)\n\t{\n\t\tunlocked = balances[user].unlocked;\n\t\tLockedBalance[] storage earnings = userEarnings[user];\n\t\tuint256 idx;\n\t\tfor (uint256 i = 0; i < earnings.length; i++) {\n\t\t\tif (earnings[i].unlockTime > block.timestamp) {\n\t\t\t\tif (idx == 0) {\n\t\t\t\t\tearningsData = new EarnedBalance[](earnings.length - i);\n\t\t\t\t}\n\t\t\t\t(, uint256 penaltyAmount, , ) = ieeWithdrawableBalances(user, earnings[i].unlockTime);\n\t\t\t\tearningsData[idx].amount = earnings[i].amount;\n\t\t\t\tearningsData[idx].unlockTime = earnings[i].unlockTime;\n\t\t\t\tearningsData[idx].penalty = penaltyAmount;\n\t\t\t\tidx++;\n\t\t\t\ttotal = total.add(earnings[i].amount);\n\t\t\t} else {\n\t\t\t\tunlocked = unlocked.add(earnings[i].amount);\n\t\t\t}\n\t\t}\n\t\treturn (total, unlocked, earningsData);\n\t}\n\n\t/**\n\t * @notice Final balance received and penalty balance paid by user upon calling exit.\n\t * @dev This is earnings, not locks.\n\t */\n\tfunction withdrawableBalance(address user)\n\t\tpublic\n\t\tview\n\t\treturns (\n\t\t\tuint256 amount,\n\t\t\tuint256 penaltyAmount,\n\t\t\tuint256 burnAmount\n\t\t)\n\t{\n\t\tuint256 earned = balances[user].earned;\n\t\tif (earned > 0) {\n\t\t\tuint256 length = userEarnings[user].length;\n\t\t\tfor (uint256 i = 0; i < length; i++) {\n\t\t\t\tuint256 earnedAmount = userEarnings[user][i].amount;\n\t\t\t\tif (earnedAmount == 0) continue;\n\t\t\t\t(, , uint256 newPenaltyAmount, uint256 newBurnAmount) = _penaltyInfo(userEarnings[user][i]);\n\t\t\t\tpenaltyAmount = penaltyAmount.add(newPenaltyAmount);\n\t\t\t\tburnAmount = burnAmount.add(newBurnAmount);\n\t\t\t}\n\t\t}\n\t\tamount = balances[user].unlocked.add(earned).sub(penaltyAmount);\n\t\treturn (amount, penaltyAmount, burnAmount);\n\t}\n\n\tfunction _penaltyInfo(LockedBalance memory earning)\n\t\tinternal\n\t\tview\n\t\treturns (\n\t\t\tuint256 amount,\n\t\t\tuint256 penaltyFactor,\n\t\t\tuint256 penaltyAmount,\n\t\t\tuint256 burnAmount\n\t\t)\n\t{\n\t\tif (earning.unlockTime > block.timestamp) {\n\t\t\t// 90% on day 1, decays to 25% on day 90\n\t\t\tpenaltyFactor = earning.unlockTime.sub(block.timestamp).mul(HALF).div(VEST_DURATION).add(QUART); // 25% + timeLeft/VEST_DURATION * 65%\n\t\t}\n\t\tpenaltyAmount = earning.amount.mul(penaltyFactor).div(WHOLE);\n\t\tburnAmount = penaltyAmount.mul(BURN).div(WHOLE);\n\t\tamount = earning.amount.sub(penaltyAmount);\n\t}\n\n\t/********************** Reward functions ***********************/\n\n\t/**\n\t * @notice Reward amount of the duration.\n\t * @param _rewardToken for the reward\n\t */\n\tfunction getRewardForDuration(address _rewardToken) external view returns (uint256) {\n\t\treturn rewardData[_rewardToken].rewardPerSecond.mul(REWARDS_DURATION).div(1e12);\n\t}\n\n\t/**\n\t * @notice Returns reward applicable timestamp.\n\t */\n\tfunction lastTimeRewardApplicable(address _rewardToken) public view returns (uint256) {\n\t\tuint256 periodFinish = rewardData[_rewardToken].periodFinish;\n\t\treturn block.timestamp < periodFinish ? block.timestamp : periodFinish;\n\t}\n\n\t/**\n\t * @notice Reward amount per token\n\t * @dev Reward is distributed only for locks.\n\t * @param _rewardToken for reward\n\t */\n\tfunction rewardPerToken(address _rewardToken) public view returns (uint256 rptStored) {\n\t\trptStored = rewardData[_rewardToken].rewardPerTokenStored;\n\t\tif (lockedSupplyWithMultiplier > 0) {\n\t\t\tuint256 newReward = lastTimeRewardApplicable(_rewardToken).sub(rewardData[_rewardToken].lastUpdateTime).mul(\n\t\t\t\trewardData[_rewardToken].rewardPerSecond\n\t\t\t);\n\t\t\trptStored = rptStored.add(newReward.mul(1e18).div(lockedSupplyWithMultiplier));\n\t\t}\n\t}\n\n\t/**\n\t * @notice Address and claimable amount of all reward tokens for the given account.\n\t * @param account for rewards\n\t */\n\tfunction claimableRewards(address account)\n\t\tpublic\n\t\tview\n\t\toverride\n\t\treturns (IFeeDistribution.RewardData[] memory rewardsData)\n\t{\n\t\trewardsData = new IFeeDistribution.RewardData[](rewardTokens.length);\n\t\tfor (uint256 i = 0; i < rewardsData.length; i++) {\n\t\t\trewardsData[i].token = rewardTokens[i];\n\t\t\trewardsData[i].amount = _earned(\n\t\t\t\taccount,\n\t\t\t\trewardsData[i].token,\n\t\t\t\tbalances[account].lockedWithMultiplier,\n\t\t\t\trewardPerToken(rewardsData[i].token)\n\t\t\t).div(1e12);\n\t\t}\n\t\treturn rewardsData;\n\t}\n\n\t/********************** Operate functions ***********************/\n\n\t/**\n\t * @notice Stake tokens to receive rewards.\n\t * @dev Locked tokens cannot be withdrawn for DEFAULT_LOCK_DURATION and are eligible to receive rewards.\n\t */\n\tfunction stake(\n\t\tuint256 amount,\n\t\taddress onBehalfOf,\n\t\tuint256 typeIndex\n\t) external override {\n\t\t// Exceptional case is\n\t\t// - User locked, default index is 1\n\t\t// - User set default index as 0\n\t\t// - User unlocked all\n\t\t// - User locks again, default index is reset to 1\n\t\tif (defaultLockIndex[onBehalfOf] == 0 && userLocks[onBehalfOf].length == 0) {\n\t\t\tdefaultLockIndex[onBehalfOf] = DEFAULT_LOCK_INDEX;\n\t\t}\n\t\t_stake(amount, onBehalfOf, typeIndex, false);\n\t}\n\n\tfunction _stake(\n\t\tuint256 amount,\n\t\taddress onBehalfOf,\n\t\tuint256 typeIndex,\n\t\tbool isRelock\n\t) internal {\n\t\tif (amount == 0) return;\n\t\tif (BountyManager != address(0)) {\n\t\t\trequire(amount >= IBounty(BountyManager).minDLPBalance());\n\t\t}\n\t\trequire(typeIndex < lockPeriod.length);\n\n\t\tincentivesController.beforeLockUpdate(onBehalfOf);\n\n\t\t_updateReward(onBehalfOf);\n\n\t\tuint256 transferAmount = amount;\n\t\tif (onBehalfOf == msg.sender || msg.sender == lockZap) {\n\t\t\tuint256 withdrawnAmt;\n\t\t\tif (!autoRelockDisabled[onBehalfOf]) {\n\t\t\t\twithdrawnAmt = _withdrawExpiredLocksFor(onBehalfOf, true, false, userLocks[onBehalfOf].length);\n\t\t\t\tamount = amount.add(withdrawnAmt);\n\t\t\t} else {\n\t\t\t\t_withdrawExpiredLocksFor(onBehalfOf, true, true, userLocks[onBehalfOf].length);\n\t\t\t}\n\t\t}\n\n\t\tBalances storage bal = balances[onBehalfOf];\n\t\tbal.total = bal.total.add(amount);\n\n\t\tbal.locked = bal.locked.add(amount);\n\t\tlockedSupply = lockedSupply.add(amount);\n\n\t\tbal.lockedWithMultiplier = bal.lockedWithMultiplier.add(amount.mul(rewardMultipliers[typeIndex]));\n\t\tlockedSupplyWithMultiplier = lockedSupplyWithMultiplier.add(amount.mul(rewardMultipliers[typeIndex]));\n\n\t\t_insertLock(\n\t\t\tonBehalfOf,\n\t\t\tLockedBalance({\n\t\t\t\tamount: amount,\n\t\t\t\tunlockTime: block.timestamp.add(lockPeriod[typeIndex]),\n\t\t\t\tmultiplier: rewardMultipliers[typeIndex],\n\t\t\t\tduration: lockPeriod[typeIndex]\n\t\t\t})\n\t\t);\n\n\t\tuserlist.addToList(onBehalfOf);\n\n\t\tif (!isRelock) {\n\t\t\tIERC20(stakingToken).safeTransferFrom(msg.sender, address(this), transferAmount);\n\t\t}\n\n\t\tincentivesController.afterLockUpdate(onBehalfOf);\n\n\t\tuint256 stakingTokenPrice;\n\t\tif (stakingToken == address(rdntToken)) {\n\t\t\tstakingTokenPrice = IPriceProvider(_priceProvider).getTokenPriceUsd();\n\t\t} else {\n\t\t\tstakingTokenPrice = IPriceProvider(_priceProvider).getLpTokenPriceUsd();\n\t\t}\n\t\tuint8 stakingTokenDecimals = IERC20Detailed(stakingToken).decimals();\n\t\tuint256 usdValue = stakingTokenPrice.mul(amount).mul(10**18).div(10**8).div(10**stakingTokenDecimals);\n\n\t\temit Staked(onBehalfOf, amount, true);\n\t\temit Locked(onBehalfOf, usdValue, stakingToken != address(rdntToken));\n\t}\n\n\tfunction _insertLock(address _user, LockedBalance memory newLock) internal {\n\t\tLockedBalance[] storage locks = userLocks[_user];\n\t\tuint256 length = locks.length;\n\t\tuint256 i;\n\t\twhile (i < length && locks[i].unlockTime < newLock.unlockTime) {\n\t\t\ti = i + 1;\n\t\t}\n\t\tlocks.push(newLock);\n\t\tfor (uint256 j = length; j > i; j -= 1) {\n\t\t\tlocks[j] = locks[j - 1];\n\t\t}\n\t\tlocks[i] = newLock;\n\t}\n\n\t/**\n\t * @notice Add to earnings\n\t * @dev Minted tokens receive rewards normally but incur a 50% penalty when\n\t *  withdrawn before VEST_DURATION has passed.\n\t */\n\tfunction mint(\n\t\taddress user,\n\t\tuint256 amount,\n\t\tbool withPenalty\n\t) external override {\n\t\trequire(minters[msg.sender]);\n\t\tif (amount == 0) return;\n\n\t\t_updateReward(user);\n\n\t\tif (user == address(this)) {\n\t\t\t// minting to this contract adds the new tokens as incentives for lockers\n\t\t\t_notifyReward(address(rdntToken), amount);\n\t\t\treturn;\n\t\t}\n\n\t\tBalances storage bal = balances[user];\n\t\tbal.total = bal.total.add(amount);\n\t\tif (withPenalty) {\n\t\t\tbal.earned = bal.earned.add(amount);\n\t\t\tLockedBalance[] storage earnings = userEarnings[user];\n\t\t\tuint256 unlockTime = block.timestamp.add(VEST_DURATION);\n\t\t\tearnings.push(\n\t\t\t\tLockedBalance({amount: amount, unlockTime: unlockTime, multiplier: 1, duration: VEST_DURATION})\n\t\t\t);\n\t\t} else {\n\t\t\tbal.unlocked = bal.unlocked.add(amount);\n\t\t}\n\t\temit Staked(user, amount, false);\n\t}\n\n\t/**\n\t * @notice Withdraw tokens from earnings and unlocked.\n\t * @dev First withdraws unlocked tokens, then earned tokens. Withdrawing earned tokens\n\t *  incurs a 50% penalty which is distributed based on locked balances.\n\t */\n\tfunction withdraw(uint256 amount) external {\n\t\taddress _address = msg.sender;\n\t\trequire(amount != 0);\n\n\t\tuint256 penaltyAmount;\n\t\tuint256 burnAmount;\n\t\tBalances storage bal = balances[_address];\n\n\t\tif (amount <= bal.unlocked) {\n\t\t\tbal.unlocked = bal.unlocked.sub(amount);\n\t\t} else {\n\t\t\tuint256 remaining = amount.sub(bal.unlocked);\n\t\t\trequire(bal.earned >= remaining);\n\t\t\tbal.unlocked = 0;\n\t\t\tuint256 sumEarned = bal.earned;\n\t\t\tuint256 i;\n\t\t\tfor (i = 0; ; i++) {\n\t\t\t\tuint256 earnedAmount = userEarnings[_address][i].amount;\n\t\t\t\tif (earnedAmount == 0) continue;\n\t\t\t\t(, uint256 penaltyFactor, , ) = _penaltyInfo(userEarnings[_address][i]);\n\n\t\t\t\t// Amount required from this lock, taking into account the penalty\n\t\t\t\tuint256 requiredAmount = remaining.mul(WHOLE).div(WHOLE.sub(penaltyFactor));\n\t\t\t\tif (requiredAmount >= earnedAmount) {\n\t\t\t\t\trequiredAmount = earnedAmount;\n\t\t\t\t\tremaining = remaining.sub(earnedAmount.mul(WHOLE.sub(penaltyFactor)).div(WHOLE)); // remaining -= earned * (1 - pentaltyFactor)\n\t\t\t\t\tif (remaining == 0) i++;\n\t\t\t\t} else {\n\t\t\t\t\tuserEarnings[_address][i].amount = earnedAmount.sub(requiredAmount);\n\t\t\t\t\tremaining = 0;\n\t\t\t\t}\n\t\t\t\tsumEarned = sumEarned.sub(requiredAmount);\n\n\t\t\t\tpenaltyAmount = penaltyAmount.add(requiredAmount.mul(penaltyFactor).div(WHOLE)); // penalty += amount * penaltyFactor\n\t\t\t\tburnAmount = burnAmount.add(penaltyAmount.mul(BURN).div(WHOLE)); // burn += penalty * burnFactor\n\n\t\t\t\tif (remaining == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\trequire(sumEarned != 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i > 0) {\n\t\t\t\tfor (uint256 j = i; j < userEarnings[_address].length; j++) {\n\t\t\t\t\tuserEarnings[_address][j - i] = userEarnings[_address][j];\n\t\t\t\t}\n\t\t\t\tfor (uint256 j = 0; j < i; j++) {\n\t\t\t\t\tuserEarnings[_address].pop();\n\t\t\t\t}\n\t\t\t}\n\t\t\tbal.earned = sumEarned;\n\t\t}\n\n\t\t// Update values\n\t\tbal.total = bal.total.sub(amount).sub(penaltyAmount);\n\n\t\t_withdrawTokens(_address, amount, penaltyAmount, burnAmount, false);\n\t}\n\n\tfunction ieeWithdrawableBalances(address user, uint256 unlockTime)\n\t\tinternal\n\t\tview\n\t\treturns (\n\t\t\tuint256 amount,\n\t\t\tuint256 penaltyAmount,\n\t\t\tuint256 burnAmount,\n\t\t\tuint256 index\n\t\t)\n\t{\n\t\tfor (uint256 i = 0; i < userEarnings[user].length; i++) {\n\t\t\tif (userEarnings[user][i].unlockTime == unlockTime) {\n\t\t\t\t(amount, , penaltyAmount, burnAmount) = _penaltyInfo(userEarnings[user][i]);\n\t\t\t\tindex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @notice Withdraw individual unlocked balance and earnings, optionally claim pending rewards.\n\t */\n\tfunction individualEarlyExit(bool claimRewards, uint256 unlockTime) external {\n\t\taddress onBehalfOf = msg.sender;\n\t\trequire(unlockTime > block.timestamp);\n\t\t(uint256 amount, uint256 penaltyAmount, uint256 burnAmount, uint256 index) = ieeWithdrawableBalances(\n\t\t\tonBehalfOf,\n\t\t\tunlockTime\n\t\t);\n\n\t\tif (index >= userEarnings[onBehalfOf].length) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (uint256 i = index + 1; i < userEarnings[onBehalfOf].length; i++) {\n\t\t\tuserEarnings[onBehalfOf][i - 1] = userEarnings[onBehalfOf][i];\n\t\t}\n\t\tuserEarnings[onBehalfOf].pop();\n\n\t\tBalances storage bal = balances[onBehalfOf];\n\t\tbal.total = bal.total.sub(amount).sub(penaltyAmount);\n\t\tbal.earned = bal.earned.sub(amount).sub(penaltyAmount);\n\n\t\t_withdrawTokens(onBehalfOf, amount, penaltyAmount, burnAmount, claimRewards);\n\t}\n\n\t/**\n\t * @notice Withdraw full unlocked balance and earnings, optionally claim pending rewards.\n\t */\n\tfunction exit(bool claimRewards) external override {\n\t\taddress onBehalfOf = msg.sender;\n\t\t(uint256 amount, uint256 penaltyAmount, uint256 burnAmount) = withdrawableBalance(onBehalfOf);\n\n\t\tdelete userEarnings[onBehalfOf];\n\n\t\tBalances storage bal = balances[onBehalfOf];\n\t\tbal.total = bal.total.sub(bal.unlocked).sub(bal.earned);\n\t\tbal.unlocked = 0;\n\t\tbal.earned = 0;\n\n\t\t_withdrawTokens(onBehalfOf, amount, penaltyAmount, burnAmount, claimRewards);\n\t}\n\n\t/**\n\t * @notice Claim all pending staking rewards.\n\t */\n\tfunction getReward(address[] memory _rewardTokens) public {\n\t\t_updateReward(msg.sender);\n\t\t_getReward(msg.sender, _rewardTokens);\n\t\tlastClaimTime[msg.sender] = block.timestamp;\n\t}\n\n\t/**\n\t * @notice Claim all pending staking rewards.\n\t */\n\tfunction getAllRewards() external {\n\t\treturn getReward(rewardTokens);\n\t}\n\n\t/**\n\t * @notice Calculate earnings.\n\t */\n\tfunction _earned(\n\t\taddress _user,\n\t\taddress _rewardToken,\n\t\tuint256 _balance,\n\t\tuint256 _currentRewardPerToken\n\t) internal view returns (uint256 earnings) {\n\t\tearnings = rewards[_user][_rewardToken];\n\t\tuint256 realRPT = _currentRewardPerToken.sub(userRewardPerTokenPaid[_user][_rewardToken]);\n\t\tearnings = earnings.add(_balance.mul(realRPT).div(1e18));\n\t}\n\n\t/**\n\t * @notice Update user reward info.\n\t */\n\tfunction _updateReward(address account) internal {\n\t\tuint256 balance = balances[account].lockedWithMultiplier;\n\t\tuint256 length = rewardTokens.length;\n\t\tfor (uint256 i = 0; i < length; i++) {\n\t\t\taddress token = rewardTokens[i];\n\t\t\tuint256 rpt = rewardPerToken(token);\n\n\t\t\tReward storage r = rewardData[token];\n\t\t\tr.rewardPerTokenStored = rpt;\n\t\t\tr.lastUpdateTime = lastTimeRewardApplicable(token);\n\n\t\t\tif (account != address(this)) {\n\t\t\t\trewards[account][token] = _earned(account, token, balance, rpt);\n\t\t\t\tuserRewardPerTokenPaid[account][token] = rpt;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @notice Add new reward.\n\t * @dev If prev reward period is not done, then it resets `rewardPerSecond` and restarts period\n\t */\n\tfunction _notifyReward(address _rewardToken, uint256 reward) internal {\n\t\tReward storage r = rewardData[_rewardToken];\n\t\tif (block.timestamp >= r.periodFinish) {\n\t\t\tr.rewardPerSecond = reward.mul(1e12).div(REWARDS_DURATION);\n\t\t} else {\n\t\t\tuint256 remaining = r.periodFinish.sub(block.timestamp);\n\t\t\tuint256 leftover = remaining.mul(r.rewardPerSecond).div(1e12);\n\t\t\tr.rewardPerSecond = reward.add(leftover).mul(1e12).div(REWARDS_DURATION);\n\t\t}\n\n\t\tr.lastUpdateTime = block.timestamp;\n\t\tr.periodFinish = block.timestamp.add(REWARDS_DURATION);\n\t\tr.balance = r.balance.add(reward);\n\t}\n\n\t/**\n\t * @notice Notify unseen rewards.\n\t * @dev for rewards other than stakingToken, every 24 hours we check if new\n\t *  rewards were sent to the contract or accrued via aToken interest.\n\t */\n\tfunction _notifyUnseenReward(address token) internal {\n\t\trequire(token != address(0));\n\t\tif (token == address(rdntToken)) {\n\t\t\treturn;\n\t\t}\n\t\tReward storage r = rewardData[token];\n\t\tuint256 periodFinish = r.periodFinish;\n\t\trequire(periodFinish != 0);\n\t\tif (periodFinish < block.timestamp.add(REWARDS_DURATION - REWARDS_LOOKBACK)) {\n\t\t\tuint256 unseen = IERC20(token).balanceOf(address(this)).sub(r.balance);\n\t\t\tif (unseen > 0) {\n\t\t\t\t_notifyReward(token, unseen);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @notice User gets reward\n\t */\n\tfunction _getReward(address _user, address[] memory _rewardTokens) internal {\n\t\tmiddleFeeDistribution.forwardReward(_rewardTokens);\n\t\tuint256 length = _rewardTokens.length;\n\t\tfor (uint256 i; i < length; i++) {\n\t\t\taddress token = _rewardTokens[i];\n\t\t\t_notifyUnseenReward(token);\n\t\t\tuint256 reward = rewards[_user][token].div(1e12);\n\t\t\tif (reward > 0) {\n\t\t\t\trewards[_user][token] = 0;\n\t\t\t\trewardData[token].balance = rewardData[token].balance.sub(reward);\n\n\t\t\t\tIERC20(token).safeTransfer(_user, reward);\n\n\t\t\t\temit RewardPaid(_user, token, reward);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @notice Withdraw tokens from MFD\n\t */\n\tfunction _withdrawTokens(\n\t\taddress onBehalfOf,\n\t\tuint256 amount,\n\t\tuint256 penaltyAmount,\n\t\tuint256 burnAmount,\n\t\tbool claimRewards\n\t) internal {\n\t\trequire(onBehalfOf == msg.sender);\n\t\t_updateReward(onBehalfOf);\n\n\t\trdntToken.safeTransfer(onBehalfOf, amount);\n\t\tif (penaltyAmount > 0) {\n\t\t\tif (burnAmount > 0) {\n\t\t\t\trdntToken.safeTransfer(STARFLEET_TREASURY, burnAmount);\n\t\t\t}\n\t\t\trdntToken.safeTransfer(daoTreasury, penaltyAmount.sub(burnAmount));\n\t\t}\n\n\t\tif (claimRewards) {\n\t\t\t_getReward(onBehalfOf, rewardTokens);\n\t\t\tlastClaimTime[onBehalfOf] = block.timestamp;\n\t\t}\n\n\t\temit Withdrawn(onBehalfOf, address(rdntToken), amount, penaltyAmount, burnAmount);\n\t}\n\n\t/********************** Eligibility + Disqualification ***********************/\n\n\t/**\n\t * @notice Withdraw all lockings tokens where the unlock time has passed\n\t */\n\tfunction _cleanWithdrawableLocks(\n\t\taddress user,\n\t\tuint256 totalLock,\n\t\tuint256 totalLockWithMultiplier,\n\t\tuint256 limit\n\t) internal returns (uint256 lockAmount, uint256 lockAmountWithMultiplier) {\n\t\tLockedBalance[] storage locks = userLocks[user];\n\n\t\tif (locks.length != 0) {\n\t\t\tuint256 length = locks.length <= limit ? locks.length : limit;\n\t\t\tfor (uint256 i = 0; i < length; ) {\n\t\t\t\tif (locks[i].unlockTime <= block.timestamp) {\n\t\t\t\t\tlockAmount = lockAmount.add(locks[i].amount);\n\t\t\t\t\tlockAmountWithMultiplier = lockAmountWithMultiplier.add(locks[i].amount.mul(locks[i].multiplier));\n\t\t\t\t\tlocks[i] = locks[locks.length - 1];\n\t\t\t\t\tlocks.pop();\n\t\t\t\t\tlength = length.sub(1);\n\t\t\t\t} else {\n\t\t\t\t\ti = i + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (locks.length == 0) {\n\t\t\t\tlockAmount = totalLock;\n\t\t\t\tlockAmountWithMultiplier = totalLockWithMultiplier;\n\t\t\t\tdelete userLocks[user];\n\n\t\t\t\tuserlist.removeFromList(user);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @notice Withdraw all currently locked tokens where the unlock time has passed.\n\t * @param _address of the user.\n\t */\n\tfunction _withdrawExpiredLocksFor(\n\t\taddress _address,\n\t\tbool isRelockAction,\n\t\tbool doTransfer,\n\t\tuint256 limit\n\t) internal returns (uint256 amount) {\n\t\tincentivesController.beforeLockUpdate(_address);\n\t\t_updateReward(_address);\n\n\t\tuint256 amountWithMultiplier;\n\t\tBalances storage bal = balances[_address];\n\t\t(amount, amountWithMultiplier) = _cleanWithdrawableLocks(_address, bal.locked, bal.lockedWithMultiplier, limit);\n\t\tbal.locked = bal.locked.sub(amount);\n\t\tbal.lockedWithMultiplier = bal.lockedWithMultiplier.sub(amountWithMultiplier);\n\t\tbal.total = bal.total.sub(amount);\n\t\tlockedSupply = lockedSupply.sub(amount);\n\t\tlockedSupplyWithMultiplier = lockedSupplyWithMultiplier.sub(amountWithMultiplier);\n\t\tincentivesController.afterLockUpdate(_address);\n\n\t\tif (!isRelockAction && !autoRelockDisabled[_address]) {\n\t\t\t_stake(amount, _address, defaultLockIndex[_address], true);\n\t\t} else {\n\t\t\tif (doTransfer) {\n\t\t\t\tIERC20(stakingToken).safeTransfer(_address, amount);\n\t\t\t\temit Withdrawn(_address, stakingToken, amount, 0, 0);\n\t\t\t}\n\t\t}\n\t\treturn amount;\n\t}\n\n\t/**\n\t * @notice Withdraw all currently locked tokens where the unlock time has passed.\n\t */\n\tfunction withdrawExpiredLocksFor(address _address) external override returns (uint256) {\n\t\treturn _withdrawExpiredLocksFor(_address, false, true, userLocks[_address].length);\n\t}\n\n\tfunction withdrawExpiredLocksForWithOptions(\n\t\taddress _address,\n\t\tuint256 _limit,\n\t\tbool _ignoreRelock\n\t) external returns (uint256) {\n\t\tif (_limit == 0) _limit = userLocks[_address].length;\n\n\t\treturn _withdrawExpiredLocksFor(_address, _ignoreRelock, true, _limit);\n\t}\n\n\tfunction zapVestingToLp(address _user) external override returns (uint256 zapped) {\n\t\trequire(msg.sender == lockZap);\n\n\t\tLockedBalance[] storage earnings = userEarnings[_user];\n\t\tuint256 length = earnings.length;\n\n\t\tfor (uint256 i = 0; i < length; ) {\n\t\t\t// only vesting, so only look at currently locked items\n\t\t\tif (earnings[i].unlockTime > block.timestamp) {\n\t\t\t\tzapped = zapped.add(earnings[i].amount);\n\t\t\t\t// remove + shift array size\n\t\t\t\tearnings[i] = earnings[earnings.length - 1];\n\t\t\t\tearnings.pop();\n\t\t\t\tlength = length.sub(1);\n\t\t\t} else {\n\t\t\t\ti = i.add(1);\n\t\t\t}\n\t\t}\n\n\t\trdntToken.safeTransfer(lockZap, zapped);\n\n\t\tBalances storage bal = balances[_user];\n\t\tbal.earned = bal.earned.sub(zapped);\n\t\tbal.total = bal.total.sub(zapped);\n\n\t\treturn zapped;\n\t}\n}\n"
    },
    "contracts/stargate/StargateBorrow.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../dependencies/openzeppelin/contracts/SafeMath.sol\";\nimport \"../dependencies/openzeppelin/contracts/IERC20.sol\";\nimport \"../dependencies/openzeppelin/contracts/SafeERC20.sol\";\nimport \"../dependencies/openzeppelin/contracts/Ownable.sol\";\nimport \"../interfaces/IStargateRouter.sol\";\nimport \"../interfaces/IRouterETH.sol\";\nimport \"../interfaces/ILendingPool.sol\";\nimport {IWETH} from \"../misc/interfaces/IWETH.sol\";\n\n/*\n    Chain Ids\n        Ethereum: 101\n        BSC: 102\n        Avalanche: 106\n        Polygon: 109\n        Arbitrum: 110\n        Optimism: 111\n        Fantom: 112\n        Swimmer: 114\n        DFK: 115\n        Harmony: 116\n        Moonbeam: 126\n\n    Pool Ids\n        Ethereum\n            USDC: 1\n            USDT: 2\n            ETH: 13\n        BSC\n            USDT: 2\n            BUSD: 5\n        Avalanche\n            USDC: 1\n            USDT: 2\n        Polygon\n            USDC: 1\n            USDT: 2\n        Arbitrum\n            USDC: 1\n            USDT: 2\n            ETH: 13\n        Optimism\n            USDC: 1\n            ETH: 13\n        Fantom\n            USDC: 1\n */\n\n/// @title Borrow gate via stargate\n/// @author Radiant\n/// @dev All function calls are currently implemented without side effects\ncontract StargateBorrow is Ownable {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    /// @notice FEE ratio DIVISOR\n    uint256 public constant FEE_PERCENT_DIVISOR = 10000;\n\n    // ETH pool Id\n    uint256 private constant PoolIdETH = 13;\n\n    // ETH address\n    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice Stargate Router\n    IStargateRouter public router;\n\n    /// @notice Stargate Router ETH\n    IRouterETH public routerETH;\n\n    /// @notice Lending Pool address\n    ILendingPool public lendingPool;\n\n    // WETH address\n    IWETH internal immutable WETH;\n\n    /// @notice asset => poolId; at the moment, pool IDs for USDC and USDT are the same accross all chains\n    mapping(address => uint256) public poolIdPerChain;\n\n    /// @notice DAO wallet\n    address public daoTreasury;\n\n    /// @notice Cross chain borrow fee ratio\n    uint256 public xChainBorrowFeePercent = 100;\n\n    /// @notice Emitted when DAO address is updated\n    event DAOTreasuryUpdated(address indexed _daoTreasury);\n\n    /// @notice Emitted when fee info is updated\n    event XChainBorrowFeePercentUpdated(uint256 percent);\n\n    /// @notice Emited when pool ids of assets are updated\n    event PoolIDsUpdated(address[] assets, uint256[] poolIDs);\n\n    /**\n     * @notice Constructor\n     * @param _router Stargate Router address\n     * @param _routerETH Stargate Router for ETH\n     * @param _lendingPool Lending pool\n     * @param _weth WETH address\n     * @param _treasury Treasury address\n     * @param _xChainBorrowFeePercent Cross chain borrow fee ratio\n     */\n    constructor(\n        IStargateRouter _router,\n        IRouterETH _routerETH,\n        ILendingPool _lendingPool,\n        IWETH _weth,\n        address _treasury,\n        uint256 _xChainBorrowFeePercent\n    ) {\n        require(address(_router) != (address(0)), \"Not a valid address\");\n        require(address(_routerETH) != (address(0)), \"Not a valid address\");\n        require(address(_lendingPool) != (address(0)), \"Not a valid address\");\n        require(address(_weth) != (address(0)), \"Not a valid address\");\n        require(_treasury != address(0), \"Not a valid address\");\n        require(_xChainBorrowFeePercent <= uint256(1e4), \"Not a valid number\");\n\n        router = _router;\n        routerETH = _routerETH;\n        lendingPool = _lendingPool;\n        daoTreasury = _treasury;\n        xChainBorrowFeePercent = _xChainBorrowFeePercent;\n        WETH = _weth;\n    }\n\n    receive() external payable {}\n\n    /**\n     * @notice Set DAO Treasury.\n     * @param _daoTreasury DAO Treasury address.\n     */\n    function setDAOTreasury(address _daoTreasury) external onlyOwner {\n        daoTreasury = _daoTreasury;\n        emit DAOTreasuryUpdated(_daoTreasury);\n    }\n\n    /**\n     * @notice Set Cross Chain Borrow Fee Percent.\n     * @param percent Fee ratio.\n     */\n    function setXChainBorrowFeePercent (uint256 percent) external onlyOwner {\n        require(percent <= 1e4, \"Invalid ratio\");\n        xChainBorrowFeePercent = percent;\n        emit XChainBorrowFeePercentUpdated(percent);\n    }\n\n    /**\n     * @notice Set pool ids of assets.\n     * @param assets array.\n     * @param poolIDs array.\n     */\n    function setPoolIDs(address[] memory assets, uint256[] memory poolIDs) external onlyOwner {\n        for (uint256 i = 0; i < assets.length; i += 1) {\n            poolIdPerChain[assets[i]] = poolIDs[i];\n        }\n        emit PoolIDsUpdated(assets, poolIDs);\n    }\n\n    /**\n     * @notice Get Cross Chain Borrow Fee amount.\n     * @param amount Fee cost.\n     */\n    function getXChainBorrowFeeAmount (uint256 amount) public view returns(uint256){\n        uint256 feeAmount = amount.mul(xChainBorrowFeePercent).div(FEE_PERCENT_DIVISOR);\n        return feeAmount;\n    }\n\n    /**\n     * @notice Quote LZ swap fee\n     * @dev Call Router.sol method to get the value for swap()\n     */\n    function quoteLayerZeroSwapFee(\n        uint16 _dstChainId,\n        uint8 _functionType,\n        bytes calldata _toAddress,\n        bytes calldata _transferAndCallPayload,\n        IStargateRouter.lzTxObj memory _lzTxParams\n    ) external view returns (uint256, uint256) {\n        return router.quoteLayerZeroFee(\n            _dstChainId,\n            _functionType,\n            _toAddress,\n            _transferAndCallPayload,\n            _lzTxParams\n        );\n    }\n\n    /**\n     * @dev Loop the deposit and borrow of an asset\n     * @param asset for loop\n     * @param amount for the initial deposit\n     * @param interestRateMode stable or variable borrow mode\n     * @param dstChainId Destination chain id\n     **/\n    function borrow(\n        address asset,\n        uint256 amount,\n        uint256 interestRateMode,\n        uint16 dstChainId\n    ) external payable {\n        if (address(asset) == ETH_ADDRESS) {\n            borrowETH(amount, interestRateMode, dstChainId);\n        } else {\n            lendingPool.borrow(asset, amount, interestRateMode, 0, msg.sender);\n            uint256 feeAmount = getXChainBorrowFeeAmount(amount);\n            IERC20(asset).safeTransfer(daoTreasury, feeAmount);\n            amount = amount.sub(feeAmount);\n            IERC20(asset).safeApprove(address(router), 0);\n            IERC20(asset).safeApprove(address(router), amount);\n            router.swap{value: msg.value}(\n                dstChainId, // dest chain id\n                poolIdPerChain[asset], // src chain pool id\n                poolIdPerChain[asset], // dst chain pool id\n                msg.sender, // receive address\n                amount, // transfer amount\n                amount.mul(99).div(100), // max slippage: 1%\n                IStargateRouter.lzTxObj(0, 0, \"0x\"),\n                abi.encodePacked(msg.sender),\n                bytes(\"\")\n            );\n        }\n    }\n\n    /**\n     * @dev Borrow ETH\n     * @param amount for the initial deposit\n     * @param interestRateMode stable or variable borrow mode\n     * @param dstChainId Destination chain id\n     **/\n    function borrowETH(\n        uint256 amount,\n        uint256 interestRateMode,\n        uint16 dstChainId\n    ) internal {\n        lendingPool.borrow(\n            address(WETH),\n            amount,\n            interestRateMode,\n            0,\n            msg.sender\n        );\n        WETH.withdraw(amount);\n        uint256 feeAmount = getXChainBorrowFeeAmount(amount);\n        _safeTransferETH(daoTreasury, feeAmount);\n        amount = amount.sub(feeAmount);\n\n        routerETH.swapETH{value: amount.add(msg.value)}(\n            dstChainId, // dest chain id\n            msg.sender, // receive address\n            abi.encodePacked(msg.sender),\n            amount, // transfer amount\n            amount.mul(99).div(100) // max slippage: 1%\n        );\n    }\n\n    /**\n    * @dev transfer ETH to an address, revert if it fails.\n    * @param to recipient of the transfer\n    * @param value the amount to send\n    */\n    function _safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, 'ETH_TRANSFER_FAILED');\n    }\n}"
    },
    "contracts/test/CustomERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"../dependencies/openzeppelin/contracts/ERC20.sol\";\n\ncontract CustomERC20 is ERC20 {\n  constructor(uint256 amount) ERC20(\"Custom\", \"Custom\") {\n    _mint(msg.sender, amount);\n  }\n\n  function setMinter(address minter) external returns (bool) {\n  }\n\n  function mint(address receiver, uint256 amount) external returns (bool successful) {\n    _mint(receiver, amount);\n    return true;\n  }\n\n  function burn(uint256 amount) external returns (bool successful) {\n    _burn(msg.sender, amount);\n    return true;\n  }\n}"
    },
    "contracts/test/mockERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"../dependencies/openzeppelin/contracts/IERC20.sol\";\n\ninterface mockERC20 is IERC20 {\n    function mint(uint256 amount) external;\n}"
    },
    "contracts/test/MockIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"../dependencies/openzeppelin/contracts/IERC20.sol\";\n\ncontract MockIncentivesController {\n  function beforeLockUpdate(address user) external {}\n\n  function afterLockUpdate(address user) external {}\n\n  function addPool(address _token, uint256 _allocPoint) external {}\n\n  function claim(address _user, address[] calldata _tokens) external {}\n}"
    },
    "contracts/test/MockMiddleFeeDistribution.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"../dependencies/openzeppelin/contracts/IERC20.sol\";\n\ncontract MockMiddleFeeDistribution {\n  function forwardReward(address[] memory _rewardTokens) external {}\n}"
    },
    "contracts/test/MockNewChefIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../staking/ChefIncentivesController.sol\";\n\ncontract MockNewChefIncentivesController is ChefIncentivesController {\n    function mockNewFunction () external pure returns (bool) {\n        return true;\n    }\n}"
    },
    "contracts/test/MockNewLPFeeDistribution.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../staking/MFDPlus.sol\";\n\ncontract MockNewLPFeeDistribution is MFDPlus {\n    function mockNewFunction () external pure returns (bool) {\n        return true;\n    }\n}"
    },
    "contracts/test/MockNewMiddleFeeDistribution.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../staking/MiddleFeeDistribution.sol\";\n\ncontract MockNewMiddleFeeDistribution is MiddleFeeDistribution {\n    function mockNewFunction () external pure returns (bool) {\n        return true;\n    }\n}"
    },
    "contracts/test/MockNewMultiFeeDistribution.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../staking/MFDPlus.sol\";\n\ncontract MockNewMultiFeeDistribution is MFDPlus {\n    function mockNewFunction () external pure returns (bool) {\n        return true;\n    }\n}"
    },
    "contracts/test/MockNewPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../oracles/PriceProvider.sol\";\n\ncontract MockNewPriceProvider is PriceProvider {\n    function mockNewFunction () external pure returns (bool) {\n        return true;\n    }\n}"
    },
    "contracts/test/MockOnwardIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../staking/ChefIncentivesController.sol\";\nimport \"../interfaces/IOnwardIncentivesController.sol\";\n\ncontract MockOnwardIncentivesController is IOnwardIncentivesController {\n    function handleAction(\n        address _token,\n        address _user,\n        uint256 _balance,\n        uint256 _totalSupply\n    ) external override {}\n}"
    },
    "contracts/test/MockPoolHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"../dependencies/openzeppelin/contracts/IERC20.sol\";\n\ncontract MockPoolHelper {\n  function getLpPrice() external pure returns(uint256) {\n    return 42;\n  }\n}"
    },
    "contracts/test/TestAdminOperation.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \"../dependencies/openzeppelin/contracts/Ownable.sol\";\n\ncontract TestAdminOperation is Ownable {\n    function test(uint256) external view onlyOwner returns (uint256) {\n        return 0x0000000000000000000000000000000000000000000000000000000000000054;\n    }\n}"
    },
    "contracts/test/TestBalancerPoolHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../zap/helpers/BalancerPoolHelper.sol\";\n\ncontract TestBalancerPoolHelper is BalancerPoolHelper {\n    function sell(uint256 _amount) public returns (uint256 amountOut) {\n        return\n            swap(\n                _amount,\n                0x0000000000000000000000000000000000000000,\n                0x0000000000000000000000000000000000000000,\n                0x0000000000000000000000000000000000000000\n            );\n    }\n}\n"
    },
    "contracts/test/TestLockZap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../zap/LockZap.sol\";\nimport \"../interfaces/IPoolHelper.sol\";\n\ncontract TestnetLockZap is LockZap {\n    function sell(uint256 _amount)\n        public\n        returns (uint256 ethOut)\n    {\n        IERC20(rdntAddr).transferFrom(msg.sender, address(poolHelper), _amount);\n        return ITestPoolHelper(address(poolHelper)).sell(_amount);\n    }\n}"
    },
    "contracts/test/TestUniswapPoolHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../dependencies/openzeppelin/contracts/SafeERC20.sol\";\nimport \"../zap/helpers/UniswapPoolHelper.sol\";\n\ncontract TestUniswapPoolHelper is UniswapPoolHelper {\n    using SafeERC20 for IERC20;\n\n    function swap(\n        uint256 _amount,\n        address,\n        address,\n        address\n    ) public returns (uint256 amountOut) {\n        IUniswapV2Pair lpToken = IUniswapV2Pair(lpTokenAddr);\n        (uint256 reserve0, uint256 reserve1, ) = lpToken.getReserves();\n\n        (address token0, address token1) = UniswapV2Library.sortTokens(\n            address(wethAddr),\n            rdntAddr\n        );\n\n        uint256 reserveWeth = token0 == address(wethAddr) ? reserve0 : reserve1;\n        uint256 reserveTokens = token0 == address(wethAddr)\n            ? reserve1\n            : reserve0;\n\n        uint256 outETH = UniswapV2Library.getAmountOut(\n            _amount,\n            reserveTokens,\n            reserveWeth\n        );\n\n        IERC20(rdntAddr).safeTransfer(lpTokenAddr, _amount);\n\n        IUniswapV2Pair(lpTokenAddr).swap(\n            address(wethAddr) == token0 ? outETH : 0,\n            address(wethAddr) == token1 ? outETH : 0,\n            address(this),\n            \"\"\n        );\n\n        amountOut = IERC20(address(wethAddr)).balanceOf(address(this));\n    }\n\n    function sell(uint256 _amount) public returns (uint256 amountOut) {\n        return\n            swap(\n                _amount,\n                0x0000000000000000000000000000000000000000,\n                0x0000000000000000000000000000000000000000,\n                0x0000000000000000000000000000000000000000\n            );\n    }\n}\n"
    },
    "contracts/uniswap/core/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.5.0;\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}\n"
    },
    "contracts/uniswap/core/interfaces/IUniswapV2Callee.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.5.0;\n\ninterface IUniswapV2Callee {\n    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;\n}\n"
    },
    "contracts/uniswap/core/interfaces/IUniswapV2ERC20.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.5.0;\n\ninterface IUniswapV2ERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n}\n"
    },
    "contracts/uniswap/core/interfaces/IUniswapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n    function getInitHash() external view returns(bytes32);\n\n}\n"
    },
    "contracts/uniswap/core/interfaces/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "contracts/uniswap/periphery/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.5.0;\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}\n"
    },
    "contracts/uniswap/periphery/interfaces/IUniswapV2Migrator.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.5.0;\n\ninterface IUniswapV2Migrator {\n    function migrate(address token, uint amountTokenMin, uint amountETHMin, address to, uint deadline) external;\n}\n"
    },
    "contracts/uniswap/periphery/interfaces/IUniswapV2Router01.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    \n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
    },
    "contracts/uniswap/periphery/interfaces/IUniswapV2Router02.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.6.2;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    \n}\n"
    },
    "contracts/uniswap/periphery/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.5.0;\n\ninterface IWETH {\n    function deposit() external payable;\n    function transfer(address to, uint value) external returns (bool);\n    function withdraw(uint) external;\n    function balanceOf(address guy) external returns(uint);\n}\n"
    },
    "contracts/uniswap/periphery/interfaces/V1/IUniswapV1Exchange.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.5.0;\n\ninterface IUniswapV1Exchange {\n    function balanceOf(address owner) external view returns (uint);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function removeLiquidity(uint, uint, uint, uint) external returns (uint, uint);\n    function tokenToEthSwapInput(uint, uint, uint) external returns (uint);\n    function ethToTokenSwapInput(uint, uint) external payable returns (uint);\n}\n"
    },
    "contracts/uniswap/periphery/interfaces/V1/IUniswapV1Factory.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.5.0;\n\ninterface IUniswapV1Factory {\n    function getExchange(address) external view returns (address);\n}\n"
    },
    "contracts/uniswap/periphery/libraries/UniswapV2OracleLibrary.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.5.0;\n\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\nimport '@uniswap/lib/contracts/libraries/FixedPoint.sol';\n\n// library with helper methods for oracles that are concerned with computing average prices\nlibrary UniswapV2OracleLibrary {\n    using FixedPoint for *;\n\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\n    function currentBlockTimestamp() internal view returns (uint32) {\n        return uint32(block.timestamp % 2 ** 32);\n    }\n\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\n    function currentCumulativePrices(\n        address pair\n    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\n        blockTimestamp = currentBlockTimestamp();\n        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\n        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\n\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\n        if (blockTimestampLast != blockTimestamp) {\n            // subtraction overflow is desired\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n            // addition overflow is desired\n            // counterfactual\n            price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\n            // counterfactual\n            price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\n        }\n    }\n}\n"
    },
    "contracts/zap/helpers/BalancerPoolHelper.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"./DustRefunder.sol\";\n\nimport \"../../dependencies/math/BNum.sol\";\n\nimport \"../../dependencies/openzeppelin/contracts/IERC20.sol\";\nimport \"../../dependencies/openzeppelin/contracts/SafeERC20.sol\";\nimport \"../../dependencies/openzeppelin/contracts/SafeMath.sol\";\nimport \"../../dependencies/openzeppelin/upgradeability/Initializable.sol\";\nimport \"../../dependencies/openzeppelin/upgradeability/OwnableUpgradeable.sol\";\n\nimport \"../../interfaces/ILiquidityZap.sol\";\nimport \"../../interfaces/IPoolHelper.sol\";\nimport \"../../interfaces/IMultiFeeDistribution.sol\";\nimport \"../../misc/interfaces/IWETH.sol\";\nimport \"../../interfaces/ILendingPool.sol\";\nimport \"../../interfaces/balancer/IWeightedPoolFactory.sol\";\n\n/// @title Balance Pool Helper Contract\n/// @author Radiant\ncontract BalancerPoolHelper is IPoolHelper, Initializable, OwnableUpgradeable, BNum, DustRefunder {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    address public inTokenAddr;\n    address public outTokenAddr;\n    address public wethAddr;\n    address public wstETHAddr;\n    address public wstEthLpAddr;\n    address public override lpTokenAddr;\n    address public vaultAddr;\n    bytes32 public poolId;\n    IWeightedPoolFactory public poolFactory;\n\n    function initialize(\n        address _inTokenAddr,\n        address _outTokenAddr,\n        address _wethAddr,\n        address _wstETHAddr,\n        address _vault,\n        IWeightedPoolFactory _poolFactory,\n        address _wstEthLpAddr\n    ) external initializer {\n        __Ownable_init();\n\n        inTokenAddr = _inTokenAddr;\n        outTokenAddr = _outTokenAddr;\n        wethAddr = _wethAddr;\n        wstETHAddr = _wstETHAddr;\n\n        vaultAddr = _vault;\n        poolFactory = _poolFactory;\n        wstEthLpAddr = _wstEthLpAddr;\n    }\n\n    function initializePool() public override {\n        require(lpTokenAddr == address(0), \"Already initialized\");\n\n        (address token0, address token1) = sortTokens(\n            inTokenAddr,\n            outTokenAddr\n        );\n\n        uint256[] memory weights = new uint256[](2);\n\n        if (token0 == outTokenAddr) {\n            weights[0] = 800000000000000000;\n            weights[1] = 200000000000000000;\n        } else {\n            weights[0] = 200000000000000000;\n            weights[1] = 800000000000000000;\n        }\n\n        IERC20[] memory tokens = new IERC20[](2);\n        tokens[0] = IERC20(token0);\n        tokens[1] = IERC20(token1);\n\n        uint256 swapFeePercentage = 1000000000000000;\n\n        lpTokenAddr = poolFactory.create(\n            \"wstETH-NOOVA\",\n            \"wstETH-NOVA\",\n            tokens,\n            weights,\n            swapFeePercentage,\n            address(this)\n        );\n\n        poolId = IWeightedPool(lpTokenAddr).getPoolId();\n\n        IERC20 outToken = IERC20(outTokenAddr);\n        IERC20 inToken = IERC20(inTokenAddr);\n        IERC20 lp = IERC20(lpTokenAddr);\n        IERC20 weth = IERC20(wethAddr);\n\n        outToken.safeApprove(vaultAddr, type(uint256).max);\n        inToken.safeApprove(vaultAddr, type(uint256).max);\n        lp.safeApprove(vaultAddr, type(uint256).max);\n        weth.approve(vaultAddr, type(uint256).max);\n\n        IAsset[] memory assets = new IAsset[](2);\n        assets[0] = IAsset(token0);\n        assets[1] = IAsset(token1);\n\n        uint256 ethAmt = inToken.balanceOf(address(this));\n        uint256 rdntAmt = outToken.balanceOf(address(this));\n\n        uint256[] memory maxAmountsIn = new uint256[](2);\n        if (token0 == inTokenAddr) {\n            maxAmountsIn[0] = ethAmt;\n            maxAmountsIn[1] = rdntAmt;\n        } else {\n            maxAmountsIn[0] = rdntAmt;\n            maxAmountsIn[1] = ethAmt;\n        }\n\n        IVault.JoinPoolRequest memory InRequest = IVault.JoinPoolRequest(\n            assets,\n            maxAmountsIn,\n            abi.encode(0, maxAmountsIn),\n            false\n        );\n        IVault(vaultAddr).joinPool(\n            poolId,\n            address(this),\n            address(this),\n            InRequest\n        );\n        uint256 liquidity = lp.balanceOf(address(this));\n        lp.safeTransfer(msg.sender, liquidity);\n    }\n\n    /// @dev Return fair reserve amounts given spot reserves, weights, and fair prices.\n    /// @param resA Reserve of the first asset\n    /// @param resB Reserve of the second asset\n    /// @param wA Weight of the first asset\n    /// @param wB Weight of the second asset\n    /// @param pxA Fair price of the first asset\n    /// @param pxB Fair price of the second asset\n    function computeFairReserves(\n        uint256 resA,\n        uint256 resB,\n        uint256 wA,\n        uint256 wB,\n        uint256 pxA,\n        uint256 pxB\n    ) internal pure returns (uint256 fairResA, uint256 fairResB) {\n        // NOTE: wA + wB = 1 (normalize weights)\n        // constant product = resA^wA * resB^wB\n        // constraints:\n        // - fairResA^wA * fairResB^wB = constant product\n        // - fairResA * pxA / wA = fairResB * pxB / wB\n        // Solving equations:\n        // --> fairResA^wA * (fairResA * (pxA * wB) / (wA * pxB))^wB = constant product\n        // --> fairResA / r1^wB = constant product\n        // --> fairResA = resA^wA * resB^wB * r1^wB\n        // --> fairResA = resA * (resB/resA)^wB * r1^wB = resA * (r1/r0)^wB\n        uint256 r0 = bdiv(resA, resB);\n        uint256 r1 = bdiv(bmul(wA, pxB), bmul(wB, pxA));\n        // fairResA = resA * (r1 / r0) ^ wB\n        // fairResB = resB * (r0 / r1) ^ wA\n        if (r0 > r1) {\n            uint256 ratio = bdiv(r1, r0);\n            fairResA = bmul(resA, bpow(ratio, wB));\n            fairResB = bdiv(resB, bpow(ratio, wA));\n        } else {\n            uint256 ratio = bdiv(r0, r1);\n            fairResA = bdiv(resA, bpow(ratio, wB));\n            fairResB = bmul(resB, bpow(ratio, wA));\n        }\n    }\n\n    function getLpPrice(uint256 rdntPriceInEth)\n        public\n        view\n        override\n        returns (uint256 priceInEth)\n    {\n        IWeightedPool pool = IWeightedPool(lpTokenAddr);\n        (uint256 rdntBalance, uint256 wethBalance, ) = getReserves();\n        // RDNT in eth, 8 decis\n        uint256 pxA = rdntPriceInEth;\n        // ETH in eth, 8 decis\n        uint256 pxB = 100000000;\n\n        uint256[] memory weights = pool.getNormalizedWeights();\n\n        (uint256 fairResA, uint256 fairResB) = computeFairReserves(\n            rdntBalance,\n            wethBalance,\n            weights[0],\n            weights[1],\n            pxA,\n            pxB\n        );\n        // use fairReserveA and fairReserveB to compute LP token price\n        // LP price = (fairResA * pxA + fairResB * pxB) / totalLPSupply\n        return fairResA.mul(pxA).add(fairResB.mul(pxB)).div(pool.totalSupply());\n    }\n\n    function _getPrice() internal view returns (uint256 priceInEth) {\n        (\n            IERC20[] memory tokens,\n            uint256[] memory balances,\n        ) = IVault(vaultAddr).getPoolTokens(poolId);\n\n        uint256 rdntBalance = address(tokens[0]) == outTokenAddr\n            ? balances[0]\n            : balances[1];\n        uint256 wethBalance = address(tokens[0]) == outTokenAddr\n            ? balances[1]\n            : balances[0];\n\n        uint256 poolWeight = 4;\n\n        return wethBalance.mul(1e8).div(rdntBalance.div(poolWeight));\n    }\n\n    function getReserves()\n        public\n        view\n        override\n        returns (\n            uint256 rdnt,\n            uint256 weth,\n            uint256 lpTokenSupply\n        )\n    {\n        IERC20 lpToken = IERC20(lpTokenAddr);\n\n        (IERC20[] memory tokens, uint256[] memory balances, ) = IVault(\n            vaultAddr\n        ).getPoolTokens(poolId);\n\n        rdnt = address(tokens[0]) == outTokenAddr ? balances[0] : balances[1];\n        weth = address(tokens[0]) == outTokenAddr ? balances[1] : balances[0];\n\n        lpTokenSupply = lpToken.totalSupply().div(1e18);\n    }\n\n    function joinPool(uint256 _wethAmt, uint256 _rdntAmt)\n        internal\n        returns (uint256 liquidity)\n    {\n        uint256 amountWsETH = swap(\n            _wethAmt,\n            wethAddr,\n            wstETHAddr,\n            wstEthLpAddr\n        );\n\n        (address token0, address token1) = sortTokens(\n            outTokenAddr,\n            inTokenAddr\n        );\n        IAsset[] memory assets = new IAsset[](2);\n        assets[0] = IAsset(token0);\n        assets[1] = IAsset(token1);\n\n        uint256[] memory maxAmountsIn = new uint256[](2);\n        if (token0 == inTokenAddr) {\n            maxAmountsIn[0] = amountWsETH;\n            maxAmountsIn[1] = _rdntAmt;\n        } else {\n            maxAmountsIn[0] = _rdntAmt;\n            maxAmountsIn[1] = amountWsETH;\n        }\n\n        bytes memory userDataEncoded = abi.encode(\n            IWeightedPool.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,\n            maxAmountsIn,\n            0\n        );\n        IVault.JoinPoolRequest memory InRequest = IVault.JoinPoolRequest(\n            assets,\n            maxAmountsIn,\n            userDataEncoded,\n            false\n        );\n        IVault(vaultAddr).joinPool(\n            poolId,\n            address(this),\n            address(this),\n            InRequest\n        );\n\n        IERC20 lp = IERC20(lpTokenAddr);\n        liquidity = lp.balanceOf(address(this));\n    }\n\n    function zapWETH(uint256 amount)\n        public\n        override\n        returns (uint256 liquidity)\n    {\n        IWETH(wethAddr).transferFrom(msg.sender, address(this), amount);\n        liquidity = joinPool(amount, 0);\n        IERC20 lp = IERC20(lpTokenAddr);\n        lp.safeTransfer(msg.sender, liquidity);\n        refundDust(outTokenAddr, wethAddr, msg.sender);\n    }\n\n    function zapTokens(uint256 _wethAmt, uint256 _rdntAmt)\n        public\n        override\n        returns (uint256 liquidity)\n    {\n        IWETH(wethAddr).transferFrom(msg.sender, address(this), _wethAmt);\n        IERC20(outTokenAddr).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _rdntAmt\n        );\n\n        liquidity = joinPool(_wethAmt, _rdntAmt);\n        IERC20 lp = IERC20(lpTokenAddr);\n        lp.safeTransfer(msg.sender, liquidity);\n\n        refundDust(outTokenAddr, wethAddr, msg.sender);\n    }\n\n    function sortTokens(address tokenA, address tokenB)\n        internal\n        pure\n        returns (address token0, address token1)\n    {\n        require(tokenA != tokenB, \"BalancerZap: IDENTICAL_ADDRESSES\");\n        (token0, token1) = tokenA < tokenB\n            ? (tokenA, tokenB)\n            : (tokenB, tokenA);\n        require(token0 != address(0), \"BalancerZap: ZERO_ADDRESS\");\n    }\n\n    function quoteFromToken(uint256 tokenAmount)\n        public\n        view\n        override\n        returns (uint256 optimalWETHAmount)\n    {\n        uint256 rdntPriceInEth = _getPrice();\n        uint256 p1 = rdntPriceInEth.mul(1e10);\n        uint256 ethRequiredBeforeWeight = tokenAmount.mul(p1).div(1e18);\n        optimalWETHAmount = ethRequiredBeforeWeight.div(4);\n    }\n\n    function swap(\n        uint256 _amount,\n        address _tokenInAddress,\n        address _tokenOutAddress,\n        address _lpAddr\n    ) internal returns (uint256 amountOut) {\n        IAsset tokenInAddress = IAsset(_tokenInAddress);\n        IAsset tokenOutAddress = IAsset(_tokenOutAddress);\n\n        bytes32 _poolId = IWeightedPool(_lpAddr).getPoolId();\n\n        bytes memory userDataEncoded = abi.encode(); //https://dev.balancer.fi/helpers/encoding\n        IVault.SingleSwap memory SingleSwapRequest = IVault.SingleSwap(\n            _poolId,\n            IVault.SwapKind.GIVEN_IN,\n            tokenInAddress,\n            tokenOutAddress,\n            _amount,\n            userDataEncoded\n        );\n        IVault.FundManagement memory FundManagementRequest = IVault\n            .FundManagement(\n                address(this),\n                false,\n                payable(address(this)),\n                false\n            );\n\n        uint256 limit = 0;\n\n        amountOut = IVault(vaultAddr).swap(\n            SingleSwapRequest,\n            FundManagementRequest,\n            limit,\n            (block.timestamp + 3 minutes)\n        );\n    }\n}\n"
    },
    "contracts/zap/helpers/DustRefunder.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../../dependencies/openzeppelin/contracts/IERC20.sol\";\nimport \"../../dependencies/openzeppelin/contracts/SafeERC20.sol\";\nimport \"../../misc/interfaces/IWETH.sol\";\n\ncontract DustRefunder {\n    using SafeERC20 for IERC20;\n\n    function refundDust(\n        address _rdnt,\n        address _weth,\n        address _refundAddress\n    ) internal {\n        IERC20 rdnt = IERC20(_rdnt);\n        IWETH weth = IWETH(_weth);\n\n        uint256 dustWETH = weth.balanceOf(address(this));\n        if(dustWETH > 0) {\n            weth.transfer(_refundAddress, dustWETH);\n        }\n        uint256 dustRdnt = rdnt.balanceOf(address(this));\n        if(dustRdnt > 0) {\n            rdnt.safeTransfer(_refundAddress, dustRdnt);\n        }\n    }\n}\n"
    },
    "contracts/zap/helpers/LiquidityZap.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.7.6;\n\n//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\n//\n// LiquidityZAP takes ETH and converts to  liquidity tokens.\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with this program.\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// Attribution: CORE / cvault.finance\n//  https://github.com/cVault-finance/CORE-periphery/blob/master/contracts/COREv1Router.sol\n//\n//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\n//----------------------------------------------------------------------------------\n//    I n s t a n t\n//\n//        .:mmm.         .:mmm:.       .ii.  .:SSSSSSSSSSSSS.     .oOOOOOOOOOOOo.\n//      .mMM'':Mm.     .:MM'':Mm:.     .II:  :SSs..........     .oOO'''''''''''OOo.\n//    .:Mm'   ':Mm.   .:Mm'   'MM:.    .II:  'sSSSSSSSSSSSSS:.  :OO.           .OO:\n//  .'mMm'     ':MM:.:MMm'     ':MM:.  .II:  .:...........:SS.  'OOo:.........:oOO'\n//  'mMm'        ':MMmm'         'mMm:  II:  'sSSSSSSSSSSSSS'     'oOOOOOOOOOOOO'\n//\n//----------------------------------------------------------------------------------\n\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\nimport \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\nimport \"../../misc/interfaces/IWETH.sol\";\n\nimport \"../../dependencies/openzeppelin/contracts/IERC20.sol\";\nimport \"../../dependencies/openzeppelin/contracts/SafeMath.sol\";\nimport \"../../dependencies/uniswap/contracts/UniswapV2Library.sol\";\nimport \"../../dependencies/openzeppelin/contracts/SafeERC20.sol\";\nimport \"../../dependencies/openzeppelin/upgradeability/Initializable.sol\";\nimport \"../../dependencies/openzeppelin/upgradeability/OwnableUpgradeable.sol\";\n\ncontract LiquidityZap is Initializable, OwnableUpgradeable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    address public _token;\n    address public _tokenWETHPair;\n    IWETH public _WETH;\n    bool private initialized;\n\n    function initialize() initializer external {\n        __Ownable_init();\n    }\n\n    function initLiquidityZap(\n        address token,\n        address WETH,\n        address tokenWethPair\n    ) external {\n        require(!initialized, \"already initialized\");\n        _token = token;\n        _WETH = IWETH(WETH);\n        _tokenWETHPair = tokenWethPair;\n        initialized = true;\n    }\n\n    fallback() external payable {\n        if (msg.sender != address(_WETH)) {\n            addLiquidityETHOnly(msg.sender);\n        }\n    }\n\n    function zapETH(address payable _onBehalf)\n        external\n        payable\n        returns (uint256 liquidity)\n    {\n        require(\n            msg.value > 0,\n            \"LiquidityZAP: ETH amount must be greater than 0\"\n        );\n        return addLiquidityETHOnly(_onBehalf);\n    }\n\n    function addLiquidityWETHOnly(uint256 _amount, address payable to)\n        public\n        returns (uint256 liquidity)\n    {\n        require(to != address(0), \"LiquidityZAP: Invalid address\");\n        uint256 buyAmount = _amount.div(2);\n        require(buyAmount > 0, \"LiquidityZAP: Insufficient ETH amount\");\n\n        (uint256 reserveWeth, uint256 reserveTokens) = getPairReserves();\n        uint256 outTokens = UniswapV2Library.getAmountOut(\n            buyAmount,\n            reserveWeth,\n            reserveTokens\n        );\n\n        _WETH.transfer(_tokenWETHPair, buyAmount);\n\n        (address token0, address token1) = UniswapV2Library.sortTokens(\n            address(_WETH),\n            _token\n        );\n        IUniswapV2Pair(_tokenWETHPair).swap(\n            _token == token0 ? outTokens : 0,\n            _token == token1 ? outTokens : 0,\n            address(this),\n            \"\"\n        );\n\n        return _addLiquidity(outTokens, buyAmount, to);\n    }\n\n\n    function addLiquidityETHOnly(address payable to)\n        public\n        payable\n        returns (uint256 liquidity)\n    {\n        require(to != address(0), \"LiquidityZAP: Invalid address\");\n        uint256 buyAmount = msg.value.div(2);\n        require(buyAmount > 0, \"LiquidityZAP: Insufficient ETH amount\");\n        _WETH.deposit{value: msg.value}();\n\n        (uint256 reserveWeth, uint256 reserveTokens) = getPairReserves();\n        uint256 outTokens = UniswapV2Library.getAmountOut(\n            buyAmount,\n            reserveWeth,\n            reserveTokens\n        );\n\n        _WETH.transfer(_tokenWETHPair, buyAmount);\n\n        (address token0, address token1) = UniswapV2Library.sortTokens(\n            address(_WETH),\n            _token\n        );\n        IUniswapV2Pair(_tokenWETHPair).swap(\n            _token == token0 ? outTokens : 0,\n            _token == token1 ? outTokens : 0,\n            address(this),\n            \"\"\n        );\n\n        return _addLiquidity(outTokens, buyAmount, to);\n    }\n\n    function quoteFromToken(uint256 tokenAmount)\n        public\n        view\n        returns (uint256 optimalWETHAmount)\n    {\n        (uint256 wethReserve, uint256 tokenReserve) = getPairReserves();\n        optimalWETHAmount = UniswapV2Library.quote(\n            tokenAmount,\n            tokenReserve,\n            wethReserve\n        );\n    }\n\n    function quote(uint256 wethAmount)\n        public\n        view\n        returns (uint256 optimalTokenAmount)\n    {\n        (uint256 wethReserve, uint256 tokenReserve) = getPairReserves();\n        optimalTokenAmount = UniswapV2Library.quote(\n            wethAmount,\n            wethReserve,\n            tokenReserve\n        );\n    }\n\n    // use with quote\n    function standardAdd(uint256 tokenAmount, uint256 _wethAmt, address payable to)\n        public\n        returns (uint256 liquidity)\n    {\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), tokenAmount);\n        _WETH.transferFrom(msg.sender, address(this), _wethAmt);\n        return _addLiquidity(tokenAmount, _wethAmt, to);\n    }\n\n    function _addLiquidity(\n        uint256 tokenAmount,\n        uint256 wethAmount,\n        address payable to\n    ) internal returns (uint256 liquidity) {\n        (uint256 wethReserve, uint256 tokenReserve) = getPairReserves();\n\n        uint256 optimalTokenAmount = UniswapV2Library.quote(\n            wethAmount,\n            wethReserve,\n            tokenReserve\n        );\n\n        uint256 optimalWETHAmount;\n        if (optimalTokenAmount > tokenAmount) {\n            optimalWETHAmount = UniswapV2Library.quote(\n                tokenAmount,\n                tokenReserve,\n                wethReserve\n            );\n            optimalTokenAmount = tokenAmount;\n        } else optimalWETHAmount = wethAmount;\n\n        assert(_WETH.transfer(_tokenWETHPair, optimalWETHAmount));\n        IERC20(_token).safeTransfer(_tokenWETHPair, optimalTokenAmount);\n\n        liquidity = IUniswapV2Pair(_tokenWETHPair).mint(to);\n\n        //refund dust\n        if (tokenAmount > optimalTokenAmount)\n            IERC20(_token).safeTransfer(\n                to,\n                tokenAmount.sub(optimalTokenAmount)\n            );\n        if (wethAmount > optimalWETHAmount) {\n            _WETH.transfer(\n                to,\n                wethAmount.sub(optimalWETHAmount)\n            );\n        }\n    }\n\n    function getLPTokenPerEthUnit(uint256 ethAmt)\n        public\n        view\n        returns (uint256 liquidity)\n    {\n        (uint256 reserveWeth, uint256 reserveTokens) = getPairReserves();\n        uint256 outTokens = UniswapV2Library.getAmountOut(\n            ethAmt.div(2),\n            reserveWeth,\n            reserveTokens\n        );\n        uint256 _totalSupply = IUniswapV2Pair(_tokenWETHPair).totalSupply();\n\n        (address token0, ) = UniswapV2Library.sortTokens(\n            address(_WETH),\n            _token\n        );\n        (uint256 amount0, uint256 amount1) = token0 == _token\n            ? (outTokens, ethAmt.div(2))\n            : (ethAmt.div(2), outTokens);\n        (uint256 _reserve0, uint256 _reserve1) = token0 == _token\n            ? (reserveTokens, reserveWeth)\n            : (reserveWeth, reserveTokens);\n        liquidity = SafeMath.min(\n            amount0.mul(_totalSupply) / _reserve0,\n            amount1.mul(_totalSupply) / _reserve1\n        );\n    }\n\n    function getPairReserves()\n        internal\n        view\n        returns (uint256 wethReserves, uint256 tokenReserves)\n    {\n        (address token0, ) = UniswapV2Library.sortTokens(\n            address(_WETH),\n            _token\n        );\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(_tokenWETHPair)\n            .getReserves();\n        (wethReserves, tokenReserves) = token0 == _token\n            ? (reserve1, reserve0)\n            : (reserve0, reserve1);\n    }\n}\n"
    },
    "contracts/zap/helpers/UniswapPoolHelper.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"./DustRefunder.sol\";\n\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\";\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\nimport \"../../dependencies/uniswap/contracts/UniswapV2Library.sol\";\n\nimport \"../../dependencies/openzeppelin/contracts/IERC20.sol\";\nimport \"../../dependencies/openzeppelin/contracts/SafeERC20.sol\";\nimport \"../../dependencies/openzeppelin/contracts/SafeMath.sol\";\nimport \"../../dependencies/openzeppelin/upgradeability/Initializable.sol\";\nimport \"../../dependencies/openzeppelin/upgradeability/OwnableUpgradeable.sol\";\nimport \"../../dependencies/uniswap/contracts/UniswapV2Library.sol\";\nimport \"../../dependencies/math/HomoraMath.sol\";\n\nimport \"../../interfaces/uniswap/IUniswapV2Router02.sol\";\nimport \"../../interfaces/ILiquidityZap.sol\";\nimport \"../../interfaces/IMultiFeeDistribution.sol\";\nimport \"../../misc/interfaces/IWETH.sol\";\nimport \"../../interfaces/ILendingPool.sol\";\nimport \"../../interfaces/IPoolHelper.sol\";\n\ncontract UniswapPoolHelper is Initializable, OwnableUpgradeable, DustRefunder {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using HomoraMath for uint;\n\n\n    address public lpTokenAddr;\n    address public rdntAddr;\n    address public wethAddr;\n\n    IUniswapV2Router02 public router;\n    ILiquidityZap public liquidityZap;\n\n    function initialize(\n        address _rdntAddr,\n        address _wethAddr,\n        address _routerAddr,\n        ILiquidityZap _liquidityZap\n    ) external initializer {\n        __Ownable_init();\n\n        rdntAddr = _rdntAddr;\n        wethAddr = _wethAddr;\n\n        router = IUniswapV2Router02(_routerAddr);\n        liquidityZap = _liquidityZap;\n    }\n\n    receive() external payable {}\n\n    function initializePool() public {\n        lpTokenAddr = IUniswapV2Factory(router.factory()).createPair(\n            rdntAddr,\n            wethAddr\n        );\n\n        IERC20 rdnt = IERC20(rdntAddr);\n        rdnt.safeApprove(address(router), type(uint256).max);\n        rdnt.safeApprove(address(liquidityZap), type(uint256).max);\n        IERC20(wethAddr).approve(address(liquidityZap), type(uint256).max);\n        IERC20(wethAddr).approve(address(router), type(uint256).max);\n\n        router.addLiquidity(\n            address(rdnt),\n            wethAddr,\n            rdnt.balanceOf(address(this)),\n            IERC20(wethAddr).balanceOf(address(this)),\n            0,\n            0,\n            address(this),\n            block.timestamp\n        );\n\n        IERC20 lp = IERC20(lpTokenAddr);\n        lp.safeTransfer(msg.sender, lp.balanceOf(address(this)));\n\n        liquidityZap.initLiquidityZap(rdntAddr, wethAddr, lpTokenAddr);\n    }\n\n    function zapWETH(uint256 amount)\n        public\n        returns (uint256 liquidity)\n    {\n        IWETH WETH = IWETH(wethAddr);\n        WETH.transferFrom(msg.sender, address(liquidityZap), amount);\n        liquidity = liquidityZap.addLiquidityWETHOnly(amount, address(this));\n        IERC20 lp = IERC20(lpTokenAddr);\n        \n        liquidity = lp.balanceOf(address(this));\n        lp.safeTransfer(msg.sender, liquidity);\n        refundDust(rdntAddr, wethAddr, msg.sender);\n    }\n\n    function getReserves() public view returns (\n        uint256 rdnt,\n        uint256 weth,\n        uint256 lpTokenSupply\n    ) {\n        IUniswapV2Pair lpToken = IUniswapV2Pair(lpTokenAddr);\n\n        (uint256 reserve0, uint256 reserve1, ) = lpToken.getReserves();\n        weth = lpToken.token0() != address(rdntAddr)\n            ? reserve0\n            : reserve1;\n        rdnt = lpToken.token0() == address(rdntAddr)\n            ? reserve0\n            : reserve1;\n\n        lpTokenSupply = lpToken.totalSupply();\n    }\n\n    // UniV2 / SLP LP Token Price\n    // Alpha Homora Fair LP Pricing Method (flash loan resistant)\n    // https://cmichel.io/pricing-lp-tokens/\n    // https://blog.alphafinance.io/fair-lp-token-pricing/\n    // https://github.com/AlphaFinanceLab/alpha-homora-v2-contract/blob/master/contracts/oracle/UniswapV2Oracle.sol\n    function getLpPrice(uint rdntPriceInEth) public view returns (uint256 priceInEth) {\n        IUniswapV2Pair lpToken = IUniswapV2Pair(lpTokenAddr);\n\n        (uint reserve0, uint reserve1, ) = lpToken.getReserves();\n        uint wethReserve = lpToken.token0() != address(rdntAddr)\n            ? reserve0\n            : reserve1;\n        uint rdntReserve = lpToken.token0() == address(rdntAddr)\n            ? reserve0\n            : reserve1;\n\n        uint lpSupply = lpToken.totalSupply();\n\n        uint sqrtK = HomoraMath.sqrt(rdntReserve.mul(wethReserve)).fdiv(lpSupply); // in 2**112\n\n        // rdnt in eth, decis 8\n        uint px0 = rdntPriceInEth.mul(2 ** 112); // in 2**112\n        // eth in eth, decis 8\n        uint px1 = uint256(100000000).mul(2 ** 112); // in 2**112\n\n        // fair token0 amt: sqrtK * sqrt(px1/px0)\n        // fair token1 amt: sqrtK * sqrt(px0/px1)\n        // fair lp price = 2 * sqrt(px0 * px1)\n        // split into 2 sqrts multiplication to prevent uint overflow (note the 2**112)\n        uint result = sqrtK.mul(2).mul(HomoraMath.sqrt(px0)).div(2**56).mul(HomoraMath.sqrt(px1)).div(2**56);\n        priceInEth = result.div(2 ** 112);\n    }\n\n    function zapTokens(uint256 _wethAmt, uint256 _rdntAmt)\n        public\n        returns (uint256 liquidity)\n    {\n        IWETH WETH = IWETH(wethAddr);\n        WETH.transferFrom(msg.sender, address(this), _wethAmt);\n        IERC20(rdntAddr).safeTransferFrom(msg.sender, address(this), _rdntAmt);\n        liquidity = liquidityZap.standardAdd(\n            _rdntAmt,\n            _wethAmt,\n            address(this)\n        );\n        IERC20 lp = IERC20(lpTokenAddr);\n        liquidity = lp.balanceOf(address(this));\n        lp.safeTransfer(msg.sender, liquidity);\n        refundDust(rdntAddr, wethAddr, msg.sender);\n    }\n\n    function quoteFromToken(uint256 tokenAmount)\n        public\n        view\n        returns (uint256 optimalWETHAmount)\n    {\n        return liquidityZap.quoteFromToken(tokenAmount);\n    }\n\n    function getLiquidityZap() public view returns (address) {\n        return address(liquidityZap);\n    }\n\n    function setLiquidityZap (address _liquidityZap) external onlyOwner {\n        liquidityZap = ILiquidityZap(_liquidityZap);\n    }\n}\n"
    },
    "contracts/zap/LockZap.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"./helpers/DustRefunder.sol\";\n\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\";\n\nimport \"../dependencies/openzeppelin/contracts/IERC20.sol\";\nimport \"../dependencies/openzeppelin/contracts/ERC20.sol\";\nimport \"../dependencies/openzeppelin/contracts/SafeERC20.sol\";\nimport \"../dependencies/openzeppelin/contracts/SafeMath.sol\";\nimport \"../dependencies/openzeppelin/upgradeability/Initializable.sol\";\nimport \"../dependencies/openzeppelin/upgradeability/OwnableUpgradeable.sol\";\nimport \"../dependencies/openzeppelin/upgradeability/PausableUpgradeable.sol\";\n\nimport \"../interfaces/uniswap/IUniswapV2Router02.sol\";\nimport \"../interfaces/ILiquidityZap.sol\";\nimport \"../interfaces/IMultiFeeDistribution.sol\";\nimport \"../interfaces/ILendingPool.sol\";\nimport \"../interfaces/IPoolHelper.sol\";\nimport \"../interfaces/IPriceProvider.sol\";\nimport \"../interfaces/IChainlinkAggregator.sol\";\nimport \"../misc/interfaces/IWETH.sol\";\n\n/// @title Borrow gate via stargate\n/// @author Radiant\n/// @dev All function calls are currently implemented without side effects\ncontract LockZap is Initializable, OwnableUpgradeable, PausableUpgradeable, DustRefunder {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    /// @notice RAITO Divisor\n    uint256 public constant RATIO_DIVISOR = 10000;\n\n    /// @notice Acceptable ratio\n    uint256 public constant ACCEPTABLE_RATIO = 9500;\n\n    /// @notice Wrapped ETH\n    IWETH public WETH;\n\n    /// @notice RDNT token address\n    address public rdntAddr;\n\n    /// @notice LP Fee distribution contract\n    IMultiFeeDistribution public lpMfd;\n\n    /// @notice Multi Fee distribution contract\n    IMultiFeeDistribution public mfd;\n\n    /// @notice Lending Pool contract\n    ILendingPool public lendingPool;\n\n    /// @notice Pool helper contract\n    IPoolHelper public poolHelper;\n\n    /// @notice Price provider contract\n    IPriceProvider public priceProvider;\n\n    /// @notice ETH oracle contract\n    IChainlinkAggregator public ethOracle;\n\n    /// @notice Emitted when zap is done\n    event Zapped(\n        bool _borrow,\n        uint256 _ethAmt,\n        uint256 _rdntAmt,\n        address indexed _from,\n        address indexed _onBehalf,\n        uint256 _lockTypeIndex\n    );\n\n    uint256 public ETH_LP_RATIO; // paramter to set the ratio of ETH in the LP token, can be 2000 for an 80/20 bal lp\n\n\n    /**\n     * @notice Initializer\n     * @param _poolHelper Pool helper address\n     * @param _lendingPool Lending pool\n     * @param _weth WETH address\n     * @param _rdntAddr RDNT token address\n     */\n    function initialize(\n        IPoolHelper _poolHelper,\n        ILendingPool _lendingPool,\n        IWETH _weth,\n        address _rdntAddr\n    ) external initializer {\n        __Ownable_init();\n        __Pausable_init();\n\n        lendingPool = _lendingPool;\n        poolHelper = _poolHelper;\n        WETH = _weth;\n        rdntAddr = _rdntAddr;\n        ETH_LP_RATIO = 5000;\n    }\n\n    receive() external payable {}\n\n    /**\n     * @notice Set Price Provider.\n     * @param _provider Price provider contract address.\n     */\n    function setPriceProvider(address _provider) external onlyOwner {\n        priceProvider = IPriceProvider(_provider);\n        ethOracle = IChainlinkAggregator(priceProvider.baseTokenPriceInUsdProxyAggregator());\n    }\n\n    /**\n     * @notice Set LP fee distribution contract.\n     * @param _lpMfdAddr New contract address.\n     */\n    function setLpMfd(address _lpMfdAddr) external onlyOwner {\n        lpMfd = IMultiFeeDistribution(_lpMfdAddr);\n    }\n\n    /**\n     * @notice Set Multi fee distribution contract.\n     * @param _mfdAddr New contract address.\n     */\n    function setMfd(address _mfdAddr) external onlyOwner {\n        mfd = IMultiFeeDistribution(_mfdAddr);\n    }\n\n    /**\n     * @notice Set Pool Helper contract\n     * @param _poolHelper New PoolHelper contract address.\n     */\n    function setPoolHelper (address _poolHelper) external onlyOwner {\n        poolHelper = IPoolHelper(_poolHelper);\n    }\n\n    /**\n     * @notice Returns pool helper address\n     */\n    function getPoolHelper() public view returns (address) {\n        return address(poolHelper);\n    }\n\n    /**\n     * @notice Get Variable debt token address\n     * @param _asset underlying.\n     */\n    function getVDebtToken(address _asset) public view returns (address) {\n        DataTypes.ReserveData memory reserveData = lendingPool.getReserveData(\n            _asset\n        );\n        return reserveData.variableDebtTokenAddress;\n    }\n\n    /**\n     * @notice Get quote from the pool\n     * @param _tokenAmount amount of tokens.\n     */\n    function quoteFromToken(uint256 _tokenAmount) public view returns (uint256 optimalWETHAmount) {\n        return poolHelper.quoteFromToken(_tokenAmount);\n    }\n\n    /**\n     * @notice Zap tokens to stake LP\n     * @param _borrow option to borrow ETH\n     * @param _wethAmt amount of WETH.\n     * @param _rdntAmt amount of RDNT.\n     * @param _lockTypeIndex lock length index.\n     */\n    function zap(\n        bool _borrow,\n        uint256 _wethAmt,\n        uint256 _rdntAmt,\n        uint256 _lockTypeIndex\n    ) public payable returns (uint256 liquidity) {\n        return _zap(_borrow, _wethAmt, _rdntAmt, msg.sender, msg.sender, _lockTypeIndex, msg.sender);\n    }\n\n    /**\n     * @notice Zap tokens to stake LP\n     * @dev It will use default lock index\n     * @param _borrow option to borrow ETH\n     * @param _wethAmt amount of WETH.\n     * @param _rdntAmt amount of RDNT.\n     * @param _onBehalf user address to be zapped.\n     */\n    function zapOnBehalf(\n        bool _borrow,\n        uint256 _wethAmt,\n        uint256 _rdntAmt,\n        address _onBehalf\n    ) public payable returns (uint256 liquidity) {\n        uint256 duration = lpMfd.defaultLockIndex(_onBehalf);\n        return _zap(_borrow, _wethAmt, _rdntAmt, msg.sender, _onBehalf, duration, _onBehalf);\n    }\n\n    /**\n     * @notice Zap tokens from vesting\n     * @param _borrow option to borrow ETH\n     * @param _lockTypeIndex lock length index.\n     */\n    function zapFromVesting(bool _borrow, uint256 _lockTypeIndex) public payable returns (uint256 liquidity) {\n        uint256 rdntAmt = mfd.zapVestingToLp(msg.sender);\n        uint256 wethAmt = quoteFromToken(rdntAmt);\n        return _zap(_borrow, wethAmt, rdntAmt, address(this), msg.sender, _lockTypeIndex, msg.sender);\n    }\n\n    /**\n     * @notice Borrow ETH\n     * @param _amount of ETH\n     */\n    function _executeBorrow(uint256 _amount) internal {\n        (, , uint256 availableBorrowsETH, , , ) = lendingPool\n            .getUserAccountData(msg.sender);\n        uint256 amountInETH = _amount.mul(10**8).div(\n            10**ERC20(address(WETH)).decimals()\n        );\n        require(\n            availableBorrowsETH > amountInETH,\n            \"Not enough availableBorrowsETH\"\n        );\n\n        uint16 referralCode = 0;\n        lendingPool.borrow(\n            address(WETH),\n            _amount,\n            2,\n            referralCode,\n            msg.sender\n        );\n    }\n\n    /**\n     * @notice Calculates slippage ratio from WETH to LP\n     * @param _ethAmt ETH amount\n     * @param _liquidity LP token amount\n     */\n    function _calcSlippage(uint256 _ethAmt, uint256 _liquidity) internal returns (uint256 ratio) {\n        priceProvider.update();\n        uint256 priceWETHamount = _ethAmt.mul(uint256(ethOracle.latestAnswer())).div(1E18);\n        uint256 priceLPamount = _liquidity * priceProvider.getLpTokenPriceUsd();\n        ratio = priceLPamount.mul(RATIO_DIVISOR).div(priceWETHamount);\n        ratio = ratio.div(1E18);\n    }\n\n    /**\n     * @notice Zap into LP\n     * @param _borrow option to borrow ETH\n     * @param _wethAmt amount of WETH.\n     * @param _rdntAmt amount of RDNT.\n     * @param _from src address of RDNT\n     * @param _onBehalf of the user.\n     * @param _lockTypeIndex lock length index.\n     * @param _refundAddress dust is refunded to this address.\n     */\n    function _zap(\n        bool _borrow,\n        uint256 _wethAmt,\n        uint256 _rdntAmt,\n        address _from,\n        address _onBehalf,\n        uint256 _lockTypeIndex,\n        address _refundAddress\n    ) internal returns (uint256 liquidity) {\n        require(\n            _wethAmt != 0 ||\n            msg.value != 0\n        , \"ETH required\");\n\n        if(msg.value != 0) {\n            require(!_borrow, \"invalid zap ETH source\");\n            _wethAmt = msg.value;\n            WETH.deposit{value: _wethAmt}();\n        } else {\n            if (_borrow) {\n                _executeBorrow(_wethAmt);\n            } else {\n                WETH.transferFrom(msg.sender, address(this), _wethAmt);\n            }\n        }\n\n        WETH.approve(address(poolHelper), _wethAmt);\n        //case where rdnt is matched with borrowed ETH\n        if(_rdntAmt != 0) {\n            require(_wethAmt >= quoteFromToken(_rdntAmt), \"ETH sent is not enough\");\n            \n            // _from == this when zapping from vesting\n            if (_from != address(this)) {\n                IERC20(rdntAddr).safeTransferFrom(msg.sender, address(this), _rdntAmt);\n            }\n            \n            IERC20(rdntAddr).safeApprove(address(poolHelper), _rdntAmt);\n            liquidity = poolHelper.zapTokens(_wethAmt, _rdntAmt);\n            if(address(priceProvider) != address(0)){\n                uint256 slippage = _calcSlippage(_wethAmt.mul(RATIO_DIVISOR).div(ETH_LP_RATIO), liquidity);\n                require(slippage >= ACCEPTABLE_RATIO, \"too much slippage\");\n            }\n        } else {\n            liquidity = poolHelper.zapWETH(_wethAmt);\n            if(address(priceProvider) != address(0)){\n                uint256 slippage = _calcSlippage(_wethAmt, liquidity);\n                require(slippage >= ACCEPTABLE_RATIO, \"too much slippage\");\n            }\n        }\n        \n        IERC20(poolHelper.lpTokenAddr()).safeApprove(\n            address(lpMfd),\n            liquidity\n        );\n        lpMfd.stake(liquidity, _onBehalf, _lockTypeIndex);\n        emit Zapped(_borrow, _wethAmt, _rdntAmt, _from, _onBehalf, _lockTypeIndex);\n\n        refundDust(rdntAddr, address(WETH), _refundAddress);\n    }\n\n\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}